"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatemeleelight"]("main",{

/***/ "./src/physics/physics.ts":
/*!********************************!*\
  !*** ./src/physics/physics.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//@flow\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.land = land;\nexports.physics = physics;\nconst main_1 = __webpack_require__(/*! ../main/main */ \"./src/main/main.ts\");\nconst characters_1 = __webpack_require__(/*! ../main/characters */ \"./src/main/characters.ts\");\nconst sfx_1 = __webpack_require__(/*! ../main/sfx */ \"./src/main/sfx.ts\");\nconst settings_1 = __webpack_require__(/*! ../settings */ \"./src/settings.ts\");\nconst actionStateShortcuts_1 = __webpack_require__(/*! ./actionStateShortcuts */ \"./src/physics/actionStateShortcuts.ts\");\nconst hitDetection_1 = __webpack_require__(/*! ./hitDetection */ \"./src/physics/hitDetection.ts\");\nconst render_1 = __webpack_require__(/*! ../main/render */ \"./src/main/render.ts\");\nconst environmentalCollision_1 = __webpack_require__(/*! ./environmentalCollision */ \"./src/physics/environmentalCollision.ts\");\nconst deepCopyObject_1 = __webpack_require__(/*! ../main/util/deepCopyObject */ \"./src/main/util/deepCopyObject.ts\");\nconst drawVfx_1 = __webpack_require__(/*! ../main/vfx/drawVfx */ \"./src/main/vfx/drawVfx.js\");\nconst stage_1 = __webpack_require__(/*! ../stages/stage */ \"./src/stages/stage.ts\");\nconst activeStage_1 = __webpack_require__(/*! ../stages/activeStage */ \"./src/stages/activeStage.ts\");\nconst Box2D_1 = __webpack_require__(/*! ../main/util/Box2D */ \"./src/main/util/Box2D.ts\");\nconst Vec2D_1 = __webpack_require__(/*! ../main/util/Vec2D */ \"./src/main/util/Vec2D.ts\");\nconst toList_1 = __webpack_require__(/*! ../main/util/toList */ \"./src/main/util/toList.ts\");\nconst extremePoint_1 = __webpack_require__(/*! ../stages/util/extremePoint */ \"./src/stages/util/extremePoint.ts\");\nconst ecbTransform_1 = __webpack_require__(/*! ../main/util/ecbTransform */ \"./src/main/util/ecbTransform.ts\");\nconst linAlg_1 = __webpack_require__(/*! ../main/linAlg */ \"./src/main/linAlg.ts\");\nfunction updatePosition(i, newPosition) {\n    main_1.player[i].phys.pos = newPosition;\n}\n;\nfunction dealWithDamagingStageCollision(i, normal, corner, angular, damageType) {\n    const collisionData = { normal: normal, angular: angular, corner: corner };\n    let damageTypeIndex = -1;\n    switch (damageType) {\n        case \"fire\":\n            damageTypeIndex = 3;\n            break;\n        case \"electric\":\n            damageTypeIndex = 4;\n            break;\n        case \"slash\":\n            damageTypeIndex = 1;\n            break;\n        case \"darkness\":\n            damageTypeIndex = 5;\n            break;\n        default:\n            break;\n    }\n    if (damageTypeIndex !== -1) {\n        hitDetection_1.hitQueue.push([i, collisionData, damageTypeIndex, false, false, true]);\n    }\n}\nfunction dealWithWallCollision(i, newPosition, pt, wallType, wallIndex, input) {\n    updatePosition(i, newPosition);\n    let wallLabel = \"L\";\n    let sign = -1;\n    let isRight = 0;\n    if (wallType[0].toLowerCase() === \"r\") {\n        wallLabel = \"R\";\n        sign = 1;\n        isRight = 1;\n    }\n    const wall = (0, stage_1.getSurfaceFromStage)([wallType, wallIndex], activeStage_1.activeStage);\n    const wallBottom = (0, extremePoint_1.extremePoint)(wall, \"b\");\n    const wallTop = (0, extremePoint_1.extremePoint)(wall, \"t\");\n    const wallNormal = (0, environmentalCollision_1.outwardsWallNormal)(wallBottom, wallTop, wallType);\n    const damageType = wall[2] === undefined ? null : wall[2].damageType;\n    const inDamageState = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"WALLDAMAGE\" || main_1.player[i].actionState === \"DAMAGEFALL\";\n    if (inDamageState && main_1.player[i].phys.techTimer > 0) {\n        main_1.player[i].phys.face = sign;\n        if (input[i][0].x || input[i][0].y || input[i][0].lsY > 0.7) {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLTECHJUMP.init(i, input);\n        }\n        else {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLTECH.init(i, input);\n        }\n    }\n    else if (inDamageState && Math.sign(main_1.player[i].phys.kVel) !== sign && main_1.player[i].hit.hitlag === 0 && Math.pow(main_1.player[i].phys.kVel.x, 2) + Math.pow(main_1.player[i].phys.kVel.y, 2) >= 2.25) {\n        main_1.player[i].phys.face = sign;\n        (0, drawVfx_1.drawVfx)({\n            name: \"wallBounce\",\n            pos: new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.ECBp[1].y),\n            face: sign,\n            f: wallNormal\n        });\n        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLDAMAGE.init(i, input, wallNormal);\n    }\n    else if (main_1.player[i].hit.hitlag === 0) {\n        if (damageType !== undefined && damageType !== null\n            && main_1.player[i].phys.hurtBoxState === 0) {\n            // apply damage\n            dealWithDamagingStageCollision(i, wallNormal, false, pt, damageType);\n        }\n        else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].specialWallCollide) {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].onWallCollide(i, input, wallLabel, wallIndex);\n        }\n        else if (main_1.player[i].phys.canWallJump) {\n            if (main_1.player[i].phys.wallJumpTimer === 254) {\n                if (main_1.player[i].phys.posDelta.x >= 0.5) {\n                    main_1.player[i].phys.wallJumpTimer = 0;\n                }\n            }\n        }\n        if (main_1.player[i].phys.wallJumpTimer >= 0 && main_1.player[i].phys.wallJumpTimer < 120) {\n            if (sign * input[i][0].lsX >= 0.7 &&\n                sign * input[i][3].lsX <= 0 &&\n                main_1.player[i].charAttributes.walljump) {\n                main_1.player[i].phys.wallJumpTimer = 254;\n                main_1.player[i].phys.face = sign;\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLJUMP.init(i, input);\n            }\n            else {\n                main_1.player[i].phys.wallJumpTimer++;\n            }\n        }\n    }\n}\n;\nfunction dealWithPlatformCollision(i, alreadyGrounded, newPosition, ecbpBottom, platformIndex, input) {\n    const platform = (0, stage_1.getSurfaceFromStage)([\"p\", platformIndex], activeStage_1.activeStage);\n    const damageType = platform[2] === undefined ? null : platform[2].damageType;\n    const platLeft = (0, extremePoint_1.extremePoint)(platform, \"l\");\n    const platRight = (0, extremePoint_1.extremePoint)(platform, \"r\");\n    const platNormal = (0, environmentalCollision_1.outwardsWallNormal)(platLeft, platRight, \"g\");\n    if (main_1.player[i].hit.hitlag > 0 || alreadyGrounded || main_1.player[i].phys.grabbedBy !== -1) {\n        updatePosition(i, newPosition);\n    }\n    else {\n        land(i, ecbpBottom, 1, platformIndex, platNormal, input);\n    }\n}\n;\nfunction dealWithGroundCollision(i, alreadyGrounded, newPosition, ecbpBottom, groundIndex, input) {\n    const ground = (0, stage_1.getSurfaceFromStage)([\"g\", groundIndex], activeStage_1.activeStage);\n    const damageType = ground[2] === undefined ? null : ground[2].damageType;\n    const ignoreDamage = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"DAMAGEFALL\" || main_1.player[i].actionState === \"WALLDAMAGE\";\n    const groundLeft = (0, extremePoint_1.extremePoint)(ground, \"l\");\n    const groundRight = (0, extremePoint_1.extremePoint)(ground, \"r\");\n    const groundNormal = (0, environmentalCollision_1.outwardsWallNormal)(groundLeft, groundRight, \"g\");\n    if (!ignoreDamage && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        // apply damage\n        dealWithDamagingStageCollision(i, groundNormal, false, 0, damageType);\n    }\n    else {\n        if (main_1.player[i].hit.hitlag > 0 || alreadyGrounded || main_1.player[i].phys.grabbedBy !== -1) {\n            updatePosition(i, newPosition);\n        }\n        else {\n            land(i, ecbpBottom, 0, groundIndex, groundNormal, input);\n        }\n    }\n}\n;\nfunction fallOffGround(i, side, groundEdgePosition, disableFall, input) {\n    let [stillGrounded, backward] = [true, false];\n    let sign = 1;\n    if (side === \"r\") {\n        sign = -1;\n    }\n    if (disableFall) {\n        main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n        main_1.player[i].phys.pos.x = groundEdgePosition.x + (side === \"l\" ? environmentalCollision_1.additionalOffset : -environmentalCollision_1.additionalOffset);\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, (0, linAlg_1.subtract)(main_1.player[i].phys.pos, main_1.player[i].phys.ECBp[0]));\n    }\n    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canEdgeCancel) {\n        if (main_1.player[i].phys.face === sign) {\n            stillGrounded = false;\n            main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n            backward = true;\n        }\n        else if (Math.abs(input[i][0].lsX) > 0.6\n            || (main_1.player[i].phys.cVel.x === 0 && main_1.player[i].phys.kVel.x === 0)\n            || actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].disableTeeter\n            || main_1.player[i].phys.shielding) {\n            stillGrounded = false;\n            main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n        }\n        else {\n            main_1.player[i].phys.cVel.x = 0;\n            main_1.player[i].phys.pos.x = groundEdgePosition.x + sign * environmentalCollision_1.additionalOffset;\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].OTTOTTO.init(i, input);\n        }\n    }\n    else if (main_1.player[i].phys.cVel.x === 0\n        && main_1.player[i].phys.kVel.x === 0\n        && !actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].inGrab) {\n        stillGrounded = false;\n        main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n    }\n    else {\n        main_1.player[i].phys.cVel.x = 0;\n        main_1.player[i].phys.pos.x = groundEdgePosition.x + sign * environmentalCollision_1.additionalOffset;\n    }\n    return [stillGrounded, backward];\n}\n;\n// ground type and index is a pair, either [\"g\", index] or [\"p\", index]\nfunction dealWithGround(i, ground, groundTypeAndIndex, connected, input) {\n    const damageType = ground[2] === undefined ? null : ground[2].damageType;\n    const ignoreDamage = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"DAMAGEFALL\" || main_1.player[i].actionState === \"WALLDAMAGE\";\n    const leftmostGroundPoint = (0, extremePoint_1.extremePoint)(ground, \"l\");\n    const rightmostGroundPoint = (0, extremePoint_1.extremePoint)(ground, \"r\");\n    const groundNormal = (0, environmentalCollision_1.outwardsWallNormal)(leftmostGroundPoint, rightmostGroundPoint, \"g\");\n    let [stillGrounded, backward] = [true, false];\n    let groundOrPlatform = 0;\n    if (groundTypeAndIndex[0] === \"p\") {\n        groundOrPlatform = 1;\n    }\n    let disableFall = false;\n    let maybeLeftGroundTypeAndIndex = null;\n    let maybeRightGroundTypeAndIndex = null;\n    // first check if the player is allowed to move along the ground, by checking there are no low ceilings\n    const ecb0Height = Math.max(environmentalCollision_1.additionalOffset, main_1.player[i].phys.ECB1[2].y - main_1.player[i].phys.ECB1[0].y - environmentalCollision_1.additionalOffset);\n    const maybeNextPosX = (0, environmentalCollision_1.moveAlongGround)(main_1.player[i].phys.ECB1[0], main_1.player[i].phys.ECBp[0], ecb0Height, ground, activeStage_1.activeStage.ceiling);\n    if (maybeNextPosX !== null) {\n        // ceiling has obstructed grounded movement\n        main_1.player[i].phys.pos.x = maybeNextPosX;\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, new Vec2D_1.Vec2D(maybeNextPosX - main_1.player[i].phys.ECBp[0].x, 0));\n    }\n    if (main_1.player[i].phys.ECBp[0].x < leftmostGroundPoint.x) {\n        if (connected !== null && connected !== undefined) {\n            maybeLeftGroundTypeAndIndex = groundTypeAndIndex[0] === \"g\"\n                ? connected[0][groundTypeAndIndex[1]][0]\n                : connected[1][groundTypeAndIndex[1]][0];\n        }\n        if (maybeLeftGroundTypeAndIndex === null || maybeLeftGroundTypeAndIndex === undefined) { // no other ground to the left\n            [stillGrounded, backward] = fallOffGround(i, \"l\", leftmostGroundPoint, disableFall, input);\n        }\n        else {\n            const [leftGroundType, leftGroundIndex] = maybeLeftGroundTypeAndIndex;\n            switch (leftGroundType) {\n                case \"g\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.ground[leftGroundIndex], [\"g\", leftGroundIndex], connected, input);\n                    break;\n                case \"p\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.platform[leftGroundIndex], [\"p\", leftGroundIndex], connected, input);\n                    break;\n                case \"r\":\n                    const rightWallToTheLeft = activeStage_1.activeStage.wallR[leftGroundIndex];\n                    if ((0, extremePoint_1.extremePoint)(rightWallToTheLeft, \"l\").y > leftmostGroundPoint.y) {\n                        disableFall = true;\n                    }\n                    [stillGrounded, backward] = fallOffGround(i, \"l\", leftmostGroundPoint, disableFall, input);\n                    break;\n                default: // surface to the left is neither ground, platform or right wall\n                    [stillGrounded, backward] = fallOffGround(i, \"l\", leftmostGroundPoint, disableFall, input);\n                    break;\n            }\n        }\n    }\n    else if (main_1.player[i].phys.ECBp[0].x > rightmostGroundPoint.x) {\n        if (connected !== null && connected !== undefined) {\n            maybeRightGroundTypeAndIndex = groundTypeAndIndex[0] === \"g\"\n                ? connected[0][groundTypeAndIndex[1]][1]\n                : connected[1][groundTypeAndIndex[1]][1];\n        }\n        if (maybeRightGroundTypeAndIndex === null || maybeRightGroundTypeAndIndex === undefined) { // no other ground to the right\n            [stillGrounded, backward] = fallOffGround(i, \"r\", rightmostGroundPoint, disableFall, input);\n        }\n        else {\n            const [rightGroundType, rightGroundIndex] = maybeRightGroundTypeAndIndex;\n            switch (rightGroundType) {\n                case \"g\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.ground[rightGroundIndex], [\"g\", rightGroundIndex], connected, input);\n                    break;\n                case \"p\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.platform[rightGroundIndex], [\"p\", rightGroundIndex], connected, input);\n                    break;\n                case \"l\":\n                    const leftWallToTheRight = activeStage_1.activeStage.wallL[rightGroundIndex];\n                    if ((0, extremePoint_1.extremePoint)(leftWallToTheRight, \"r\").y > rightmostGroundPoint.y) {\n                        disableFall = true;\n                    }\n                    [stillGrounded, backward] = fallOffGround(i, \"r\", rightmostGroundPoint, disableFall, input);\n                    break;\n                default: // surface to the right is neither ground, platform or left wall\n                    [stillGrounded, backward] = fallOffGround(i, \"r\", rightmostGroundPoint, disableFall, input);\n                    break;\n            }\n        }\n    }\n    else {\n        const ecbpBottom = main_1.player[i].phys.ECBp[0];\n        const yIntercept = (0, environmentalCollision_1.coordinateIntercept)([ecbpBottom, new Vec2D_1.Vec2D(ecbpBottom.x, ecbpBottom.y + 1)], ground);\n        main_1.player[i].phys.pos.y = main_1.player[i].phys.pos.y + yIntercept.y - ecbpBottom.y + environmentalCollision_1.additionalOffset;\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, new Vec2D_1.Vec2D(0, yIntercept.y - ecbpBottom.y + environmentalCollision_1.additionalOffset));\n        main_1.player[i].phys.onSurface = [groundOrPlatform, groundTypeAndIndex[1]];\n        main_1.player[i].phys.groundAngle = Math.atan2(groundNormal.y, groundNormal.x) || Math.PI / 2;\n    }\n    if (!ignoreDamage && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        // apply damage\n        dealWithDamagingStageCollision(i, groundNormal, false, 0, damageType);\n        stillGrounded = false;\n    }\n    return [stillGrounded, backward];\n}\n;\nfunction dealWithCeilingCollision(i, newPosition, ecbTop, ceilingIndex, input) {\n    updatePosition(i, newPosition);\n    const ceiling = (0, stage_1.getSurfaceFromStage)([\"c\", ceilingIndex], activeStage_1.activeStage);\n    const damageType = ceiling[2] === undefined ? null : ceiling[2].damageType;\n    const ceilingLeft = (0, extremePoint_1.extremePoint)(ceiling, \"l\");\n    const ceilingRight = (0, extremePoint_1.extremePoint)(ceiling, \"r\");\n    const ceilingNormal = (0, environmentalCollision_1.outwardsWallNormal)(ceilingLeft, ceilingRight, \"c\");\n    const ignoreDamage = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"DAMAGEFALL\" || main_1.player[i].actionState === \"WALLDAMAGE\";\n    if (!ignoreDamage && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        // apply damage\n        dealWithDamagingStageCollision(i, ceilingNormal, false, 2, damageType);\n    }\n    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].headBonk && main_1.player[i].phys.cVel.y + main_1.player[i].phys.kVel.y > 0) {\n        if (main_1.player[i].hit.hitstun > 0) {\n            if (main_1.player[i].phys.techTimer > 0) {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHU.init(i, input);\n            }\n            else {\n                (0, drawVfx_1.drawVfx)({\n                    name: \"ceilingBounce\",\n                    pos: ecbTop,\n                    face: 1,\n                    f: ceilingNormal\n                });\n                sfx_1.sounds.bounce.play();\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].STOPCEIL.init(i, input, ceilingNormal);\n            }\n        }\n        else {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].STOPCEIL.init(i, input);\n        }\n    }\n}\n;\nfunction dealWithCornerCollision(i, newPosition, ecb, angularParameter, damageType) {\n    updatePosition(i, newPosition);\n    const insideECBType = angularParameter < 2 ? \"l\" : \"r\";\n    const [same, other] = (0, environmentalCollision_1.getSameAndOther)(angularParameter);\n    const lowerECBPoint = other === 2 ? ecb[same] : ecb[0];\n    const upperECBPoint = other === 2 ? ecb[2] : ecb[same];\n    const normal = (0, environmentalCollision_1.outwardsWallNormal)(lowerECBPoint, upperECBPoint, insideECBType);\n    if (main_1.player[i].hit.hitlag === 0 && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        dealWithDamagingStageCollision(i, normal, true, angularParameter, damageType);\n    }\n}\n;\nfunction land(i, newPosition, t, j, normal, input) {\n    main_1.player[i].phys.pos = newPosition;\n    main_1.player[i].phys.grounded = true;\n    main_1.player[i].phys.doubleJumped = false;\n    main_1.player[i].phys.jumpsUsed = 0;\n    main_1.player[i].phys.airborneTimer = 0;\n    main_1.player[i].phys.fastfalled = false;\n    main_1.player[i].phys.chargeFrames = 0;\n    main_1.player[i].phys.charging = false;\n    main_1.player[i].phys.wallJumpCount = 0;\n    main_1.player[i].phys.thrownHitbox = false;\n    main_1.player[i].phys.sideBJumpFlag = true;\n    main_1.player[i].phys.onSurface = [t, j];\n    main_1.player[i].phys.onLedge = -1;\n    main_1.player[i].rotation = 0;\n    main_1.player[i].rotationPoint = new Vec2D_1.Vec2D(0, 0);\n    main_1.player[i].colourOverlayBoolean = false;\n    main_1.player[i].hitboxes.active = [false, false, false, false];\n    let newNormal = normal;\n    if (newNormal === null || newNormal === undefined || (newNormal.x === 0 && newNormal.y === 0)) {\n        newNormal = new Vec2D_1.Vec2D(0, 1);\n    }\n    main_1.player[i].phys.groundAngle = Math.atan2(newNormal.y, newNormal.x);\n    switch (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].landType) {\n        case 0:\n            // LANDING / NIL\n            if (main_1.player[i].phys.cVel.y >= -1) {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WAIT.init(i, input);\n            }\n            else {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].LANDING.init(i, input);\n            }\n            break;\n        case 1:\n            // OWN FUNCTION\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].land(i, input);\n            break;\n        case 2:\n            // KNOCKDOWN / TECH\n            if (main_1.player[i].phys.techTimer > 0) {\n                if (input[i][0].lsX * main_1.player[i].phys.face > 0.5) {\n                    actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHF.init(i, input);\n                }\n                else if (input[i][0].lsX * main_1.player[i].phys.face < -0.5) {\n                    actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHB.init(i, input);\n                }\n                else {\n                    actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHN.init(i, input);\n                }\n            }\n            else {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].DOWNBOUND.init(i, input);\n            }\n            break;\n        default:\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].LANDING.init(i, input);\n            break;\n    }\n    main_1.player[i].phys.cVel.y = 0;\n    main_1.player[i].phys.kVel.y = 0;\n    main_1.player[i].hit.hitstun = 0;\n}\n;\nfunction hitlagSwitchUpdate(i, input) {\n    if (main_1.player[i].hit.hitlag > 0) {\n        main_1.player[i].hit.hitlag--;\n        if (main_1.player[i].hit.hitlag === 0 && main_1.player[i].hit.knockback > 0) {\n            if (main_1.player[i].phys.grabbedBy === -1 || main_1.player[i].hit.knockback > 50) {\n                const newAngle = (0, hitDetection_1.getLaunchAngle)(main_1.player[i].hit.angle, main_1.player[i].hit.knockback, main_1.player[i].hit.reverse, input[i][0].lsX, input[i][0].lsY, i);\n                main_1.player[i].phys.cVel.x = 0;\n                main_1.player[i].phys.cVel.y = 0;\n                //console.log(newAngle);\n                main_1.player[i].phys.kVel.x = (0, hitDetection_1.getHorizontalVelocity)(main_1.player[i].hit.knockback, newAngle);\n                main_1.player[i].phys.kVel.y = (0, hitDetection_1.getVerticalVelocity)(main_1.player[i].hit.knockback, newAngle, main_1.player[i].phys.grounded, main_1.player[i].hit.angle);\n                //console.log(player[i].phys.kVel);\n                main_1.player[i].phys.kDec.x = (0, hitDetection_1.getHorizontalDecay)(newAngle);\n                main_1.player[i].phys.kDec.y = (0, hitDetection_1.getVerticalDecay)(newAngle);\n                //console.log(player[i].phys.kDec);\n                //player[i].hit.hitstun = getHitstun(player[i].hit.knockback);\n                main_1.player[i].phys.onLedge = -1;\n                main_1.player[i].phys.charging = false;\n                main_1.player[i].phys.chargeFrames = 0;\n                main_1.player[i].phys.shielding = false;\n                /*if (player[i].phys.grounded){\n                 if (newAngle == 0 || newAngle > 270){\n                 player[i].phys.kVel.y = 0;\n                 player[i].phys.kDec.x = player[i].charAttributes.traction;\n                 }\n                 else if (newAngle > 180){\n                 player[i].phys.kVel.y = 0;\n                 player[i].phys.kDec.x = -player[i].charAttributes.traction;\n                 }\n                 }*/\n                if (main_1.player[i].phys.kVel.y === 0) {\n                    if (main_1.player[i].hit.knockback >= 80) {\n                        main_1.player[i].phys.grounded = false;\n                        main_1.player[i].phys.pos.y += 0.0001;\n                    }\n                }\n                if (main_1.player[i].phys.kVel.y > 0) {\n                    main_1.player[i].phys.grounded = false;\n                }\n            }\n            main_1.player[i].hit.knockback = 0;\n        }\n        //SDI / ASDI\n        switch (main_1.player[i].actionState) {\n            case \"DAMAGEN2\":\n            case \"DAMAGEFLYN\":\n            case \"GUARDON\":\n            case \"GUARD\":\n            case \"DOWNDAMAGE\":\n                if (main_1.player[i].hit.hitlag > 0) {\n                    if ((input[i][0].lsX > 0.7 && input[i][1].lsX < 0.7) ||\n                        (input[i][0].lsX < -0.7 && input[i][1].lsX > -0.7) ||\n                        (input[i][0].lsY > 0.7 && input[i][1].lsY < 0.7) ||\n                        (input[i][0].lsY < -0.7 && input[i][1].lsY > -0.7)) {\n                        if (!((input[i][0].lsX * input[i][0].lsX) + (input[i][0].lsY * input[i][0].lsY) < (0.49))) {\n                            main_1.player[i].phys.pos.x += input[i][0].lsX * 6;\n                            main_1.player[i].phys.pos.y += main_1.player[i].phys.grounded ? 0 : input[i][0].lsY * 6;\n                        }\n                    }\n                }\n                else {\n                    main_1.player[i].phys.pos.x += input[i][0].lsX * 3;\n                    main_1.player[i].phys.pos.y += main_1.player[i].phys.grounded ? 0 : input[i][0].lsY * 3;\n                }\n                break;\n            default:\n                break;\n        }\n        if (main_1.player[i].hit.hitlag === 0) {\n            // if hitlag just ended, do normal stuff as well\n            hitlagSwitchUpdate(i, input);\n        }\n    }\n    else {\n        if (main_1.player[i].hit.shieldstun > 0) {\n            //console.log(player[i].hit.shieldstun);\n            main_1.player[i].hit.shieldstun--;\n            if (main_1.player[i].hit.shieldstun < 0) {\n                main_1.player[i].hit.shieldstun = 0;\n            }\n        }\n        //console.log(actionStates[characterSelections[i]][player[i].actionState]);\n        main_1.player[i].phys.canWallJump = actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].wallJumpAble;\n        main_1.player[i].phys.bTurnaroundTimer--;\n        if (main_1.player[i].phys.bTurnaroundTimer < 0) {\n            main_1.player[i].phys.bTurnaroundTimer = 0;\n        }\n        if ((input[i][0].lsX > 0.9 && input[i][1].lsX < 0.9) ||\n            (input[i][0].lsX < -0.9 && input[i][1].lsX > -0.9)) {\n            main_1.player[i].phys.bTurnaroundTimer = 20;\n            main_1.player[i].phys.bTurnaroundDirection = Math.sign(input[i][0].lsX);\n        }\n        main_1.player[i].prevActionState = main_1.player[i].actionState;\n        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].main(i, input);\n        if (main_1.player[i].shocked > 0) {\n            main_1.player[i].shocked--;\n            if (main_1.player[i].shocked % 5 === 0) {\n                sfx_1.sounds.electricfizz.play();\n            }\n            (0, drawVfx_1.drawVfx)({\n                name: \"shocked\",\n                pos: new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + 5),\n                face: main_1.player[i].phys.face\n            });\n        }\n        if (main_1.player[i].burning > 0) {\n            main_1.player[i].burning--;\n            if (main_1.player[i].burning % 6 === 0) {\n                (0, drawVfx_1.drawVfx)({\n                    name: \"burning\",\n                    pos: new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + 5),\n                    face: main_1.player[i].phys.face\n                });\n            }\n        }\n        // TURBO MODE\n        // if just changed action states, remove ability to cancel\n        if (main_1.player[i].prevActionState !== main_1.player[i].actionState) {\n            main_1.player[i].hasHit = false;\n        }\n        if (settings_1.gameSettings.turbo && main_1.gameMode !== 5) {\n            if (main_1.player[i].hasHit) {\n                if (main_1.player[i].actionState !== \"CATCHATTACK\") {\n                    if (main_1.player[i].phys.grounded) {\n                        if ((0, actionStateShortcuts_1.turboGroundedInterrupt)(i, input)) {\n                            main_1.player[i].hasHit = false;\n                        }\n                    }\n                    else {\n                        if ((0, actionStateShortcuts_1.turboAirborneInterrupt)(i, input)) {\n                            main_1.player[i].hasHit = false;\n                        }\n                    }\n                }\n            }\n        }\n        if (Math.abs(main_1.player[i].phys.kVel.x) > 0) {\n            const oSign = Math.sign(main_1.player[i].phys.kVel.x);\n            if (main_1.player[i].phys.grounded) {\n                main_1.player[i].phys.kVel.x -= oSign * main_1.player[i].charAttributes.traction;\n            }\n            else {\n                main_1.player[i].phys.kVel.x -= main_1.player[i].phys.kDec.x;\n            }\n            if (oSign !== Math.sign(main_1.player[i].phys.kVel.x)) {\n                main_1.player[i].phys.kVel.x = 0;\n            }\n        }\n        if (Math.abs(main_1.player[i].phys.kVel.y) > 0) {\n            const oSign = Math.sign(main_1.player[i].phys.kVel.y);\n            if (main_1.player[i].phys.grounded) {\n                main_1.player[i].phys.kVel.y = 0;\n            }\n            main_1.player[i].phys.kVel.y -= main_1.player[i].phys.kDec.y;\n            if (oSign !== Math.sign(main_1.player[i].phys.kVel.y)) {\n                main_1.player[i].phys.kVel.y = 0;\n            }\n        }\n        main_1.player[i].phys.pos.x += main_1.player[i].phys.cVel.x + main_1.player[i].phys.kVel.x;\n        main_1.player[i].phys.pos.y += main_1.player[i].phys.cVel.y + main_1.player[i].phys.kVel.y;\n    }\n}\n;\nfunction hurtBoxStateUpdate(i) {\n    if (main_1.player[i].actionState === \"REBIRTH\" || main_1.player[i].actionState === \"REBIRTHWAIT\") {\n        main_1.player[i].phys.hurtBoxState = 1;\n    }\n    else {\n        main_1.player[i].phys.hurtBoxState = 0;\n    }\n    if (main_1.player[i].phys.invincibleTimer > 0) {\n        main_1.player[i].phys.invincibleTimer--;\n        main_1.player[i].phys.hurtBoxState = 2;\n    }\n    if (main_1.player[i].phys.intangibleTimer > 0) {\n        main_1.player[i].phys.intangibleTimer--;\n        main_1.player[i].phys.hurtBoxState = 1;\n    }\n}\n;\nfunction outOfCameraUpdate(i) {\n    if (main_1.player[i].phys.outOfCameraTimer >= 60) {\n        if (main_1.player[i].percent < 150) {\n            main_1.player[i].percent++;\n        }\n        (0, main_1.percentShake)(40, i);\n        sfx_1.sounds.outofcamera.play();\n        main_1.player[i].phys.outOfCameraTimer = 0;\n    }\n}\n;\nfunction lCancelUpdate(i, input) {\n    // if smash 64 lcancel, put any landingattackair action states into landing\n    if (settings_1.gameSettings.lCancelType === 2 && main_1.gameMode !== 5) {\n        if (main_1.player[i].phys.lCancel) {\n            if (main_1.player[i].actionState.substr(0, 16) === \"LANDINGATTACKAIR\") {\n                main_1.player[i].actionState = \"LANDING\";\n                main_1.player[i].timer = 1;\n            }\n        }\n    }\n    if (main_1.player[i].phys.lCancelTimer > 0) {\n        main_1.player[i].phys.lCancelTimer--;\n        if (main_1.player[i].phys.lCancelTimer === 0) {\n            main_1.player[i].phys.lCancel = false;\n        }\n    }\n    // l CANCEL\n    if (main_1.player[i].phys.lCancelTimer === 0 &&\n        ((input[i][0].lA > 0 && input[i][1].lA === 0) ||\n            (input[i][0].rA > 0 && input[i][1].rA === 0) ||\n            (input[i][0].z && !input[i][1].z))) {\n        // if smash 64 lcancel, increase window to 11 frames\n        if (settings_1.gameSettings.lCancelType === 2 && main_1.gameMode !== 5) {\n            main_1.player[i].phys.lCancelTimer = 11;\n        }\n        else {\n            main_1.player[i].phys.lCancelTimer = 7;\n        }\n        main_1.player[i].phys.lCancel = true;\n    }\n    // if auto lcancel is on, always lcancel\n    if (settings_1.gameSettings.lCancelType === 1 && main_1.gameMode !== 5) {\n        main_1.player[i].phys.lCancel = true;\n    }\n    // V Cancel\n    if (main_1.player[i].phys.vCancelTimer > 0) {\n        main_1.player[i].phys.vCancelTimer--;\n    }\n    if (main_1.player[i].phys.techTimer > 0) {\n        main_1.player[i].phys.techTimer--;\n    }\n    if (main_1.player[i].phys.shoulderLockout > 0) {\n        main_1.player[i].phys.shoulderLockout--;\n    }\n    if ((input[i][0].l && !input[i][1].l) ||\n        (input[i][0].r && !input[i][1].r)) {\n        if (!main_1.player[i].phys.grounded) {\n            if (main_1.player[i].phys.shoulderLockout === 0) {\n                main_1.player[i].phys.vCancelTimer = 3;\n                main_1.player[i].phys.techTimer = 20;\n            }\n        }\n        main_1.player[i].phys.shoulderLockout = 40;\n    }\n}\n;\nconst nullSquashDatum = { location: null, factor: 1 };\nconst ecbSquashData = [nullSquashDatum,\n    nullSquashDatum,\n    nullSquashDatum,\n    nullSquashDatum];\nfunction findAndResolveCollisions(i, input, oldBackward, oldNotTouchingWalls, ecbOffset) {\n    let stillGrounded = true;\n    let backward = oldBackward;\n    const notTouchingWalls = oldNotTouchingWalls;\n    const connected = activeStage_1.activeStage.connected;\n    // ------------------------------------------------------------------------------------------------------\n    // grounded state movement\n    if (main_1.player[i].phys.grounded) {\n        const oldPosition = new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y);\n        const relevantGroundIndex = main_1.player[i].phys.onSurface[1];\n        let relevantGroundType = \"g\";\n        let relevantGround = activeStage_1.activeStage.ground[relevantGroundIndex];\n        if (main_1.player[i].phys.onSurface[0] === 1) {\n            relevantGroundType = \"p\";\n            relevantGround = activeStage_1.activeStage.platform[relevantGroundIndex];\n        }\n        const relevantGroundTypeAndIndex = [relevantGroundType, relevantGroundIndex];\n        [stillGrounded, backward] = dealWithGround(i, relevantGround, relevantGroundTypeAndIndex, connected, input);\n    }\n    // end of grounded state movement\n    // ------------------------------------------------------------------------------------------------------\n    // ------------------------------------------------------------------------------------------------------\n    // main collision detection routine\n    const notIgnoringPlatforms = ((!actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canPassThrough || (input[i][0].lsY > -0.56)) && !main_1.player[i].phys.passing);\n    const isImmune = main_1.player[i].phys.hurtBoxState !== 0;\n    const playerStatusInfo = {\n        ignoringPlatforms: !notIgnoringPlatforms,\n        grounded: main_1.player[i].phys.grounded,\n        immune: isImmune\n    };\n    // type CollisionRoutineResult = { position : Vec2D, touching : null | SimpleTouchingDatum, squashDatum : SquashDatum, ecb : ECB};\n    const collisionData = (0, environmentalCollision_1.runCollisionRoutine)(main_1.player[i].phys.ECB1, main_1.player[i].phys.ECBp, main_1.player[i].phys.pos, ecbSquashData[i], playerStatusInfo, activeStage_1.activeStage);\n    ecbSquashData[i] = collisionData.squashDatum;\n    const newPosition = collisionData.position;\n    const newECB = collisionData.ecb;\n    const touchingDatum = collisionData.touching;\n    if (touchingDatum === null) {\n        updatePosition(i, newPosition);\n    }\n    else if (touchingDatum.kind === \"surface\") {\n        const surfaceLabel = touchingDatum.type;\n        const surfaceIndex = touchingDatum.index;\n        const pt = touchingDatum.pt;\n        switch (surfaceLabel[0].toLowerCase()) {\n            case \"l\": // player touching left wall\n                notTouchingWalls[0] = false;\n                dealWithWallCollision(i, newPosition, pt, \"l\", surfaceIndex, input);\n                break;\n            case \"r\": // player touching right wall\n                notTouchingWalls[1] = false;\n                dealWithWallCollision(i, newPosition, pt, \"r\", surfaceIndex, input);\n                break;\n            case \"g\": // player landed on ground\n                dealWithGroundCollision(i, main_1.player[i].phys.grounded, newPosition, newECB[0], surfaceIndex, input);\n                break;\n            case \"c\": // player touching ceiling\n                dealWithCeilingCollision(i, newPosition, newECB[2], surfaceIndex, input);\n                break;\n            case \"p\": // player landed on platform\n                dealWithPlatformCollision(i, main_1.player[i].phys.grounded, newPosition, newECB[0], surfaceIndex, input);\n                break;\n            default:\n                console.log(\"error in 'findAndResolveCollisions': unrecognised surface type.\");\n                break;\n        }\n    }\n    else if (touchingDatum.kind === \"corner\") {\n        const angularParameter = touchingDatum.angular;\n        const cornerDamageType = touchingDatum.damageType !== undefined ? touchingDatum.damageType : null;\n        dealWithCornerCollision(i, newPosition, newECB, angularParameter, cornerDamageType);\n    }\n    main_1.player[i].phys.ECB1 = newECB;\n    // finally, calculate how much squashing is required by the ground\n    if (main_1.player[i].phys.grounded) {\n        const groundSquashFactor = (0, environmentalCollision_1.groundedECBSquashFactor)(new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ecbOffset[3]) //    top non-squashed ECBp point\n        , new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y) // bottom non-squashed ECBp point, no offset as grounded\n        , (0, toList_1.toList)(activeStage_1.activeStage.ceiling));\n        if (groundSquashFactor !== null && (groundSquashFactor < ecbSquashData[i].factor)) {\n            ecbSquashData[i] = { location: 0, factor: groundSquashFactor };\n        }\n        if (ecbSquashData[i] !== null) {\n            ecbSquashData[i].location = 0;\n        }\n    }\n    return [stillGrounded, backward, notTouchingWalls];\n}\n;\nfunction dealWithLedges(i, input) {\n    const playerPosX = main_1.player[i].phys.pos.x;\n    const playerPosY = main_1.player[i].phys.pos.y;\n    //TODO find out what these magic numbers are\n    const ledgeSnapBoxOffset2 = main_1.player[i].charAttributes.ledgeSnapBoxOffset[2];\n    const ledgeSnapBoxOffset0 = main_1.player[i].charAttributes.ledgeSnapBoxOffset[0];\n    const ledgeSnapBoxOffset1 = main_1.player[i].charAttributes.ledgeSnapBoxOffset[1];\n    main_1.player[i].phys.ledgeSnapBoxF = new Box2D_1.Box2D([playerPosX, playerPosY + ledgeSnapBoxOffset2], [playerPosX + ledgeSnapBoxOffset0, playerPosY + ledgeSnapBoxOffset1]);\n    main_1.player[i].phys.ledgeSnapBoxB = new Box2D_1.Box2D([playerPosX - ledgeSnapBoxOffset0, playerPosY + ledgeSnapBoxOffset2], [playerPosX, playerPosY + ledgeSnapBoxOffset1]);\n    if (main_1.player[i].phys.ledgeRegrabCount) {\n        main_1.player[i].phys.ledgeRegrabTimeout--;\n        if (main_1.player[i].phys.ledgeRegrabTimeout === 0) {\n            main_1.player[i].phys.ledgeRegrabCount = false;\n        }\n    }\n    let lsBF = -1;\n    let lsBB = -1;\n    let foundLedge = 0;\n    if (main_1.player[i].phys.onLedge === -1 && !main_1.player[i].phys.ledgeRegrabCount) {\n        for (let j = 0; j < activeStage_1.activeStage.ledge.length; j++) {\n            let ledgeAvailable = true;\n            for (let k = 0; k < 4; k++) {\n                if (main_1.playerType[k] > -1) {\n                    if (k !== i) {\n                        if (main_1.player[k].phys.onLedge === j) {\n                            ledgeAvailable = false;\n                        }\n                    }\n                }\n            }\n            if (ledgeAvailable && !main_1.player[i].phys.grounded && main_1.player[i].hit.hitstun <= 0) {\n                const x = activeStage_1.activeStage[activeStage_1.activeStage.ledge[j][0]][activeStage_1.activeStage.ledge[j][1]][activeStage_1.activeStage.ledge[j][2]].x;\n                const y = activeStage_1.activeStage[activeStage_1.activeStage.ledge[j][0]][activeStage_1.activeStage.ledge[j][1]][activeStage_1.activeStage.ledge[j][2]].y;\n                if (x > main_1.player[i].phys.ledgeSnapBoxF.min.x &&\n                    x < main_1.player[i].phys.ledgeSnapBoxF.max.x &&\n                    y < main_1.player[i].phys.ledgeSnapBoxF.min.y &&\n                    y > main_1.player[i].phys.ledgeSnapBoxF.max.y) {\n                    if (activeStage_1.activeStage.ledge[j][2] === 0) {\n                        if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[0]) {\n                            lsBF = j;\n                        }\n                    }\n                    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        lsBF = j;\n                    }\n                }\n                if (x > main_1.player[i].phys.ledgeSnapBoxB.min.x &&\n                    x < main_1.player[i].phys.ledgeSnapBoxB.max.x &&\n                    y < main_1.player[i].phys.ledgeSnapBoxB.min.y &&\n                    y > main_1.player[i].phys.ledgeSnapBoxF.max.y) {\n                    if (activeStage_1.activeStage.ledge[j][2] === 1) {\n                        if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[0]) {\n                            lsBB = j;\n                        }\n                    }\n                    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        lsBB = j;\n                    }\n                }\n            }\n            if (main_1.player[i].phys.cVel.y < 0 && input[i][0].lsY > -0.5) {\n                if (lsBF > -1) {\n                    foundLedge = activeStage_1.activeStage.ledge[lsBF];\n                    if (foundLedge[2] * -2 + 1 === main_1.player[i].phys.face || actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        main_1.player[i].phys.onLedge = lsBF;\n                        main_1.player[i].phys.ledgeRegrabTimeout = 30;\n                        main_1.player[i].phys.face = foundLedge[2] * -2 + 1;\n                        main_1.player[i].phys.pos = new Vec2D_1.Vec2D(activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].x + main_1.edgeOffset[0][0], activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].y + main_1.edgeOffset[0][1]);\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].CLIFFCATCH.init(i, input);\n                    }\n                }\n                else if (lsBB > -1) {\n                    foundLedge = activeStage_1.activeStage.ledge[lsBB];\n                    if (foundLedge[2] * -2 + 1 === main_1.player[i].phys.face || actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        main_1.player[i].phys.onLedge = lsBB;\n                        main_1.player[i].phys.ledgeRegrabTimeout = 30;\n                        main_1.player[i].phys.face = foundLedge[2] * -2 + 1;\n                        main_1.player[i].phys.pos = new Vec2D_1.Vec2D(activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].x + main_1.edgeOffset[1][0], activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].y + main_1.edgeOffset[1][1]);\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].CLIFFCATCH.init(i, input);\n                    }\n                }\n            }\n        }\n    }\n}\n;\nfunction dealWithDeath(i, input) {\n    if (!actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].dead && main_1.player[i].actionState !== \"SLEEP\") {\n        let state = 0;\n        if (main_1.player[i].phys.pos.x < activeStage_1.activeStage.blastzone.min.x) {\n            state = \"DEADLEFT\";\n        }\n        else if (main_1.player[i].phys.pos.x > activeStage_1.activeStage.blastzone.max.x) {\n            state = \"DEADRIGHT\";\n        }\n        else if (main_1.player[i].phys.pos.y < activeStage_1.activeStage.blastzone.min.y) {\n            state = \"DEADDOWN\";\n        }\n        else if (main_1.player[i].phys.pos.y > activeStage_1.activeStage.blastzone.max.y && main_1.player[i].phys.kVel.y >= 2.4) {\n            state = \"DEADUP\";\n        }\n        if (state !== 0) {\n            main_1.player[i].phys.outOfCameraTimer = 0;\n            (0, actionStateShortcuts_1.turnOffHitboxes)(i);\n            main_1.player[i].stocks--;\n            main_1.player[i].colourOverlayBoolean = false;\n            render_1.lostStockQueue.push([i, main_1.player[i].stocks, 0]);\n            if (main_1.player[i].stocks === 0 && main_1.versusMode) {\n                main_1.player[i].stocks = 1;\n            }\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][state].init(i, input);\n        }\n    }\n}\n;\nfunction updateHitboxes(i) {\n    main_1.player[i].phys.isInterpolated = false;\n    for (let j = 0; j < 4; j++) {\n        if (main_1.player[i].hitboxes.active[j] && main_1.player[i].phys.prevFrameHitboxes.active[j]) {\n            if (main_1.player[i].phys.prevFrameHitboxes.id[j].offset[main_1.player[i].phys.prevFrameHitboxes.frame] === undefined) {\n                continue;\n            }\n            if (main_1.player[i].hitboxes.id[j].offset[main_1.player[i].hitboxes.frame] === undefined) {\n                continue;\n            }\n            const h1 = new Vec2D_1.Vec2D(main_1.player[i].phys.posPrev.x + (main_1.player[i].phys.prevFrameHitboxes.id[j].offset[main_1.player[i].phys.prevFrameHitboxes.frame].x * main_1.player[i].phys.facePrev), main_1.player[i].phys.posPrev.y + main_1.player[i].phys.prevFrameHitboxes.id[j].offset[main_1.player[i].phys.prevFrameHitboxes.frame].y);\n            const h2 = new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x + (main_1.player[i].hitboxes.id[j].offset[main_1.player[i].hitboxes.frame].x * main_1.player[i].phys.face), main_1.player[i].phys.pos.y + main_1.player[i].hitboxes.id[j].offset[main_1.player[i].hitboxes.frame].y);\n            const a = h2.x - h1.x;\n            const b = h2.y - h1.y;\n            let x = 0;\n            if (!(a === 0 || b === 0)) {\n                x = Math.atan(Math.abs(a) / Math.abs(b));\n            }\n            {\n                const opp = Math.sin(x) * main_1.player[i].hitboxes.id[j].size;\n                const adj = Math.cos(x) * main_1.player[i].hitboxes.id[j].size;\n                const sigma = [h1.x, h1.y];\n                let alpha1;\n                let alpha2;\n                let beta1;\n                let beta2;\n                if ((a > 0 && b > 0) || (a <= 0 && b <= 0)) {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                else {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                main_1.player[i].phys.interPolatedHitbox[j] = [alpha1, alpha2, beta2, beta1];\n            }\n            {\n                const opp = Math.sin(x) * main_1.player[i].hitboxes.id[j].size - settings_1.gameSettings.phantomThreshold;\n                const adj = Math.cos(x) * main_1.player[i].hitboxes.id[j].size - settings_1.gameSettings.phantomThreshold;\n                const sigma = [h1.x, h1.y];\n                let alpha1;\n                let alpha2;\n                let beta1;\n                let beta2;\n                if ((a > 0 && b > 0) || (a <= 0 && b <= 0)) {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                else {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                main_1.player[i].phys.interPolatedHitboxPhantom[j] = [alpha1, alpha2, beta2, beta1];\n                main_1.player[i].phys.isInterpolated = true;\n            }\n        }\n    }\n}\n;\nfunction physics(i, input) {\n    main_1.player[i].phys.passing = false;\n    main_1.player[i].phys.posPrev = new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y);\n    main_1.player[i].phys.facePrev = main_1.player[i].phys.face;\n    (0, deepCopyObject_1.deepObjectMerge)(true, main_1.player[i].phys.prevFrameHitboxes, main_1.player[i].hitboxes);\n    hitlagSwitchUpdate(i, input);\n    hurtBoxStateUpdate(i);\n    outOfCameraUpdate(i);\n    lCancelUpdate(i, input);\n    if (!main_1.player[i].phys.grounded) {\n        main_1.player[i].phys.airborneTimer++;\n    }\n    //console.log(player[i].timer);\n    let frame = Math.floor(main_1.player[i].timer);\n    if (frame === 0) {\n        frame = 1;\n    }\n    if (frame > characters_1.framesData[main_1.characterSelections[i]][main_1.player[i].actionState]) {\n        frame = characters_1.framesData[main_1.characterSelections[i]][main_1.player[i].actionState];\n    }\n    //console.log(actionStates[characterSelections[i]][player[i].actionState].name+\" \"+(frame-1));\n    /* global ecb */\n    let ecb;\n    const ecbOffset = actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].dead ? [0, 0, 0, 0] : [ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][0] * main_1.player[i].charAttributes.ecbScale, ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][1] * main_1.player[i].charAttributes.ecbScale, ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][2] * main_1.player[i].charAttributes.ecbScale, ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][3] * main_1.player[i].charAttributes.ecbScale];\n    const playerPosX = main_1.player[i].phys.pos.x;\n    const playerPosY = main_1.player[i].phys.pos.y;\n    main_1.player[i].phys.ECBp = [\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ((main_1.player[i].phys.grounded || main_1.player[i].phys.airborneTimer < 10) ? 0 : ecbOffset[0])),\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x + Math.max(1, ecbOffset[1]), main_1.player[i].phys.pos.y + ecbOffset[2]),\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ecbOffset[3]),\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x - ecbOffset[1], main_1.player[i].phys.pos.y + ecbOffset[2])\n    ];\n    if (ecbSquashData[i] !== null && ecbSquashData[i].factor < 1) {\n        if (ecbSquashData[i].factor * 2 * ecbOffset[1] < environmentalCollision_1.smallestECBWidth) {\n            ecbSquashData[i].factor = (environmentalCollision_1.smallestECBWidth + 2 * environmentalCollision_1.additionalOffset) / (2 * ecbOffset[1]);\n        }\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.squashECBAt)(main_1.player[i].phys.ECBp, { factor: ecbSquashData[i].factor, location: 0 });\n        if (!main_1.player[i].phys.grounded) {\n            main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, new Vec2D_1.Vec2D(0, (ecbSquashData[i].factor - 1) * ecbOffset[0]));\n        }\n    }\n    if (!actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].ignoreCollision) {\n        let notTouchingWalls = [true, true];\n        let stillGrounded = true;\n        let backward = false;\n        [stillGrounded, backward, notTouchingWalls] = findAndResolveCollisions(i, input, backward, notTouchingWalls, ecbOffset);\n        if (main_1.player[i].phys.grabbedBy === -1) {\n            if (notTouchingWalls[0] && notTouchingWalls[1] && main_1.player[i].phys.canWallJump) {\n                main_1.player[i].phys.wallJumpTimer = 254;\n            }\n            if (!notTouchingWalls[0] || !notTouchingWalls[1]) {\n                if (main_1.player[i].phys.grounded) {\n                    const s = main_1.player[i].phys.onSurface[1];\n                    const surface = main_1.player[i].phys.onSurface[0] ? activeStage_1.activeStage.platform[s] : activeStage_1.activeStage.ground[s];\n                    if (main_1.player[i].phys.pos.x < surface[0].x - 0.1 || main_1.player[i].phys.pos.x > surface[1].x + 0.1) {\n                        stillGrounded = false;\n                    }\n                }\n            }\n            if (!stillGrounded) {\n                main_1.player[i].phys.grounded = false;\n                if (typeof actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].airborneState !== 'undefined') {\n                    main_1.player[i].actionState = actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].airborneState;\n                }\n                else {\n                    if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].missfoot && backward) {\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].MISSFOOT.init(i, input);\n                    }\n                    else {\n                        if (main_1.player[i].phys.grabbing !== -1) {\n                            actionStateShortcuts_1.actionStates[main_1.characterSelections[main_1.player[i].phys.grabbing]].FALL.init(main_1.player[i].phys.grabbing, input, true);\n                            main_1.player[main_1.player[i].phys.grabbing].phys.grabbedBy = -1;\n                            main_1.player[i].phys.grabbing = -1;\n                        }\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].FALL.init(i, input);\n                    }\n                    if (Math.abs(main_1.player[i].phys.cVel.x) > main_1.player[i].charAttributes.aerialHmaxV) {\n                        main_1.player[i].phys.cVel.x = Math.sign(main_1.player[i].phys.cVel.x) * main_1.player[i].charAttributes.aerialHmaxV;\n                    }\n                }\n                main_1.player[i].phys.shielding = false;\n            }\n            if (main_1.player[i].phys.grounded) {\n                for (let j = 0; j < 4; j++) {\n                    if (main_1.playerType[j] > -1) {\n                        if (i !== j) {\n                            if (main_1.player[j].phys.grounded &&\n                                main_1.player[j].phys.onSurface[0] === main_1.player[i].phys.onSurface[0] &&\n                                main_1.player[j].phys.onSurface[1] === main_1.player[i].phys.onSurface[1]) {\n                                if (main_1.player[i].phys.grabbing !== j && main_1.player[i].phys.grabbedBy !== j) {\n                                    // TODO: this pushing code needs to account for players on slanted surfaces\n                                    const diff = Math.abs(main_1.player[i].phys.pos.x - main_1.player[j].phys.pos.x);\n                                    if (diff < 6.5 && diff > 0) {\n                                        main_1.player[j].phys.pos.x += Math.sign(main_1.player[i].phys.pos.x - main_1.player[j].phys.pos.x) * -0.3;\n                                    }\n                                    else if (diff === 0 && Math.abs(main_1.player[i].phys.cVel.x) > Math.abs(main_1.player[j].phys.cVel.x)) {\n                                        main_1.player[j].phys.pos.x += Math.sign(main_1.player[i].phys.cVel.x) * -0.3;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else { // player ignoring collisions\n        main_1.player[i].phys.ECB1 = [\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ((main_1.player[i].phys.grounded || main_1.player[i].phys.airborneTimer < 10) ? 0 : ecbOffset[0])),\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x + ecbOffset[1], main_1.player[i].phys.pos.y + ecbOffset[2]),\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ecbOffset[3]),\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x - ecbOffset[1], main_1.player[i].phys.pos.y + ecbOffset[2])\n        ];\n    }\n    if (main_1.player[i].phys.shielding === false) {\n        main_1.player[i].phys.shieldHP += 0.07;\n        if (main_1.player[i].phys.shieldHP > 60) {\n            main_1.player[i].phys.shieldHP = 60;\n        }\n    }\n    dealWithLedges(i, input);\n    dealWithDeath(i, input);\n    main_1.player[i].phys.hurtbox = new Box2D_1.Box2D([playerPosX - main_1.player[i].charAttributes.hurtboxOffset[0], playerPosY + main_1.player[i].charAttributes.hurtboxOffset[1]], [playerPosX + main_1.player[i].charAttributes.hurtboxOffset[0], playerPosY]);\n    if (main_1.gameMode === 3 && main_1.player[i].phys.posPrev.y > -80 && playerPosY <= -80) {\n        sfx_1.sounds.lowdown.play();\n    }\n    updateHitboxes(i);\n    main_1.player[i].phys.posDelta = new Vec2D_1.Vec2D(Math.abs(playerPosX - main_1.player[i].phys.posPrev.x), Math.abs(playerPosY - main_1.player[i].phys.posPrev.y));\n    if (main_1.showDebug) {\n        const actState = document.getElementById('actState' + i);\n        const stateNum = document.getElementById('stateNum' + i);\n        const face = document.getElementById('face' + i);\n        const velocityX = document.getElementById(\"velocityX\" + i);\n        const velocityY = document.getElementById(\"velocityY\" + i);\n        const kvelocityX = document.getElementById(\"kvelocityX\" + i);\n        const kvelocityY = document.getElementById(\"kvelocityY\" + i);\n        const pvelocityX = document.getElementById(\"pvelocityX\" + i);\n        const pvelocityY = document.getElementById(\"pvelocityY\" + i);\n        actState.innerHTML = main_1.player[i].currentAction + \" \" + main_1.player[i].currentSubaction + \" : \" + main_1.player[i].actionState;\n        stateNum.innerHTML = frame.toString();\n        face.innerHTML = main_1.player[i].phys.face;\n        velocityX.innerHTML = main_1.player[i].phys.cVel.x.toFixed(5);\n        velocityY.innerHTML = main_1.player[i].phys.cVel.y.toFixed(5);\n        kvelocityX.innerHTML = main_1.player[i].phys.kVel.x.toFixed(5);\n        kvelocityY.innerHTML = main_1.player[i].phys.kVel.y.toFixed(5);\n        pvelocityX.innerHTML = playerPosX.toFixed(5);\n        pvelocityY.innerHTML = playerPosY.toFixed(5);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGh5c2ljcy9waHlzaWNzLnRzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsd0NBQWM7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsb0RBQW9CO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyxzQ0FBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxzQ0FBYTtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQyxxRUFBd0I7QUFDL0QsdUJBQXVCLG1CQUFPLENBQUMscURBQWdCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDRDQUFnQjtBQUN6QyxpQ0FBaUMsbUJBQU8sQ0FBQyx5RUFBMEI7QUFDbkUseUJBQXlCLG1CQUFPLENBQUMsc0VBQTZCO0FBQzlELGtCQUFrQixtQkFBTyxDQUFDLHNEQUFxQjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4Q0FBaUI7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsMERBQXVCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLG9EQUFvQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvREFBb0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQXFCO0FBQzlDLHVCQUF1QixtQkFBTyxDQUFDLHNFQUE2QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyxrRUFBMkI7QUFDMUQsaUJBQWlCLG1CQUFPLENBQUMsNENBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUE0QztBQUNwRTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyw4Q0FBOEM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWxlZWxpZ2h0Ly4vc3JjL3BoeXNpY3MvcGh5c2ljcy50cz8yZmUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy9AZmxvd1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sYW5kID0gbGFuZDtcbmV4cG9ydHMucGh5c2ljcyA9IHBoeXNpY3M7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi4vbWFpbi9tYWluXCIpO1xuY29uc3QgY2hhcmFjdGVyc18xID0gcmVxdWlyZShcIi4uL21haW4vY2hhcmFjdGVyc1wiKTtcbmNvbnN0IHNmeF8xID0gcmVxdWlyZShcIi4uL21haW4vc2Z4XCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9zZXR0aW5nc1wiKTtcbmNvbnN0IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEgPSByZXF1aXJlKFwiLi9hY3Rpb25TdGF0ZVNob3J0Y3V0c1wiKTtcbmNvbnN0IGhpdERldGVjdGlvbl8xID0gcmVxdWlyZShcIi4vaGl0RGV0ZWN0aW9uXCIpO1xuY29uc3QgcmVuZGVyXzEgPSByZXF1aXJlKFwiLi4vbWFpbi9yZW5kZXJcIik7XG5jb25zdCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudGFsQ29sbGlzaW9uXCIpO1xuY29uc3QgZGVlcENvcHlPYmplY3RfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3V0aWwvZGVlcENvcHlPYmplY3RcIik7XG5jb25zdCBkcmF3VmZ4XzEgPSByZXF1aXJlKFwiLi4vbWFpbi92ZngvZHJhd1ZmeFwiKTtcbmNvbnN0IHN0YWdlXzEgPSByZXF1aXJlKFwiLi4vc3RhZ2VzL3N0YWdlXCIpO1xuY29uc3QgYWN0aXZlU3RhZ2VfMSA9IHJlcXVpcmUoXCIuLi9zdGFnZXMvYWN0aXZlU3RhZ2VcIik7XG5jb25zdCBCb3gyRF8xID0gcmVxdWlyZShcIi4uL21haW4vdXRpbC9Cb3gyRFwiKTtcbmNvbnN0IFZlYzJEXzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL1ZlYzJEXCIpO1xuY29uc3QgdG9MaXN0XzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL3RvTGlzdFwiKTtcbmNvbnN0IGV4dHJlbWVQb2ludF8xID0gcmVxdWlyZShcIi4uL3N0YWdlcy91dGlsL2V4dHJlbWVQb2ludFwiKTtcbmNvbnN0IGVjYlRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4uL21haW4vdXRpbC9lY2JUcmFuc2Zvcm1cIik7XG5jb25zdCBsaW5BbGdfMSA9IHJlcXVpcmUoXCIuLi9tYWluL2xpbkFsZ1wiKTtcbmZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGksIG5ld1Bvc2l0aW9uKSB7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcyA9IG5ld1Bvc2l0aW9uO1xufVxuO1xuZnVuY3Rpb24gZGVhbFdpdGhEYW1hZ2luZ1N0YWdlQ29sbGlzaW9uKGksIG5vcm1hbCwgY29ybmVyLCBhbmd1bGFyLCBkYW1hZ2VUeXBlKSB7XG4gICAgY29uc3QgY29sbGlzaW9uRGF0YSA9IHsgbm9ybWFsOiBub3JtYWwsIGFuZ3VsYXI6IGFuZ3VsYXIsIGNvcm5lcjogY29ybmVyIH07XG4gICAgbGV0IGRhbWFnZVR5cGVJbmRleCA9IC0xO1xuICAgIHN3aXRjaCAoZGFtYWdlVHlwZSkge1xuICAgICAgICBjYXNlIFwiZmlyZVwiOlxuICAgICAgICAgICAgZGFtYWdlVHlwZUluZGV4ID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZWxlY3RyaWNcIjpcbiAgICAgICAgICAgIGRhbWFnZVR5cGVJbmRleCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNsYXNoXCI6XG4gICAgICAgICAgICBkYW1hZ2VUeXBlSW5kZXggPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXJrbmVzc1wiOlxuICAgICAgICAgICAgZGFtYWdlVHlwZUluZGV4ID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkYW1hZ2VUeXBlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGhpdERldGVjdGlvbl8xLmhpdFF1ZXVlLnB1c2goW2ksIGNvbGxpc2lvbkRhdGEsIGRhbWFnZVR5cGVJbmRleCwgZmFsc2UsIGZhbHNlLCB0cnVlXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVhbFdpdGhXYWxsQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBwdCwgd2FsbFR5cGUsIHdhbGxJbmRleCwgaW5wdXQpIHtcbiAgICB1cGRhdGVQb3NpdGlvbihpLCBuZXdQb3NpdGlvbik7XG4gICAgbGV0IHdhbGxMYWJlbCA9IFwiTFwiO1xuICAgIGxldCBzaWduID0gLTE7XG4gICAgbGV0IGlzUmlnaHQgPSAwO1xuICAgIGlmICh3YWxsVHlwZVswXS50b0xvd2VyQ2FzZSgpID09PSBcInJcIikge1xuICAgICAgICB3YWxsTGFiZWwgPSBcIlJcIjtcbiAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgIGlzUmlnaHQgPSAxO1xuICAgIH1cbiAgICBjb25zdCB3YWxsID0gKDAsIHN0YWdlXzEuZ2V0U3VyZmFjZUZyb21TdGFnZSkoW3dhbGxUeXBlLCB3YWxsSW5kZXhdLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlKTtcbiAgICBjb25zdCB3YWxsQm90dG9tID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkod2FsbCwgXCJiXCIpO1xuICAgIGNvbnN0IHdhbGxUb3AgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KSh3YWxsLCBcInRcIik7XG4gICAgY29uc3Qgd2FsbE5vcm1hbCA9ICgwLCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEub3V0d2FyZHNXYWxsTm9ybWFsKSh3YWxsQm90dG9tLCB3YWxsVG9wLCB3YWxsVHlwZSk7XG4gICAgY29uc3QgZGFtYWdlVHlwZSA9IHdhbGxbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB3YWxsWzJdLmRhbWFnZVR5cGU7XG4gICAgY29uc3QgaW5EYW1hZ2VTdGF0ZSA9IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkxZTlwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiV0FMTERBTUFHRVwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkFMTFwiO1xuICAgIGlmIChpbkRhbWFnZVN0YXRlICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy50ZWNoVGltZXIgPiAwKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlID0gc2lnbjtcbiAgICAgICAgaWYgKGlucHV0W2ldWzBdLnggfHwgaW5wdXRbaV1bMF0ueSB8fCBpbnB1dFtpXVswXS5sc1kgPiAwLjcpIHtcbiAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5XQUxMVEVDSEpVTVAuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uV0FMTFRFQ0guaW5pdChpLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5EYW1hZ2VTdGF0ZSAmJiBNYXRoLnNpZ24obWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwpICE9PSBzaWduICYmIG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZyA9PT0gMCAmJiBNYXRoLnBvdyhtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54LCAyKSArIE1hdGgucG93KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnksIDIpID49IDIuMjUpIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgPSBzaWduO1xuICAgICAgICAoMCwgZHJhd1ZmeF8xLmRyYXdWZngpKHtcbiAgICAgICAgICAgIG5hbWU6IFwid2FsbEJvdW5jZVwiLFxuICAgICAgICAgICAgcG9zOiBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwWzFdLnkpLFxuICAgICAgICAgICAgZmFjZTogc2lnbixcbiAgICAgICAgICAgIGY6IHdhbGxOb3JtYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5XQUxMREFNQUdFLmluaXQoaSwgaW5wdXQsIHdhbGxOb3JtYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5oaXRsYWcgPT09IDApIHtcbiAgICAgICAgaWYgKGRhbWFnZVR5cGUgIT09IHVuZGVmaW5lZCAmJiBkYW1hZ2VUeXBlICE9PSBudWxsXG4gICAgICAgICAgICAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID09PSAwKSB7XG4gICAgICAgICAgICAvLyBhcHBseSBkYW1hZ2VcbiAgICAgICAgICAgIGRlYWxXaXRoRGFtYWdpbmdTdGFnZUNvbGxpc2lvbihpLCB3YWxsTm9ybWFsLCBmYWxzZSwgcHQsIGRhbWFnZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5zcGVjaWFsV2FsbENvbGxpZGUpIHtcbiAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5vbldhbGxDb2xsaWRlKGksIGlucHV0LCB3YWxsTGFiZWwsIHdhbGxJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmNhbldhbGxKdW1wKSB7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLndhbGxKdW1wVGltZXIgPT09IDI1NCkge1xuICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zRGVsdGEueCA+PSAwLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLndhbGxKdW1wVGltZXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLndhbGxKdW1wVGltZXIgPj0gMCAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMud2FsbEp1bXBUaW1lciA8IDEyMCkge1xuICAgICAgICAgICAgaWYgKHNpZ24gKiBpbnB1dFtpXVswXS5sc1ggPj0gMC43ICYmXG4gICAgICAgICAgICAgICAgc2lnbiAqIGlucHV0W2ldWzNdLmxzWCA8PSAwICYmXG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy53YWxsanVtcCkge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy53YWxsSnVtcFRpbWVyID0gMjU0O1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlID0gc2lnbjtcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uV0FMTEpVTVAuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMud2FsbEp1bXBUaW1lcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gZGVhbFdpdGhQbGF0Zm9ybUNvbGxpc2lvbihpLCBhbHJlYWR5R3JvdW5kZWQsIG5ld1Bvc2l0aW9uLCBlY2JwQm90dG9tLCBwbGF0Zm9ybUluZGV4LCBpbnB1dCkge1xuICAgIGNvbnN0IHBsYXRmb3JtID0gKDAsIHN0YWdlXzEuZ2V0U3VyZmFjZUZyb21TdGFnZSkoW1wicFwiLCBwbGF0Zm9ybUluZGV4XSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZSk7XG4gICAgY29uc3QgZGFtYWdlVHlwZSA9IHBsYXRmb3JtWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogcGxhdGZvcm1bMl0uZGFtYWdlVHlwZTtcbiAgICBjb25zdCBwbGF0TGVmdCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKHBsYXRmb3JtLCBcImxcIik7XG4gICAgY29uc3QgcGxhdFJpZ2h0ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkocGxhdGZvcm0sIFwiclwiKTtcbiAgICBjb25zdCBwbGF0Tm9ybWFsID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5vdXR3YXJkc1dhbGxOb3JtYWwpKHBsYXRMZWZ0LCBwbGF0UmlnaHQsIFwiZ1wiKTtcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID4gMCB8fCBhbHJlYWR5R3JvdW5kZWQgfHwgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiZWRCeSAhPT0gLTEpIHtcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oaSwgbmV3UG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFuZChpLCBlY2JwQm90dG9tLCAxLCBwbGF0Zm9ybUluZGV4LCBwbGF0Tm9ybWFsLCBpbnB1dCk7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gZGVhbFdpdGhHcm91bmRDb2xsaXNpb24oaSwgYWxyZWFkeUdyb3VuZGVkLCBuZXdQb3NpdGlvbiwgZWNicEJvdHRvbSwgZ3JvdW5kSW5kZXgsIGlucHV0KSB7XG4gICAgY29uc3QgZ3JvdW5kID0gKDAsIHN0YWdlXzEuZ2V0U3VyZmFjZUZyb21TdGFnZSkoW1wiZ1wiLCBncm91bmRJbmRleF0sIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UpO1xuICAgIGNvbnN0IGRhbWFnZVR5cGUgPSBncm91bmRbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBncm91bmRbMl0uZGFtYWdlVHlwZTtcbiAgICBjb25zdCBpZ25vcmVEYW1hZ2UgPSBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIkRBTUFHRUZMWU5cIiB8fCBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIkRBTUFHRUZBTExcIiB8fCBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIldBTExEQU1BR0VcIjtcbiAgICBjb25zdCBncm91bmRMZWZ0ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkoZ3JvdW5kLCBcImxcIik7XG4gICAgY29uc3QgZ3JvdW5kUmlnaHQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShncm91bmQsIFwiclwiKTtcbiAgICBjb25zdCBncm91bmROb3JtYWwgPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLm91dHdhcmRzV2FsbE5vcm1hbCkoZ3JvdW5kTGVmdCwgZ3JvdW5kUmlnaHQsIFwiZ1wiKTtcbiAgICBpZiAoIWlnbm9yZURhbWFnZSAmJiBkYW1hZ2VUeXBlICE9PSB1bmRlZmluZWQgJiYgZGFtYWdlVHlwZSAhPT0gbnVsbFxuICAgICAgICAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID09PSAwKSB7XG4gICAgICAgIC8vIGFwcGx5IGRhbWFnZVxuICAgICAgICBkZWFsV2l0aERhbWFnaW5nU3RhZ2VDb2xsaXNpb24oaSwgZ3JvdW5kTm9ybWFsLCBmYWxzZSwgMCwgZGFtYWdlVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID4gMCB8fCBhbHJlYWR5R3JvdW5kZWQgfHwgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiZWRCeSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBvc2l0aW9uKGksIG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhbmQoaSwgZWNicEJvdHRvbSwgMCwgZ3JvdW5kSW5kZXgsIGdyb3VuZE5vcm1hbCwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gZmFsbE9mZkdyb3VuZChpLCBzaWRlLCBncm91bmRFZGdlUG9zaXRpb24sIGRpc2FibGVGYWxsLCBpbnB1dCkge1xuICAgIGxldCBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gW3RydWUsIGZhbHNlXTtcbiAgICBsZXQgc2lnbiA9IDE7XG4gICAgaWYgKHNpZGUgPT09IFwiclwiKSB7XG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICB9XG4gICAgaWYgKGRpc2FibGVGYWxsKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA9IE1hdGgubWF4KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSwgZ3JvdW5kRWRnZVBvc2l0aW9uLnkpICsgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA9IGdyb3VuZEVkZ2VQb3NpdGlvbi54ICsgKHNpZGUgPT09IFwibFwiID8gZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQgOiAtZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQpO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCA9ICgwLCBlY2JUcmFuc2Zvcm1fMS5tb3ZlRUNCKShtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCwgKDAsIGxpbkFsZ18xLnN1YnRyYWN0KShtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLCBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcFswXSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uY2FuRWRnZUNhbmNlbCkge1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgPT09IHNpZ24pIHtcbiAgICAgICAgICAgIHN0aWxsR3JvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA9IE1hdGgubWF4KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSwgZ3JvdW5kRWRnZVBvc2l0aW9uLnkpICsgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgICAgICAgICBiYWNrd2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXRbaV1bMF0ubHNYKSA+IDAuNlxuICAgICAgICAgICAgfHwgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnggPT09IDAgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCA9PT0gMClcbiAgICAgICAgICAgIHx8IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5kaXNhYmxlVGVldGVyXG4gICAgICAgICAgICB8fCBtYWluXzEucGxheWVyW2ldLnBoeXMuc2hpZWxkaW5nKSB7XG4gICAgICAgICAgICBzdGlsbEdyb3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgPSBNYXRoLm1heChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnksIGdyb3VuZEVkZ2VQb3NpdGlvbi55KSArIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5hZGRpdGlvbmFsT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCA9IDA7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggPSBncm91bmRFZGdlUG9zaXRpb24ueCArIHNpZ24gKiBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldDtcbiAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5PVFRPVFRPLmluaXQoaSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnggPT09IDBcbiAgICAgICAgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCA9PT0gMFxuICAgICAgICAmJiAhYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmluR3JhYikge1xuICAgICAgICBzdGlsbEdyb3VuZGVkID0gZmFsc2U7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA9IE1hdGgubWF4KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSwgZ3JvdW5kRWRnZVBvc2l0aW9uLnkpICsgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54ID0gMDtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ID0gZ3JvdW5kRWRnZVBvc2l0aW9uLnggKyBzaWduICogZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdO1xufVxuO1xuLy8gZ3JvdW5kIHR5cGUgYW5kIGluZGV4IGlzIGEgcGFpciwgZWl0aGVyIFtcImdcIiwgaW5kZXhdIG9yIFtcInBcIiwgaW5kZXhdXG5mdW5jdGlvbiBkZWFsV2l0aEdyb3VuZChpLCBncm91bmQsIGdyb3VuZFR5cGVBbmRJbmRleCwgY29ubmVjdGVkLCBpbnB1dCkge1xuICAgIGNvbnN0IGRhbWFnZVR5cGUgPSBncm91bmRbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBncm91bmRbMl0uZGFtYWdlVHlwZTtcbiAgICBjb25zdCBpZ25vcmVEYW1hZ2UgPSBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIkRBTUFHRUZMWU5cIiB8fCBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIkRBTUFHRUZBTExcIiB8fCBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIldBTExEQU1BR0VcIjtcbiAgICBjb25zdCBsZWZ0bW9zdEdyb3VuZFBvaW50ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkoZ3JvdW5kLCBcImxcIik7XG4gICAgY29uc3QgcmlnaHRtb3N0R3JvdW5kUG9pbnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShncm91bmQsIFwiclwiKTtcbiAgICBjb25zdCBncm91bmROb3JtYWwgPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLm91dHdhcmRzV2FsbE5vcm1hbCkobGVmdG1vc3RHcm91bmRQb2ludCwgcmlnaHRtb3N0R3JvdW5kUG9pbnQsIFwiZ1wiKTtcbiAgICBsZXQgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IFt0cnVlLCBmYWxzZV07XG4gICAgbGV0IGdyb3VuZE9yUGxhdGZvcm0gPSAwO1xuICAgIGlmIChncm91bmRUeXBlQW5kSW5kZXhbMF0gPT09IFwicFwiKSB7XG4gICAgICAgIGdyb3VuZE9yUGxhdGZvcm0gPSAxO1xuICAgIH1cbiAgICBsZXQgZGlzYWJsZUZhbGwgPSBmYWxzZTtcbiAgICBsZXQgbWF5YmVMZWZ0R3JvdW5kVHlwZUFuZEluZGV4ID0gbnVsbDtcbiAgICBsZXQgbWF5YmVSaWdodEdyb3VuZFR5cGVBbmRJbmRleCA9IG51bGw7XG4gICAgLy8gZmlyc3QgY2hlY2sgaWYgdGhlIHBsYXllciBpcyBhbGxvd2VkIHRvIG1vdmUgYWxvbmcgdGhlIGdyb3VuZCwgYnkgY2hlY2tpbmcgdGhlcmUgYXJlIG5vIGxvdyBjZWlsaW5nc1xuICAgIGNvbnN0IGVjYjBIZWlnaHQgPSBNYXRoLm1heChlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldCwgbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQjFbMl0ueSAtIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0IxWzBdLnkgLSBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldCk7XG4gICAgY29uc3QgbWF5YmVOZXh0UG9zWCA9ICgwLCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEubW92ZUFsb25nR3JvdW5kKShtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCMVswXSwgbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnBbMF0sIGVjYjBIZWlnaHQsIGdyb3VuZCwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5jZWlsaW5nKTtcbiAgICBpZiAobWF5YmVOZXh0UG9zWCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjZWlsaW5nIGhhcyBvYnN0cnVjdGVkIGdyb3VuZGVkIG1vdmVtZW50XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA9IG1heWJlTmV4dFBvc1g7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwID0gKDAsIGVjYlRyYW5zZm9ybV8xLm1vdmVFQ0IpKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwLCBuZXcgVmVjMkRfMS5WZWMyRChtYXliZU5leHRQb3NYIC0gbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnBbMF0ueCwgMCkpO1xuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnBbMF0ueCA8IGxlZnRtb3N0R3JvdW5kUG9pbnQueCkge1xuICAgICAgICBpZiAoY29ubmVjdGVkICE9PSBudWxsICYmIGNvbm5lY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXliZUxlZnRHcm91bmRUeXBlQW5kSW5kZXggPSBncm91bmRUeXBlQW5kSW5kZXhbMF0gPT09IFwiZ1wiXG4gICAgICAgICAgICAgICAgPyBjb25uZWN0ZWRbMF1bZ3JvdW5kVHlwZUFuZEluZGV4WzFdXVswXVxuICAgICAgICAgICAgICAgIDogY29ubmVjdGVkWzFdW2dyb3VuZFR5cGVBbmRJbmRleFsxXV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlTGVmdEdyb3VuZFR5cGVBbmRJbmRleCA9PT0gbnVsbCB8fCBtYXliZUxlZnRHcm91bmRUeXBlQW5kSW5kZXggPT09IHVuZGVmaW5lZCkgeyAvLyBubyBvdGhlciBncm91bmQgdG8gdGhlIGxlZnRcbiAgICAgICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBmYWxsT2ZmR3JvdW5kKGksIFwibFwiLCBsZWZ0bW9zdEdyb3VuZFBvaW50LCBkaXNhYmxlRmFsbCwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW2xlZnRHcm91bmRUeXBlLCBsZWZ0R3JvdW5kSW5kZXhdID0gbWF5YmVMZWZ0R3JvdW5kVHlwZUFuZEluZGV4O1xuICAgICAgICAgICAgc3dpdGNoIChsZWZ0R3JvdW5kVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICAgICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBkZWFsV2l0aEdyb3VuZChpLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmdyb3VuZFtsZWZ0R3JvdW5kSW5kZXhdLCBbXCJnXCIsIGxlZnRHcm91bmRJbmRleF0sIGNvbm5lY3RlZCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZGVhbFdpdGhHcm91bmQoaSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5wbGF0Zm9ybVtsZWZ0R3JvdW5kSW5kZXhdLCBbXCJwXCIsIGxlZnRHcm91bmRJbmRleF0sIGNvbm5lY3RlZCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodFdhbGxUb1RoZUxlZnQgPSBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLndhbGxSW2xlZnRHcm91bmRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShyaWdodFdhbGxUb1RoZUxlZnQsIFwibFwiKS55ID4gbGVmdG1vc3RHcm91bmRQb2ludC55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlRmFsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGZhbGxPZmZHcm91bmQoaSwgXCJsXCIsIGxlZnRtb3N0R3JvdW5kUG9pbnQsIGRpc2FibGVGYWxsLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIHN1cmZhY2UgdG8gdGhlIGxlZnQgaXMgbmVpdGhlciBncm91bmQsIHBsYXRmb3JtIG9yIHJpZ2h0IHdhbGxcbiAgICAgICAgICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGZhbGxPZmZHcm91bmQoaSwgXCJsXCIsIGxlZnRtb3N0R3JvdW5kUG9pbnQsIGRpc2FibGVGYWxsLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwWzBdLnggPiByaWdodG1vc3RHcm91bmRQb2ludC54KSB7XG4gICAgICAgIGlmIChjb25uZWN0ZWQgIT09IG51bGwgJiYgY29ubmVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1heWJlUmlnaHRHcm91bmRUeXBlQW5kSW5kZXggPSBncm91bmRUeXBlQW5kSW5kZXhbMF0gPT09IFwiZ1wiXG4gICAgICAgICAgICAgICAgPyBjb25uZWN0ZWRbMF1bZ3JvdW5kVHlwZUFuZEluZGV4WzFdXVsxXVxuICAgICAgICAgICAgICAgIDogY29ubmVjdGVkWzFdW2dyb3VuZFR5cGVBbmRJbmRleFsxXV1bMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlUmlnaHRHcm91bmRUeXBlQW5kSW5kZXggPT09IG51bGwgfHwgbWF5YmVSaWdodEdyb3VuZFR5cGVBbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IC8vIG5vIG90aGVyIGdyb3VuZCB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBmYWxsT2ZmR3JvdW5kKGksIFwiclwiLCByaWdodG1vc3RHcm91bmRQb2ludCwgZGlzYWJsZUZhbGwsIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFtyaWdodEdyb3VuZFR5cGUsIHJpZ2h0R3JvdW5kSW5kZXhdID0gbWF5YmVSaWdodEdyb3VuZFR5cGVBbmRJbmRleDtcbiAgICAgICAgICAgIHN3aXRjaCAocmlnaHRHcm91bmRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGRlYWxXaXRoR3JvdW5kKGksIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuZ3JvdW5kW3JpZ2h0R3JvdW5kSW5kZXhdLCBbXCJnXCIsIHJpZ2h0R3JvdW5kSW5kZXhdLCBjb25uZWN0ZWQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGRlYWxXaXRoR3JvdW5kKGksIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UucGxhdGZvcm1bcmlnaHRHcm91bmRJbmRleF0sIFtcInBcIiwgcmlnaHRHcm91bmRJbmRleF0sIGNvbm5lY3RlZCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibFwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0V2FsbFRvVGhlUmlnaHQgPSBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLndhbGxMW3JpZ2h0R3JvdW5kSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkobGVmdFdhbGxUb1RoZVJpZ2h0LCBcInJcIikueSA+IHJpZ2h0bW9zdEdyb3VuZFBvaW50LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVGYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZmFsbE9mZkdyb3VuZChpLCBcInJcIiwgcmlnaHRtb3N0R3JvdW5kUG9pbnQsIGRpc2FibGVGYWxsLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IC8vIHN1cmZhY2UgdG8gdGhlIHJpZ2h0IGlzIG5laXRoZXIgZ3JvdW5kLCBwbGF0Zm9ybSBvciBsZWZ0IHdhbGxcbiAgICAgICAgICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGZhbGxPZmZHcm91bmQoaSwgXCJyXCIsIHJpZ2h0bW9zdEdyb3VuZFBvaW50LCBkaXNhYmxlRmFsbCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZWNicEJvdHRvbSA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwWzBdO1xuICAgICAgICBjb25zdCB5SW50ZXJjZXB0ID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5jb29yZGluYXRlSW50ZXJjZXB0KShbZWNicEJvdHRvbSwgbmV3IFZlYzJEXzEuVmVjMkQoZWNicEJvdHRvbS54LCBlY2JwQm90dG9tLnkgKyAxKV0sIGdyb3VuZCk7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIHlJbnRlcmNlcHQueSAtIGVjYnBCb3R0b20ueSArIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5hZGRpdGlvbmFsT2Zmc2V0O1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCA9ICgwLCBlY2JUcmFuc2Zvcm1fMS5tb3ZlRUNCKShtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCwgbmV3IFZlYzJEXzEuVmVjMkQoMCwgeUludGVyY2VwdC55IC0gZWNicEJvdHRvbS55ICsgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQpKTtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLm9uU3VyZmFjZSA9IFtncm91bmRPclBsYXRmb3JtLCBncm91bmRUeXBlQW5kSW5kZXhbMV1dO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kQW5nbGUgPSBNYXRoLmF0YW4yKGdyb3VuZE5vcm1hbC55LCBncm91bmROb3JtYWwueCkgfHwgTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGlmICghaWdub3JlRGFtYWdlICYmIGRhbWFnZVR5cGUgIT09IHVuZGVmaW5lZCAmJiBkYW1hZ2VUeXBlICE9PSBudWxsXG4gICAgICAgICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPT09IDApIHtcbiAgICAgICAgLy8gYXBwbHkgZGFtYWdlXG4gICAgICAgIGRlYWxXaXRoRGFtYWdpbmdTdGFnZUNvbGxpc2lvbihpLCBncm91bmROb3JtYWwsIGZhbHNlLCAwLCBkYW1hZ2VUeXBlKTtcbiAgICAgICAgc3RpbGxHcm91bmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXTtcbn1cbjtcbmZ1bmN0aW9uIGRlYWxXaXRoQ2VpbGluZ0NvbGxpc2lvbihpLCBuZXdQb3NpdGlvbiwgZWNiVG9wLCBjZWlsaW5nSW5kZXgsIGlucHV0KSB7XG4gICAgdXBkYXRlUG9zaXRpb24oaSwgbmV3UG9zaXRpb24pO1xuICAgIGNvbnN0IGNlaWxpbmcgPSAoMCwgc3RhZ2VfMS5nZXRTdXJmYWNlRnJvbVN0YWdlKShbXCJjXCIsIGNlaWxpbmdJbmRleF0sIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UpO1xuICAgIGNvbnN0IGRhbWFnZVR5cGUgPSBjZWlsaW5nWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogY2VpbGluZ1syXS5kYW1hZ2VUeXBlO1xuICAgIGNvbnN0IGNlaWxpbmdMZWZ0ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkoY2VpbGluZywgXCJsXCIpO1xuICAgIGNvbnN0IGNlaWxpbmdSaWdodCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKGNlaWxpbmcsIFwiclwiKTtcbiAgICBjb25zdCBjZWlsaW5nTm9ybWFsID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5vdXR3YXJkc1dhbGxOb3JtYWwpKGNlaWxpbmdMZWZ0LCBjZWlsaW5nUmlnaHQsIFwiY1wiKTtcbiAgICBjb25zdCBpZ25vcmVEYW1hZ2UgPSBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIkRBTUFHRUZMWU5cIiB8fCBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIkRBTUFHRUZBTExcIiB8fCBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlID09PSBcIldBTExEQU1BR0VcIjtcbiAgICBpZiAoIWlnbm9yZURhbWFnZSAmJiBkYW1hZ2VUeXBlICE9PSB1bmRlZmluZWQgJiYgZGFtYWdlVHlwZSAhPT0gbnVsbFxuICAgICAgICAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID09PSAwKSB7XG4gICAgICAgIC8vIGFwcGx5IGRhbWFnZVxuICAgICAgICBkZWFsV2l0aERhbWFnaW5nU3RhZ2VDb2xsaXNpb24oaSwgY2VpbGluZ05vcm1hbCwgZmFsc2UsIDIsIGRhbWFnZVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uaGVhZEJvbmsgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueSArIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgPiAwKSB7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5oaXRzdHVuID4gMCkge1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy50ZWNoVGltZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLlRFQ0hVLmluaXQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKDAsIGRyYXdWZnhfMS5kcmF3VmZ4KSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY2VpbGluZ0JvdW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IGVjYlRvcCxcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogMSxcbiAgICAgICAgICAgICAgICAgICAgZjogY2VpbGluZ05vcm1hbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNmeF8xLnNvdW5kcy5ib3VuY2UucGxheSgpO1xuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5TVE9QQ0VJTC5pbml0KGksIGlucHV0LCBjZWlsaW5nTm9ybWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5TVE9QQ0VJTC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIGRlYWxXaXRoQ29ybmVyQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBlY2IsIGFuZ3VsYXJQYXJhbWV0ZXIsIGRhbWFnZVR5cGUpIHtcbiAgICB1cGRhdGVQb3NpdGlvbihpLCBuZXdQb3NpdGlvbik7XG4gICAgY29uc3QgaW5zaWRlRUNCVHlwZSA9IGFuZ3VsYXJQYXJhbWV0ZXIgPCAyID8gXCJsXCIgOiBcInJcIjtcbiAgICBjb25zdCBbc2FtZSwgb3RoZXJdID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5nZXRTYW1lQW5kT3RoZXIpKGFuZ3VsYXJQYXJhbWV0ZXIpO1xuICAgIGNvbnN0IGxvd2VyRUNCUG9pbnQgPSBvdGhlciA9PT0gMiA/IGVjYltzYW1lXSA6IGVjYlswXTtcbiAgICBjb25zdCB1cHBlckVDQlBvaW50ID0gb3RoZXIgPT09IDIgPyBlY2JbMl0gOiBlY2Jbc2FtZV07XG4gICAgY29uc3Qgbm9ybWFsID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5vdXR3YXJkc1dhbGxOb3JtYWwpKGxvd2VyRUNCUG9pbnQsIHVwcGVyRUNCUG9pbnQsIGluc2lkZUVDQlR5cGUpO1xuICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5oaXRsYWcgPT09IDAgJiYgZGFtYWdlVHlwZSAhPT0gdW5kZWZpbmVkICYmIGRhbWFnZVR5cGUgIT09IG51bGxcbiAgICAgICAgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmh1cnRCb3hTdGF0ZSA9PT0gMCkge1xuICAgICAgICBkZWFsV2l0aERhbWFnaW5nU3RhZ2VDb2xsaXNpb24oaSwgbm9ybWFsLCB0cnVlLCBhbmd1bGFyUGFyYW1ldGVyLCBkYW1hZ2VUeXBlKTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBsYW5kKGksIG5ld1Bvc2l0aW9uLCB0LCBqLCBub3JtYWwsIGlucHV0KSB7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcyA9IG5ld1Bvc2l0aW9uO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCA9IHRydWU7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmRvdWJsZUp1bXBlZCA9IGZhbHNlO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5qdW1wc1VzZWQgPSAwO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5haXJib3JuZVRpbWVyID0gMDtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFzdGZhbGxlZCA9IGZhbHNlO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jaGFyZ2VGcmFtZXMgPSAwO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jaGFyZ2luZyA9IGZhbHNlO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy53YWxsSnVtcENvdW50ID0gMDtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMudGhyb3duSGl0Ym94ID0gZmFsc2U7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnNpZGVCSnVtcEZsYWcgPSB0cnVlO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vblN1cmZhY2UgPSBbdCwgal07XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLm9uTGVkZ2UgPSAtMTtcbiAgICBtYWluXzEucGxheWVyW2ldLnJvdGF0aW9uID0gMDtcbiAgICBtYWluXzEucGxheWVyW2ldLnJvdGF0aW9uUG9pbnQgPSBuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKTtcbiAgICBtYWluXzEucGxheWVyW2ldLmNvbG91ck92ZXJsYXlCb29sZWFuID0gZmFsc2U7XG4gICAgbWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5hY3RpdmUgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICAgIGxldCBuZXdOb3JtYWwgPSBub3JtYWw7XG4gICAgaWYgKG5ld05vcm1hbCA9PT0gbnVsbCB8fCBuZXdOb3JtYWwgPT09IHVuZGVmaW5lZCB8fCAobmV3Tm9ybWFsLnggPT09IDAgJiYgbmV3Tm9ybWFsLnkgPT09IDApKSB7XG4gICAgICAgIG5ld05vcm1hbCA9IG5ldyBWZWMyRF8xLlZlYzJEKDAsIDEpO1xuICAgIH1cbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kQW5nbGUgPSBNYXRoLmF0YW4yKG5ld05vcm1hbC55LCBuZXdOb3JtYWwueCk7XG4gICAgc3dpdGNoIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0ubGFuZFR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgLy8gTEFORElORyAvIE5JTFxuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnkgPj0gLTEpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uV0FJVC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5MQU5ESU5HLmluaXQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIE9XTiBGVU5DVElPTlxuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmxhbmQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIEtOT0NLRE9XTiAvIFRFQ0hcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMudGVjaFRpbWVyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFtpXVswXS5sc1ggKiBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZSA+IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uVEVDSEYuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0W2ldWzBdLmxzWCAqIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlIDwgLTAuNSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uVEVDSEIuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uVEVDSE4uaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLkRPV05CT1VORC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLkxBTkRJTkcuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueSA9IDA7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSA9IDA7XG4gICAgbWFpbl8xLnBsYXllcltpXS5oaXQuaGl0c3R1biA9IDA7XG59XG47XG5mdW5jdGlvbiBoaXRsYWdTd2l0Y2hVcGRhdGUoaSwgaW5wdXQpIHtcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID4gMCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLmhpdC5oaXRsYWctLTtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZyA9PT0gMCAmJiBtYWluXzEucGxheWVyW2ldLmhpdC5rbm9ja2JhY2sgPiAwKSB7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiZWRCeSA9PT0gLTEgfHwgbWFpbl8xLnBsYXllcltpXS5oaXQua25vY2tiYWNrID4gNTApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdBbmdsZSA9ICgwLCBoaXREZXRlY3Rpb25fMS5nZXRMYXVuY2hBbmdsZSkobWFpbl8xLnBsYXllcltpXS5oaXQuYW5nbGUsIG1haW5fMS5wbGF5ZXJbaV0uaGl0Lmtub2NrYmFjaywgbWFpbl8xLnBsYXllcltpXS5oaXQucmV2ZXJzZSwgaW5wdXRbaV1bMF0ubHNYLCBpbnB1dFtpXVswXS5sc1ksIGkpO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnggPSAwO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnkgPSAwO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cobmV3QW5nbGUpO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnggPSAoMCwgaGl0RGV0ZWN0aW9uXzEuZ2V0SG9yaXpvbnRhbFZlbG9jaXR5KShtYWluXzEucGxheWVyW2ldLmhpdC5rbm9ja2JhY2ssIG5ld0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55ID0gKDAsIGhpdERldGVjdGlvbl8xLmdldFZlcnRpY2FsVmVsb2NpdHkpKG1haW5fMS5wbGF5ZXJbaV0uaGl0Lmtub2NrYmFjaywgbmV3QW5nbGUsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCwgbWFpbl8xLnBsYXllcltpXS5oaXQuYW5nbGUpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocGxheWVyW2ldLnBoeXMua1ZlbCk7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtEZWMueCA9ICgwLCBoaXREZXRlY3Rpb25fMS5nZXRIb3Jpem9udGFsRGVjYXkpKG5ld0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua0RlYy55ID0gKDAsIGhpdERldGVjdGlvbl8xLmdldFZlcnRpY2FsRGVjYXkpKG5ld0FuZ2xlKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBsYXllcltpXS5waHlzLmtEZWMpO1xuICAgICAgICAgICAgICAgIC8vcGxheWVyW2ldLmhpdC5oaXRzdHVuID0gZ2V0SGl0c3R1bihwbGF5ZXJbaV0uaGl0Lmtub2NrYmFjayk7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLm9uTGVkZ2UgPSAtMTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY2hhcmdlRnJhbWVzID0gMDtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuc2hpZWxkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyppZiAocGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQpe1xuICAgICAgICAgICAgICAgICBpZiAobmV3QW5nbGUgPT0gMCB8fCBuZXdBbmdsZSA+IDI3MCl7XG4gICAgICAgICAgICAgICAgIHBsYXllcltpXS5waHlzLmtWZWwueSA9IDA7XG4gICAgICAgICAgICAgICAgIHBsYXllcltpXS5waHlzLmtEZWMueCA9IHBsYXllcltpXS5jaGFyQXR0cmlidXRlcy50cmFjdGlvbjtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXdBbmdsZSA+IDE4MCl7XG4gICAgICAgICAgICAgICAgIHBsYXllcltpXS5waHlzLmtWZWwueSA9IDA7XG4gICAgICAgICAgICAgICAgIHBsYXllcltpXS5waHlzLmtEZWMueCA9IC1wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMudHJhY3Rpb247XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0Lmtub2NrYmFjayA+PSA4MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKz0gMC4wMDAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLmhpdC5rbm9ja2JhY2sgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vU0RJIC8gQVNESVxuICAgICAgICBzd2l0Y2ggKG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJEQU1BR0VOMlwiOlxuICAgICAgICAgICAgY2FzZSBcIkRBTUFHRUZMWU5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJHVUFSRE9OXCI6XG4gICAgICAgICAgICBjYXNlIFwiR1VBUkRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJET1dOREFNQUdFXCI6XG4gICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpbnB1dFtpXVswXS5sc1ggPiAwLjcgJiYgaW5wdXRbaV1bMV0ubHNYIDwgMC43KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0W2ldWzBdLmxzWCA8IC0wLjcgJiYgaW5wdXRbaV1bMV0ubHNYID4gLTAuNykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnB1dFtpXVswXS5sc1kgPiAwLjcgJiYgaW5wdXRbaV1bMV0ubHNZIDwgMC43KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0W2ldWzBdLmxzWSA8IC0wLjcgJiYgaW5wdXRbaV1bMV0ubHNZID4gLTAuNykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKChpbnB1dFtpXVswXS5sc1ggKiBpbnB1dFtpXVswXS5sc1gpICsgKGlucHV0W2ldWzBdLmxzWSAqIGlucHV0W2ldWzBdLmxzWSkgPCAoMC40OSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ICs9IGlucHV0W2ldWzBdLmxzWCAqIDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICs9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCA/IDAgOiBpbnB1dFtpXVswXS5sc1kgKiA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggKz0gaW5wdXRbaV1bMF0ubHNYICogMztcbiAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICs9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCA/IDAgOiBpbnB1dFtpXVswXS5sc1kgKiAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgaGl0bGFnIGp1c3QgZW5kZWQsIGRvIG5vcm1hbCBzdHVmZiBhcyB3ZWxsXG4gICAgICAgICAgICBoaXRsYWdTd2l0Y2hVcGRhdGUoaSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuc2hpZWxkc3R1biA+IDApIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocGxheWVyW2ldLmhpdC5zaGllbGRzdHVuKTtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uaGl0LnNoaWVsZHN0dW4tLTtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5zaGllbGRzdHVuIDwgMCkge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uaGl0LnNoaWVsZHN0dW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coYWN0aW9uU3RhdGVzW2NoYXJhY3RlclNlbGVjdGlvbnNbaV1dW3BsYXllcltpXS5hY3Rpb25TdGF0ZV0pO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY2FuV2FsbEp1bXAgPSBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0ud2FsbEp1bXBBYmxlO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuYlR1cm5hcm91bmRUaW1lci0tO1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmJUdXJuYXJvdW5kVGltZXIgPCAwKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuYlR1cm5hcm91bmRUaW1lciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbnB1dFtpXVswXS5sc1ggPiAwLjkgJiYgaW5wdXRbaV1bMV0ubHNYIDwgMC45KSB8fFxuICAgICAgICAgICAgKGlucHV0W2ldWzBdLmxzWCA8IC0wLjkgJiYgaW5wdXRbaV1bMV0ubHNYID4gLTAuOSkpIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5iVHVybmFyb3VuZFRpbWVyID0gMjA7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuYlR1cm5hcm91bmREaXJlY3Rpb24gPSBNYXRoLnNpZ24oaW5wdXRbaV1bMF0ubHNYKTtcbiAgICAgICAgfVxuICAgICAgICBtYWluXzEucGxheWVyW2ldLnByZXZBY3Rpb25TdGF0ZSA9IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGU7XG4gICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5tYWluKGksIGlucHV0KTtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uc2hvY2tlZCA+IDApIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uc2hvY2tlZC0tO1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uc2hvY2tlZCAlIDUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZnhfMS5zb3VuZHMuZWxlY3RyaWNmaXp6LnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBkcmF3VmZ4XzEuZHJhd1ZmeCkoe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwic2hvY2tlZFwiLFxuICAgICAgICAgICAgICAgIHBvczogbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyA1KSxcbiAgICAgICAgICAgICAgICBmYWNlOiBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uYnVybmluZyA+IDApIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uYnVybmluZy0tO1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uYnVybmluZyAlIDYgPT09IDApIHtcbiAgICAgICAgICAgICAgICAoMCwgZHJhd1ZmeF8xLmRyYXdWZngpKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJidXJuaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvczogbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyA1KSxcbiAgICAgICAgICAgICAgICAgICAgZmFjZTogbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUVVJCTyBNT0RFXG4gICAgICAgIC8vIGlmIGp1c3QgY2hhbmdlZCBhY3Rpb24gc3RhdGVzLCByZW1vdmUgYWJpbGl0eSB0byBjYW5jZWxcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucHJldkFjdGlvblN0YXRlICE9PSBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLmhhc0hpdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5nc18xLmdhbWVTZXR0aW5ncy50dXJibyAmJiBtYWluXzEuZ2FtZU1vZGUgIT09IDUpIHtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhhc0hpdCkge1xuICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlICE9PSBcIkNBVENIQVRUQUNLXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLnR1cmJvR3JvdW5kZWRJbnRlcnJ1cHQpKGksIGlucHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uaGFzSGl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEudHVyYm9BaXJib3JuZUludGVycnVwdCkoaSwgaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5oYXNIaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMobWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvU2lnbiA9IE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54KTtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQpIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54IC09IG9TaWduICogbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy50cmFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnggLT0gbWFpbl8xLnBsYXllcltpXS5waHlzLmtEZWMueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvU2lnbiAhPT0gTWF0aC5zaWduKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLngpKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkpID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgb1NpZ24gPSBNYXRoLnNpZ24obWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSk7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55IC09IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rRGVjLnk7XG4gICAgICAgICAgICBpZiAob1NpZ24gIT09IE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55KSkge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCArPSBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54ICsgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueDtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICs9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnkgKyBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55O1xuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIGh1cnRCb3hTdGF0ZVVwZGF0ZShpKSB7XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiUkVCSVJUSFwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiUkVCSVJUSFdBSVRcIikge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPSAwO1xuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmludmluY2libGVUaW1lciA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmludmluY2libGVUaW1lci0tO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID0gMjtcbiAgICB9XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5pbnRhbmdpYmxlVGltZXIgPiAwKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5pbnRhbmdpYmxlVGltZXItLTtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmh1cnRCb3hTdGF0ZSA9IDE7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gb3V0T2ZDYW1lcmFVcGRhdGUoaSkge1xuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMub3V0T2ZDYW1lcmFUaW1lciA+PSA2MCkge1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5wZXJjZW50IDwgMTUwKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBlcmNlbnQrKztcbiAgICAgICAgfVxuICAgICAgICAoMCwgbWFpbl8xLnBlcmNlbnRTaGFrZSkoNDAsIGkpO1xuICAgICAgICBzZnhfMS5zb3VuZHMub3V0b2ZjYW1lcmEucGxheSgpO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMub3V0T2ZDYW1lcmFUaW1lciA9IDA7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gbENhbmNlbFVwZGF0ZShpLCBpbnB1dCkge1xuICAgIC8vIGlmIHNtYXNoIDY0IGxjYW5jZWwsIHB1dCBhbnkgbGFuZGluZ2F0dGFja2FpciBhY3Rpb24gc3RhdGVzIGludG8gbGFuZGluZ1xuICAgIGlmIChzZXR0aW5nc18xLmdhbWVTZXR0aW5ncy5sQ2FuY2VsVHlwZSA9PT0gMiAmJiBtYWluXzEuZ2FtZU1vZGUgIT09IDUpIHtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sQ2FuY2VsKSB7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZS5zdWJzdHIoMCwgMTYpID09PSBcIkxBTkRJTkdBVFRBQ0tBSVJcIikge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPSBcIkxBTkRJTkdcIjtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnRpbWVyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmxDYW5jZWxUaW1lciA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmxDYW5jZWxUaW1lci0tO1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmxDYW5jZWxUaW1lciA9PT0gMCkge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmxDYW5jZWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBsIENBTkNFTFxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbFRpbWVyID09PSAwICYmXG4gICAgICAgICgoaW5wdXRbaV1bMF0ubEEgPiAwICYmIGlucHV0W2ldWzFdLmxBID09PSAwKSB8fFxuICAgICAgICAgICAgKGlucHV0W2ldWzBdLnJBID4gMCAmJiBpbnB1dFtpXVsxXS5yQSA9PT0gMCkgfHxcbiAgICAgICAgICAgIChpbnB1dFtpXVswXS56ICYmICFpbnB1dFtpXVsxXS56KSkpIHtcbiAgICAgICAgLy8gaWYgc21hc2ggNjQgbGNhbmNlbCwgaW5jcmVhc2Ugd2luZG93IHRvIDExIGZyYW1lc1xuICAgICAgICBpZiAoc2V0dGluZ3NfMS5nYW1lU2V0dGluZ3MubENhbmNlbFR5cGUgPT09IDIgJiYgbWFpbl8xLmdhbWVNb2RlICE9PSA1KSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbFRpbWVyID0gMTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbFRpbWVyID0gNztcbiAgICAgICAgfVxuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbCA9IHRydWU7XG4gICAgfVxuICAgIC8vIGlmIGF1dG8gbGNhbmNlbCBpcyBvbiwgYWx3YXlzIGxjYW5jZWxcbiAgICBpZiAoc2V0dGluZ3NfMS5nYW1lU2V0dGluZ3MubENhbmNlbFR5cGUgPT09IDEgJiYgbWFpbl8xLmdhbWVNb2RlICE9PSA1KSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sQ2FuY2VsID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gViBDYW5jZWxcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnZDYW5jZWxUaW1lciA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnZDYW5jZWxUaW1lci0tO1xuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnRlY2hUaW1lciA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnRlY2hUaW1lci0tO1xuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnNob3VsZGVyTG9ja291dCA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnNob3VsZGVyTG9ja291dC0tO1xuICAgIH1cbiAgICBpZiAoKGlucHV0W2ldWzBdLmwgJiYgIWlucHV0W2ldWzFdLmwpIHx8XG4gICAgICAgIChpbnB1dFtpXVswXS5yICYmICFpbnB1dFtpXVsxXS5yKSkge1xuICAgICAgICBpZiAoIW1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCkge1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5zaG91bGRlckxvY2tvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMudkNhbmNlbFRpbWVyID0gMztcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMudGVjaFRpbWVyID0gMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnNob3VsZGVyTG9ja291dCA9IDQwO1xuICAgIH1cbn1cbjtcbmNvbnN0IG51bGxTcXVhc2hEYXR1bSA9IHsgbG9jYXRpb246IG51bGwsIGZhY3RvcjogMSB9O1xuY29uc3QgZWNiU3F1YXNoRGF0YSA9IFtudWxsU3F1YXNoRGF0dW0sXG4gICAgbnVsbFNxdWFzaERhdHVtLFxuICAgIG51bGxTcXVhc2hEYXR1bSxcbiAgICBudWxsU3F1YXNoRGF0dW1dO1xuZnVuY3Rpb24gZmluZEFuZFJlc29sdmVDb2xsaXNpb25zKGksIGlucHV0LCBvbGRCYWNrd2FyZCwgb2xkTm90VG91Y2hpbmdXYWxscywgZWNiT2Zmc2V0KSB7XG4gICAgbGV0IHN0aWxsR3JvdW5kZWQgPSB0cnVlO1xuICAgIGxldCBiYWNrd2FyZCA9IG9sZEJhY2t3YXJkO1xuICAgIGNvbnN0IG5vdFRvdWNoaW5nV2FsbHMgPSBvbGROb3RUb3VjaGluZ1dhbGxzO1xuICAgIGNvbnN0IGNvbm5lY3RlZCA9IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuY29ubmVjdGVkO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdyb3VuZGVkIHN0YXRlIG1vdmVtZW50XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCkge1xuICAgICAgICBjb25zdCBvbGRQb3NpdGlvbiA9IG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55KTtcbiAgICAgICAgY29uc3QgcmVsZXZhbnRHcm91bmRJbmRleCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vblN1cmZhY2VbMV07XG4gICAgICAgIGxldCByZWxldmFudEdyb3VuZFR5cGUgPSBcImdcIjtcbiAgICAgICAgbGV0IHJlbGV2YW50R3JvdW5kID0gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5ncm91bmRbcmVsZXZhbnRHcm91bmRJbmRleF07XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMub25TdXJmYWNlWzBdID09PSAxKSB7XG4gICAgICAgICAgICByZWxldmFudEdyb3VuZFR5cGUgPSBcInBcIjtcbiAgICAgICAgICAgIHJlbGV2YW50R3JvdW5kID0gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5wbGF0Zm9ybVtyZWxldmFudEdyb3VuZEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWxldmFudEdyb3VuZFR5cGVBbmRJbmRleCA9IFtyZWxldmFudEdyb3VuZFR5cGUsIHJlbGV2YW50R3JvdW5kSW5kZXhdO1xuICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZGVhbFdpdGhHcm91bmQoaSwgcmVsZXZhbnRHcm91bmQsIHJlbGV2YW50R3JvdW5kVHlwZUFuZEluZGV4LCBjb25uZWN0ZWQsIGlucHV0KTtcbiAgICB9XG4gICAgLy8gZW5kIG9mIGdyb3VuZGVkIHN0YXRlIG1vdmVtZW50XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbWFpbiBjb2xsaXNpb24gZGV0ZWN0aW9uIHJvdXRpbmVcbiAgICBjb25zdCBub3RJZ25vcmluZ1BsYXRmb3JtcyA9ICgoIWFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5jYW5QYXNzVGhyb3VnaCB8fCAoaW5wdXRbaV1bMF0ubHNZID4gLTAuNTYpKSAmJiAhbWFpbl8xLnBsYXllcltpXS5waHlzLnBhc3NpbmcpO1xuICAgIGNvbnN0IGlzSW1tdW5lID0gbWFpbl8xLnBsYXllcltpXS5waHlzLmh1cnRCb3hTdGF0ZSAhPT0gMDtcbiAgICBjb25zdCBwbGF5ZXJTdGF0dXNJbmZvID0ge1xuICAgICAgICBpZ25vcmluZ1BsYXRmb3JtczogIW5vdElnbm9yaW5nUGxhdGZvcm1zLFxuICAgICAgICBncm91bmRlZDogbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkLFxuICAgICAgICBpbW11bmU6IGlzSW1tdW5lXG4gICAgfTtcbiAgICAvLyB0eXBlIENvbGxpc2lvblJvdXRpbmVSZXN1bHQgPSB7IHBvc2l0aW9uIDogVmVjMkQsIHRvdWNoaW5nIDogbnVsbCB8IFNpbXBsZVRvdWNoaW5nRGF0dW0sIHNxdWFzaERhdHVtIDogU3F1YXNoRGF0dW0sIGVjYiA6IEVDQn07XG4gICAgY29uc3QgY29sbGlzaW9uRGF0YSA9ICgwLCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEucnVuQ29sbGlzaW9uUm91dGluZSkobWFpbl8xLnBsYXllcltpXS5waHlzLkVDQjEsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwLCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLCBlY2JTcXVhc2hEYXRhW2ldLCBwbGF5ZXJTdGF0dXNJbmZvLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlKTtcbiAgICBlY2JTcXVhc2hEYXRhW2ldID0gY29sbGlzaW9uRGF0YS5zcXVhc2hEYXR1bTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IGNvbGxpc2lvbkRhdGEucG9zaXRpb247XG4gICAgY29uc3QgbmV3RUNCID0gY29sbGlzaW9uRGF0YS5lY2I7XG4gICAgY29uc3QgdG91Y2hpbmdEYXR1bSA9IGNvbGxpc2lvbkRhdGEudG91Y2hpbmc7XG4gICAgaWYgKHRvdWNoaW5nRGF0dW0gPT09IG51bGwpIHtcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oaSwgbmV3UG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b3VjaGluZ0RhdHVtLmtpbmQgPT09IFwic3VyZmFjZVwiKSB7XG4gICAgICAgIGNvbnN0IHN1cmZhY2VMYWJlbCA9IHRvdWNoaW5nRGF0dW0udHlwZTtcbiAgICAgICAgY29uc3Qgc3VyZmFjZUluZGV4ID0gdG91Y2hpbmdEYXR1bS5pbmRleDtcbiAgICAgICAgY29uc3QgcHQgPSB0b3VjaGluZ0RhdHVtLnB0O1xuICAgICAgICBzd2l0Y2ggKHN1cmZhY2VMYWJlbFswXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwibFwiOiAvLyBwbGF5ZXIgdG91Y2hpbmcgbGVmdCB3YWxsXG4gICAgICAgICAgICAgICAgbm90VG91Y2hpbmdXYWxsc1swXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlYWxXaXRoV2FsbENvbGxpc2lvbihpLCBuZXdQb3NpdGlvbiwgcHQsIFwibFwiLCBzdXJmYWNlSW5kZXgsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6IC8vIHBsYXllciB0b3VjaGluZyByaWdodCB3YWxsXG4gICAgICAgICAgICAgICAgbm90VG91Y2hpbmdXYWxsc1sxXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlYWxXaXRoV2FsbENvbGxpc2lvbihpLCBuZXdQb3NpdGlvbiwgcHQsIFwiclwiLCBzdXJmYWNlSW5kZXgsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnXCI6IC8vIHBsYXllciBsYW5kZWQgb24gZ3JvdW5kXG4gICAgICAgICAgICAgICAgZGVhbFdpdGhHcm91bmRDb2xsaXNpb24oaSwgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkLCBuZXdQb3NpdGlvbiwgbmV3RUNCWzBdLCBzdXJmYWNlSW5kZXgsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjXCI6IC8vIHBsYXllciB0b3VjaGluZyBjZWlsaW5nXG4gICAgICAgICAgICAgICAgZGVhbFdpdGhDZWlsaW5nQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBuZXdFQ0JbMl0sIHN1cmZhY2VJbmRleCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBcIjogLy8gcGxheWVyIGxhbmRlZCBvbiBwbGF0Zm9ybVxuICAgICAgICAgICAgICAgIGRlYWxXaXRoUGxhdGZvcm1Db2xsaXNpb24oaSwgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkLCBuZXdQb3NpdGlvbiwgbmV3RUNCWzBdLCBzdXJmYWNlSW5kZXgsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvciBpbiAnZmluZEFuZFJlc29sdmVDb2xsaXNpb25zJzogdW5yZWNvZ25pc2VkIHN1cmZhY2UgdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodG91Y2hpbmdEYXR1bS5raW5kID09PSBcImNvcm5lclwiKSB7XG4gICAgICAgIGNvbnN0IGFuZ3VsYXJQYXJhbWV0ZXIgPSB0b3VjaGluZ0RhdHVtLmFuZ3VsYXI7XG4gICAgICAgIGNvbnN0IGNvcm5lckRhbWFnZVR5cGUgPSB0b3VjaGluZ0RhdHVtLmRhbWFnZVR5cGUgIT09IHVuZGVmaW5lZCA/IHRvdWNoaW5nRGF0dW0uZGFtYWdlVHlwZSA6IG51bGw7XG4gICAgICAgIGRlYWxXaXRoQ29ybmVyQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBuZXdFQ0IsIGFuZ3VsYXJQYXJhbWV0ZXIsIGNvcm5lckRhbWFnZVR5cGUpO1xuICAgIH1cbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCMSA9IG5ld0VDQjtcbiAgICAvLyBmaW5hbGx5LCBjYWxjdWxhdGUgaG93IG11Y2ggc3F1YXNoaW5nIGlzIHJlcXVpcmVkIGJ5IHRoZSBncm91bmRcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgIGNvbnN0IGdyb3VuZFNxdWFzaEZhY3RvciA9ICgwLCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuZ3JvdW5kZWRFQ0JTcXVhc2hGYWN0b3IpKG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgZWNiT2Zmc2V0WzNdKSAvLyAgICB0b3Agbm9uLXNxdWFzaGVkIEVDQnAgcG9pbnRcbiAgICAgICAgLCBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSkgLy8gYm90dG9tIG5vbi1zcXVhc2hlZCBFQ0JwIHBvaW50LCBubyBvZmZzZXQgYXMgZ3JvdW5kZWRcbiAgICAgICAgLCAoMCwgdG9MaXN0XzEudG9MaXN0KShhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmNlaWxpbmcpKTtcbiAgICAgICAgaWYgKGdyb3VuZFNxdWFzaEZhY3RvciAhPT0gbnVsbCAmJiAoZ3JvdW5kU3F1YXNoRmFjdG9yIDwgZWNiU3F1YXNoRGF0YVtpXS5mYWN0b3IpKSB7XG4gICAgICAgICAgICBlY2JTcXVhc2hEYXRhW2ldID0geyBsb2NhdGlvbjogMCwgZmFjdG9yOiBncm91bmRTcXVhc2hGYWN0b3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWNiU3F1YXNoRGF0YVtpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZWNiU3F1YXNoRGF0YVtpXS5sb2NhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZCwgbm90VG91Y2hpbmdXYWxsc107XG59XG47XG5mdW5jdGlvbiBkZWFsV2l0aExlZGdlcyhpLCBpbnB1dCkge1xuICAgIGNvbnN0IHBsYXllclBvc1ggPSBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLng7XG4gICAgY29uc3QgcGxheWVyUG9zWSA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueTtcbiAgICAvL1RPRE8gZmluZCBvdXQgd2hhdCB0aGVzZSBtYWdpYyBudW1iZXJzIGFyZVxuICAgIGNvbnN0IGxlZGdlU25hcEJveE9mZnNldDIgPSBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLmxlZGdlU25hcEJveE9mZnNldFsyXTtcbiAgICBjb25zdCBsZWRnZVNuYXBCb3hPZmZzZXQwID0gbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5sZWRnZVNuYXBCb3hPZmZzZXRbMF07XG4gICAgY29uc3QgbGVkZ2VTbmFwQm94T2Zmc2V0MSA9IG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMubGVkZ2VTbmFwQm94T2Zmc2V0WzFdO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hGID0gbmV3IEJveDJEXzEuQm94MkQoW3BsYXllclBvc1gsIHBsYXllclBvc1kgKyBsZWRnZVNuYXBCb3hPZmZzZXQyXSwgW3BsYXllclBvc1ggKyBsZWRnZVNuYXBCb3hPZmZzZXQwLCBwbGF5ZXJQb3NZICsgbGVkZ2VTbmFwQm94T2Zmc2V0MV0pO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hCID0gbmV3IEJveDJEXzEuQm94MkQoW3BsYXllclBvc1ggLSBsZWRnZVNuYXBCb3hPZmZzZXQwLCBwbGF5ZXJQb3NZICsgbGVkZ2VTbmFwQm94T2Zmc2V0Ml0sIFtwbGF5ZXJQb3NYLCBwbGF5ZXJQb3NZICsgbGVkZ2VTbmFwQm94T2Zmc2V0MV0pO1xuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VSZWdyYWJDb3VudCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VSZWdyYWJUaW1lb3V0LS07XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VSZWdyYWJUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VSZWdyYWJDb3VudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBsc0JGID0gLTE7XG4gICAgbGV0IGxzQkIgPSAtMTtcbiAgICBsZXQgZm91bmRMZWRnZSA9IDA7XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vbkxlZGdlID09PSAtMSAmJiAhbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlUmVncmFiQ291bnQpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmxlZGdlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbGVkZ2VBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCA0OyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllclR5cGVba10gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoayAhPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJba10ucGh5cy5vbkxlZGdlID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVkZ2VBdmFpbGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWRnZUF2YWlsYWJsZSAmJiAhbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkICYmIG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdHN0dW4gPD0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlW2FjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2Vbal1bMF1dW2FjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2Vbal1bMV1dW2FjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2Vbal1bMl1dLng7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2VbYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVswXV1bYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVsxXV1bYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVsyXV0ueTtcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hGLm1pbi54ICYmXG4gICAgICAgICAgICAgICAgICAgIHggPCBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VTbmFwQm94Ri5tYXgueCAmJlxuICAgICAgICAgICAgICAgICAgICB5IDwgbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEYubWluLnkgJiZcbiAgICAgICAgICAgICAgICAgICAgeSA+IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hGLm1heC55KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmxlZGdlW2pdWzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmNhbkdyYWJMZWRnZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxzQkYgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5jYW5HcmFiTGVkZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxzQkYgPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh4ID4gbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEIubWluLnggJiZcbiAgICAgICAgICAgICAgICAgICAgeCA8IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hCLm1heC54ICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPCBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VTbmFwQm94Qi5taW4ueSAmJlxuICAgICAgICAgICAgICAgICAgICB5ID4gbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEYubWF4LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2Vbal1bMl0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uY2FuR3JhYkxlZGdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHNCQiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmNhbkdyYWJMZWRnZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHNCQiA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueSA8IDAgJiYgaW5wdXRbaV1bMF0ubHNZID4gLTAuNSkge1xuICAgICAgICAgICAgICAgIGlmIChsc0JGID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRMZWRnZSA9IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2VbbHNCRl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZExlZGdlWzJdICogLTIgKyAxID09PSBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZSB8fCBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uY2FuR3JhYkxlZGdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMub25MZWRnZSA9IGxzQkY7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VSZWdyYWJUaW1lb3V0ID0gMzA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZSA9IGZvdW5kTGVkZ2VbMl0gKiAtMiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zID0gbmV3IFZlYzJEXzEuVmVjMkQoYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZVtmb3VuZExlZGdlWzBdXVtmb3VuZExlZGdlWzFdXVtmb3VuZExlZGdlWzJdXS54ICsgbWFpbl8xLmVkZ2VPZmZzZXRbMF1bMF0sIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2VbZm91bmRMZWRnZVswXV1bZm91bmRMZWRnZVsxXV1bZm91bmRMZWRnZVsyXV0ueSArIG1haW5fMS5lZGdlT2Zmc2V0WzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5DTElGRkNBVENILmluaXQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxzQkIgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZExlZGdlID0gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtsc0JCXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kTGVkZ2VbMl0gKiAtMiArIDEgPT09IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlIHx8IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5jYW5HcmFiTGVkZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vbkxlZGdlID0gbHNCQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVJlZ3JhYlRpbWVvdXQgPSAzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlID0gZm91bmRMZWRnZVsyXSAqIC0yICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MgPSBuZXcgVmVjMkRfMS5WZWMyRChhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlW2ZvdW5kTGVkZ2VbMF1dW2ZvdW5kTGVkZ2VbMV1dW2ZvdW5kTGVkZ2VbMl1dLnggKyBtYWluXzEuZWRnZU9mZnNldFsxXVswXSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZVtmb3VuZExlZGdlWzBdXVtmb3VuZExlZGdlWzFdXVtmb3VuZExlZGdlWzJdXS55ICsgbWFpbl8xLmVkZ2VPZmZzZXRbMV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLkNMSUZGQ0FUQ0guaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG47XG5mdW5jdGlvbiBkZWFsV2l0aERlYXRoKGksIGlucHV0KSB7XG4gICAgaWYgKCFhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uZGVhZCAmJiBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlICE9PSBcIlNMRUVQXCIpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gMDtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA8IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuYmxhc3R6b25lLm1pbi54KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiREVBRExFRlRcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggPiBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmJsYXN0em9uZS5tYXgueCkge1xuICAgICAgICAgICAgc3RhdGUgPSBcIkRFQURSSUdIVFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA8IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuYmxhc3R6b25lLm1pbi55KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiREVBRERPV05cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgPiBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmJsYXN0em9uZS5tYXgueSAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55ID49IDIuNCkge1xuICAgICAgICAgICAgc3RhdGUgPSBcIkRFQURVUFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLm91dE9mQ2FtZXJhVGltZXIgPSAwO1xuICAgICAgICAgICAgKDAsIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEudHVybk9mZkhpdGJveGVzKShpKTtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uc3RvY2tzLS07XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLmNvbG91ck92ZXJsYXlCb29sZWFuID0gZmFsc2U7XG4gICAgICAgICAgICByZW5kZXJfMS5sb3N0U3RvY2tRdWV1ZS5wdXNoKFtpLCBtYWluXzEucGxheWVyW2ldLnN0b2NrcywgMF0pO1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uc3RvY2tzID09PSAwICYmIG1haW5fMS52ZXJzdXNNb2RlKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5zdG9ja3MgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW3N0YXRlXS5pbml0KGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIHVwZGF0ZUhpdGJveGVzKGkpIHtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaXNJbnRlcnBvbGF0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5hY3RpdmVbal0gJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmFjdGl2ZVtqXSkge1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wcmV2RnJhbWVIaXRib3hlcy5pZFtqXS5vZmZzZXRbbWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmZyYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5pZFtqXS5vZmZzZXRbbWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5mcmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaDEgPSBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zUHJldi54ICsgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wcmV2RnJhbWVIaXRib3hlcy5pZFtqXS5vZmZzZXRbbWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmZyYW1lXS54ICogbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2VQcmV2KSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvc1ByZXYueSArIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wcmV2RnJhbWVIaXRib3hlcy5pZFtqXS5vZmZzZXRbbWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmZyYW1lXS55KTtcbiAgICAgICAgICAgIGNvbnN0IGgyID0gbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ICsgKG1haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuaWRbal0ub2Zmc2V0W21haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuZnJhbWVdLnggKiBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZSksIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIG1haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuaWRbal0ub2Zmc2V0W21haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuZnJhbWVdLnkpO1xuICAgICAgICAgICAgY29uc3QgYSA9IGgyLnggLSBoMS54O1xuICAgICAgICAgICAgY29uc3QgYiA9IGgyLnkgLSBoMS55O1xuICAgICAgICAgICAgbGV0IHggPSAwO1xuICAgICAgICAgICAgaWYgKCEoYSA9PT0gMCB8fCBiID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLmF0YW4oTWF0aC5hYnMoYSkgLyBNYXRoLmFicyhiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BwID0gTWF0aC5zaW4oeCkgKiBtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmlkW2pdLnNpemU7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqID0gTWF0aC5jb3MoeCkgKiBtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmlkW2pdLnNpemU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbWEgPSBbaDEueCwgaDEueV07XG4gICAgICAgICAgICAgICAgbGV0IGFscGhhMTtcbiAgICAgICAgICAgICAgICBsZXQgYWxwaGEyO1xuICAgICAgICAgICAgICAgIGxldCBiZXRhMTtcbiAgICAgICAgICAgICAgICBsZXQgYmV0YTI7XG4gICAgICAgICAgICAgICAgaWYgKChhID4gMCAmJiBiID4gMCkgfHwgKGEgPD0gMCAmJiBiIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IG5ldyBWZWMyRF8xLlZlYzJEKChzaWdtYVswXSArIGFkaiksIChzaWdtYVsxXSAtIG9wcCkpO1xuICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBuZXcgVmVjMkRfMS5WZWMyRCgoYWxwaGExLnggKyBhKSwgKGFscGhhMS55ICsgYikpO1xuICAgICAgICAgICAgICAgICAgICBiZXRhMSA9IG5ldyBWZWMyRF8xLlZlYzJEKChzaWdtYVswXSAtIGFkaiksIChzaWdtYVsxXSArIG9wcCkpO1xuICAgICAgICAgICAgICAgICAgICBiZXRhMiA9IG5ldyBWZWMyRF8xLlZlYzJEKChiZXRhMS54ICsgYSksIChiZXRhMS55ICsgYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbmV3IFZlYzJEXzEuVmVjMkQoKHNpZ21hWzBdIC0gYWRqKSwgKHNpZ21hWzFdIC0gb3BwKSk7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IG5ldyBWZWMyRF8xLlZlYzJEKChhbHBoYTEueCArIGEpLCAoYWxwaGExLnkgKyBiKSk7XG4gICAgICAgICAgICAgICAgICAgIGJldGExID0gbmV3IFZlYzJEXzEuVmVjMkQoKHNpZ21hWzBdICsgYWRqKSwgKHNpZ21hWzFdICsgb3BwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJldGEyID0gbmV3IFZlYzJEXzEuVmVjMkQoKGJldGExLnggKyBhKSwgKGJldGExLnkgKyBiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5pbnRlclBvbGF0ZWRIaXRib3hbal0gPSBbYWxwaGExLCBhbHBoYTIsIGJldGEyLCBiZXRhMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BwID0gTWF0aC5zaW4oeCkgKiBtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmlkW2pdLnNpemUgLSBzZXR0aW5nc18xLmdhbWVTZXR0aW5ncy5waGFudG9tVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkaiA9IE1hdGguY29zKHgpICogbWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5pZFtqXS5zaXplIC0gc2V0dGluZ3NfMS5nYW1lU2V0dGluZ3MucGhhbnRvbVRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYSA9IFtoMS54LCBoMS55XTtcbiAgICAgICAgICAgICAgICBsZXQgYWxwaGExO1xuICAgICAgICAgICAgICAgIGxldCBhbHBoYTI7XG4gICAgICAgICAgICAgICAgbGV0IGJldGExO1xuICAgICAgICAgICAgICAgIGxldCBiZXRhMjtcbiAgICAgICAgICAgICAgICBpZiAoKGEgPiAwICYmIGIgPiAwKSB8fCAoYSA8PSAwICYmIGIgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbmV3IFZlYzJEXzEuVmVjMkQoKHNpZ21hWzBdICsgYWRqKSwgKHNpZ21hWzFdIC0gb3BwKSk7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IG5ldyBWZWMyRF8xLlZlYzJEKChhbHBoYTEueCArIGEpLCAoYWxwaGExLnkgKyBiKSk7XG4gICAgICAgICAgICAgICAgICAgIGJldGExID0gbmV3IFZlYzJEXzEuVmVjMkQoKHNpZ21hWzBdIC0gYWRqKSwgKHNpZ21hWzFdICsgb3BwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJldGEyID0gbmV3IFZlYzJEXzEuVmVjMkQoKGJldGExLnggKyBhKSwgKGJldGExLnkgKyBiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBuZXcgVmVjMkRfMS5WZWMyRCgoc2lnbWFbMF0gLSBhZGopLCAoc2lnbWFbMV0gLSBvcHApKTtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gbmV3IFZlYzJEXzEuVmVjMkQoKGFscGhhMS54ICsgYSksIChhbHBoYTEueSArIGIpKTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YTEgPSBuZXcgVmVjMkRfMS5WZWMyRCgoc2lnbWFbMF0gKyBhZGopLCAoc2lnbWFbMV0gKyBvcHApKTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YTIgPSBuZXcgVmVjMkRfMS5WZWMyRCgoYmV0YTEueCArIGEpLCAoYmV0YTEueSArIGIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmludGVyUG9sYXRlZEhpdGJveFBoYW50b21bal0gPSBbYWxwaGExLCBhbHBoYTIsIGJldGEyLCBiZXRhMV07XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmlzSW50ZXJwb2xhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIHBoeXNpY3MoaSwgaW5wdXQpIHtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucGFzc2luZyA9IGZhbHNlO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3NQcmV2ID0gbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkpO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlUHJldiA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlO1xuICAgICgwLCBkZWVwQ29weU9iamVjdF8xLmRlZXBPYmplY3RNZXJnZSkodHJ1ZSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLCBtYWluXzEucGxheWVyW2ldLmhpdGJveGVzKTtcbiAgICBoaXRsYWdTd2l0Y2hVcGRhdGUoaSwgaW5wdXQpO1xuICAgIGh1cnRCb3hTdGF0ZVVwZGF0ZShpKTtcbiAgICBvdXRPZkNhbWVyYVVwZGF0ZShpKTtcbiAgICBsQ2FuY2VsVXBkYXRlKGksIGlucHV0KTtcbiAgICBpZiAoIW1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuYWlyYm9ybmVUaW1lcisrO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKHBsYXllcltpXS50aW1lcik7XG4gICAgbGV0IGZyYW1lID0gTWF0aC5mbG9vcihtYWluXzEucGxheWVyW2ldLnRpbWVyKTtcbiAgICBpZiAoZnJhbWUgPT09IDApIHtcbiAgICAgICAgZnJhbWUgPSAxO1xuICAgIH1cbiAgICBpZiAoZnJhbWUgPiBjaGFyYWN0ZXJzXzEuZnJhbWVzRGF0YVttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0pIHtcbiAgICAgICAgZnJhbWUgPSBjaGFyYWN0ZXJzXzEuZnJhbWVzRGF0YVttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV07XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coYWN0aW9uU3RhdGVzW2NoYXJhY3RlclNlbGVjdGlvbnNbaV1dW3BsYXllcltpXS5hY3Rpb25TdGF0ZV0ubmFtZStcIiBcIisoZnJhbWUtMSkpO1xuICAgIC8qIGdsb2JhbCBlY2IgKi9cbiAgICBsZXQgZWNiO1xuICAgIGNvbnN0IGVjYk9mZnNldCA9IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5kZWFkID8gWzAsIDAsIDAsIDBdIDogW2VjYlttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV1bZnJhbWUgLSAxXVswXSAqIG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMuZWNiU2NhbGUsIGVjYlttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV1bZnJhbWUgLSAxXVsxXSAqIG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMuZWNiU2NhbGUsIGVjYlttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV1bZnJhbWUgLSAxXVsyXSAqIG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMuZWNiU2NhbGUsIGVjYlttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV1bZnJhbWUgLSAxXVszXSAqIG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMuZWNiU2NhbGVdO1xuICAgIGNvbnN0IHBsYXllclBvc1ggPSBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLng7XG4gICAgY29uc3QgcGxheWVyUG9zWSA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueTtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCA9IFtcbiAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyAoKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCB8fCBtYWluXzEucGxheWVyW2ldLnBoeXMuYWlyYm9ybmVUaW1lciA8IDEwKSA/IDAgOiBlY2JPZmZzZXRbMF0pKSxcbiAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ICsgTWF0aC5tYXgoMSwgZWNiT2Zmc2V0WzFdKSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgZWNiT2Zmc2V0WzJdKSxcbiAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyBlY2JPZmZzZXRbM10pLFxuICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggLSBlY2JPZmZzZXRbMV0sIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIGVjYk9mZnNldFsyXSlcbiAgICBdO1xuICAgIGlmIChlY2JTcXVhc2hEYXRhW2ldICE9PSBudWxsICYmIGVjYlNxdWFzaERhdGFbaV0uZmFjdG9yIDwgMSkge1xuICAgICAgICBpZiAoZWNiU3F1YXNoRGF0YVtpXS5mYWN0b3IgKiAyICogZWNiT2Zmc2V0WzFdIDwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLnNtYWxsZXN0RUNCV2lkdGgpIHtcbiAgICAgICAgICAgIGVjYlNxdWFzaERhdGFbaV0uZmFjdG9yID0gKGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5zbWFsbGVzdEVDQldpZHRoICsgMiAqIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5hZGRpdGlvbmFsT2Zmc2V0KSAvICgyICogZWNiT2Zmc2V0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCA9ICgwLCBlY2JUcmFuc2Zvcm1fMS5zcXVhc2hFQ0JBdCkobWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnAsIHsgZmFjdG9yOiBlY2JTcXVhc2hEYXRhW2ldLmZhY3RvciwgbG9jYXRpb246IDAgfSk7XG4gICAgICAgIGlmICghbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCA9ICgwLCBlY2JUcmFuc2Zvcm1fMS5tb3ZlRUNCKShtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCwgbmV3IFZlYzJEXzEuVmVjMkQoMCwgKGVjYlNxdWFzaERhdGFbaV0uZmFjdG9yIC0gMSkgKiBlY2JPZmZzZXRbMF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5pZ25vcmVDb2xsaXNpb24pIHtcbiAgICAgICAgbGV0IG5vdFRvdWNoaW5nV2FsbHMgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgIGxldCBzdGlsbEdyb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGJhY2t3YXJkID0gZmFsc2U7XG4gICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZCwgbm90VG91Y2hpbmdXYWxsc10gPSBmaW5kQW5kUmVzb2x2ZUNvbGxpc2lvbnMoaSwgaW5wdXQsIGJhY2t3YXJkLCBub3RUb3VjaGluZ1dhbGxzLCBlY2JPZmZzZXQpO1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiZWRCeSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChub3RUb3VjaGluZ1dhbGxzWzBdICYmIG5vdFRvdWNoaW5nV2FsbHNbMV0gJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmNhbldhbGxKdW1wKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLndhbGxKdW1wVGltZXIgPSAyNTQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vdFRvdWNoaW5nV2FsbHNbMF0gfHwgIW5vdFRvdWNoaW5nV2FsbHNbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBtYWluXzEucGxheWVyW2ldLnBoeXMub25TdXJmYWNlWzFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdXJmYWNlID0gbWFpbl8xLnBsYXllcltpXS5waHlzLm9uU3VyZmFjZVswXSA/IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UucGxhdGZvcm1bc10gOiBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmdyb3VuZFtzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA8IHN1cmZhY2VbMF0ueCAtIDAuMSB8fCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggPiBzdXJmYWNlWzFdLnggKyAwLjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0aWxsR3JvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RpbGxHcm91bmRlZCkge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmFpcmJvcm5lU3RhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPSBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uYWlyYm9ybmVTdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0ubWlzc2Zvb3QgJiYgYmFja3dhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5NSVNTRk9PVC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJpbmcgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbbWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiaW5nXV0uRkFMTC5pbml0KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncmFiYmluZywgaW5wdXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbbWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiaW5nXS5waHlzLmdyYWJiZWRCeSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncmFiYmluZyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLkZBTEwuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLngpID4gbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5hZXJpYWxIbWF4Vikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCA9IE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54KSAqIG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMuYWVyaWFsSG1heFY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnNoaWVsZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyVHlwZVtqXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2pdLnBoeXMuZ3JvdW5kZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltqXS5waHlzLm9uU3VyZmFjZVswXSA9PT0gbWFpbl8xLnBsYXllcltpXS5waHlzLm9uU3VyZmFjZVswXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2pdLnBoeXMub25TdXJmYWNlWzFdID09PSBtYWluXzEucGxheWVyW2ldLnBoeXMub25TdXJmYWNlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJpbmcgIT09IGogJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiZWRCeSAhPT0gaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBwdXNoaW5nIGNvZGUgbmVlZHMgdG8gYWNjb3VudCBmb3IgcGxheWVycyBvbiBzbGFudGVkIHN1cmZhY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54IC0gbWFpbl8xLnBsYXllcltqXS5waHlzLnBvcy54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgNi41ICYmIGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltqXS5waHlzLnBvcy54ICs9IE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggLSBtYWluXzEucGxheWVyW2pdLnBoeXMucG9zLngpICogLTAuMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpZmYgPT09IDAgJiYgTWF0aC5hYnMobWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCkgPiBNYXRoLmFicyhtYWluXzEucGxheWVyW2pdLnBoeXMuY1ZlbC54KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbal0ucGh5cy5wb3MueCArPSBNYXRoLnNpZ24obWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCkgKiAtMC4zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyBwbGF5ZXIgaWdub3JpbmcgY29sbGlzaW9uc1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCMSA9IFtcbiAgICAgICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgKChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQgfHwgbWFpbl8xLnBsYXllcltpXS5waHlzLmFpcmJvcm5lVGltZXIgPCAxMCkgPyAwIDogZWNiT2Zmc2V0WzBdKSksXG4gICAgICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggKyBlY2JPZmZzZXRbMV0sIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIGVjYk9mZnNldFsyXSksXG4gICAgICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIGVjYk9mZnNldFszXSksXG4gICAgICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggLSBlY2JPZmZzZXRbMV0sIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIGVjYk9mZnNldFsyXSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5zaGllbGRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5zaGllbGRIUCArPSAwLjA3O1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnNoaWVsZEhQID4gNjApIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5zaGllbGRIUCA9IDYwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWxXaXRoTGVkZ2VzKGksIGlucHV0KTtcbiAgICBkZWFsV2l0aERlYXRoKGksIGlucHV0KTtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydGJveCA9IG5ldyBCb3gyRF8xLkJveDJEKFtwbGF5ZXJQb3NYIC0gbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5odXJ0Ym94T2Zmc2V0WzBdLCBwbGF5ZXJQb3NZICsgbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5odXJ0Ym94T2Zmc2V0WzFdXSwgW3BsYXllclBvc1ggKyBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLmh1cnRib3hPZmZzZXRbMF0sIHBsYXllclBvc1ldKTtcbiAgICBpZiAobWFpbl8xLmdhbWVNb2RlID09PSAzICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3NQcmV2LnkgPiAtODAgJiYgcGxheWVyUG9zWSA8PSAtODApIHtcbiAgICAgICAgc2Z4XzEuc291bmRzLmxvd2Rvd24ucGxheSgpO1xuICAgIH1cbiAgICB1cGRhdGVIaXRib3hlcyhpKTtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zRGVsdGEgPSBuZXcgVmVjMkRfMS5WZWMyRChNYXRoLmFicyhwbGF5ZXJQb3NYIC0gbWFpbl8xLnBsYXllcltpXS5waHlzLnBvc1ByZXYueCksIE1hdGguYWJzKHBsYXllclBvc1kgLSBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zUHJldi55KSk7XG4gICAgaWYgKG1haW5fMS5zaG93RGVidWcpIHtcbiAgICAgICAgY29uc3QgYWN0U3RhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0U3RhdGUnICsgaSk7XG4gICAgICAgIGNvbnN0IHN0YXRlTnVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXRlTnVtJyArIGkpO1xuICAgICAgICBjb25zdCBmYWNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZhY2UnICsgaSk7XG4gICAgICAgIGNvbnN0IHZlbG9jaXR5WCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmVsb2NpdHlYXCIgKyBpKTtcbiAgICAgICAgY29uc3QgdmVsb2NpdHlZID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ2ZWxvY2l0eVlcIiArIGkpO1xuICAgICAgICBjb25zdCBrdmVsb2NpdHlYID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJrdmVsb2NpdHlYXCIgKyBpKTtcbiAgICAgICAgY29uc3Qga3ZlbG9jaXR5WSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwia3ZlbG9jaXR5WVwiICsgaSk7XG4gICAgICAgIGNvbnN0IHB2ZWxvY2l0eVggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInB2ZWxvY2l0eVhcIiArIGkpO1xuICAgICAgICBjb25zdCBwdmVsb2NpdHlZID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwdmVsb2NpdHlZXCIgKyBpKTtcbiAgICAgICAgYWN0U3RhdGUuaW5uZXJIVE1MID0gbWFpbl8xLnBsYXllcltpXS5jdXJyZW50QWN0aW9uICsgXCIgXCIgKyBtYWluXzEucGxheWVyW2ldLmN1cnJlbnRTdWJhY3Rpb24gKyBcIiA6IFwiICsgbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZTtcbiAgICAgICAgc3RhdGVOdW0uaW5uZXJIVE1MID0gZnJhbWUudG9TdHJpbmcoKTtcbiAgICAgICAgZmFjZS5pbm5lckhUTUwgPSBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZTtcbiAgICAgICAgdmVsb2NpdHlYLmlubmVySFRNTCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLngudG9GaXhlZCg1KTtcbiAgICAgICAgdmVsb2NpdHlZLmlubmVySFRNTCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnkudG9GaXhlZCg1KTtcbiAgICAgICAga3ZlbG9jaXR5WC5pbm5lckhUTUwgPSBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54LnRvRml4ZWQoNSk7XG4gICAgICAgIGt2ZWxvY2l0eVkuaW5uZXJIVE1MID0gbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueS50b0ZpeGVkKDUpO1xuICAgICAgICBwdmVsb2NpdHlYLmlubmVySFRNTCA9IHBsYXllclBvc1gudG9GaXhlZCg1KTtcbiAgICAgICAgcHZlbG9jaXR5WS5pbm5lckhUTUwgPSBwbGF5ZXJQb3NZLnRvRml4ZWQoNSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/physics/physics.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("1485a7197fd21fb9a503")
/******/ })();
/******/ 
/******/ }
);