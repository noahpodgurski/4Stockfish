"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatemeleelight"]("main",{

/***/ "./src/physics/physics.ts":
/*!********************************!*\
  !*** ./src/physics/physics.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n//@flow\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.land = land;\nexports.physics = physics;\nconst main_1 = __webpack_require__(/*! ../main/main */ \"./src/main/main.ts\");\nconst characters_1 = __webpack_require__(/*! ../main/characters */ \"./src/main/characters.ts\");\nconst sfx_1 = __webpack_require__(/*! ../main/sfx */ \"./src/main/sfx.ts\");\nconst settings_1 = __webpack_require__(/*! ../settings */ \"./src/settings.ts\");\nconst actionStateShortcuts_1 = __webpack_require__(/*! ./actionStateShortcuts */ \"./src/physics/actionStateShortcuts.ts\");\nconst hitDetection_1 = __webpack_require__(/*! ./hitDetection */ \"./src/physics/hitDetection.ts\");\nconst render_1 = __webpack_require__(/*! ../main/render */ \"./src/main/render.ts\");\nconst environmentalCollision_1 = __webpack_require__(/*! ./environmentalCollision */ \"./src/physics/environmentalCollision.ts\");\nconst deepCopyObject_1 = __webpack_require__(/*! ../main/util/deepCopyObject */ \"./src/main/util/deepCopyObject.ts\");\nconst drawVfx_1 = __webpack_require__(/*! ../main/vfx/drawVfx */ \"./src/main/vfx/drawVfx.js\");\nconst stage_1 = __webpack_require__(/*! ../stages/stage */ \"./src/stages/stage.ts\");\nconst activeStage_1 = __webpack_require__(/*! ../stages/activeStage */ \"./src/stages/activeStage.ts\");\nconst Box2D_1 = __webpack_require__(/*! ../main/util/Box2D */ \"./src/main/util/Box2D.ts\");\nconst Vec2D_1 = __webpack_require__(/*! ../main/util/Vec2D */ \"./src/main/util/Vec2D.ts\");\nconst toList_1 = __webpack_require__(/*! ../main/util/toList */ \"./src/main/util/toList.ts\");\nconst extremePoint_1 = __webpack_require__(/*! ../stages/util/extremePoint */ \"./src/stages/util/extremePoint.ts\");\nconst ecbTransform_1 = __webpack_require__(/*! ../main/util/ecbTransform */ \"./src/main/util/ecbTransform.ts\");\nconst linAlg_1 = __webpack_require__(/*! ../main/linAlg */ \"./src/main/linAlg.ts\");\nfunction updatePosition(i, newPosition) {\n    main_1.player[i].phys.pos = newPosition;\n}\n;\nfunction dealWithDamagingStageCollision(i, normal, corner, angular, damageType) {\n    const collisionData = { normal: normal, angular: angular, corner: corner };\n    let damageTypeIndex = -1;\n    switch (damageType) {\n        case \"fire\":\n            damageTypeIndex = 3;\n            break;\n        case \"electric\":\n            damageTypeIndex = 4;\n            break;\n        case \"slash\":\n            damageTypeIndex = 1;\n            break;\n        case \"darkness\":\n            damageTypeIndex = 5;\n            break;\n        default:\n            break;\n    }\n    if (damageTypeIndex !== -1) {\n        hitDetection_1.hitQueue.push([i, collisionData, damageTypeIndex, false, false, true]);\n    }\n}\nfunction dealWithWallCollision(i, newPosition, pt, wallType, wallIndex, input) {\n    updatePosition(i, newPosition);\n    let wallLabel = \"L\";\n    let sign = -1;\n    let isRight = 0;\n    if (wallType[0].toLowerCase() === \"r\") {\n        wallLabel = \"R\";\n        sign = 1;\n        isRight = 1;\n    }\n    const wall = (0, stage_1.getSurfaceFromStage)([wallType, wallIndex], activeStage_1.activeStage);\n    const wallBottom = (0, extremePoint_1.extremePoint)(wall, \"b\");\n    const wallTop = (0, extremePoint_1.extremePoint)(wall, \"t\");\n    const wallNormal = (0, environmentalCollision_1.outwardsWallNormal)(wallBottom, wallTop, wallType);\n    const damageType = wall[2] === undefined ? null : wall[2].damageType;\n    const inDamageState = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"WALLDAMAGE\" || main_1.player[i].actionState === \"DAMAGEFALL\";\n    if (inDamageState && main_1.player[i].phys.techTimer > 0) {\n        main_1.player[i].phys.face = sign;\n        if (input[i][0].x || input[i][0].y || input[i][0].lsY > 0.7) {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLTECHJUMP.init(i, input);\n        }\n        else {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLTECH.init(i, input);\n        }\n    }\n    else if (inDamageState && Math.sign(main_1.player[i].phys.kVel) !== sign && main_1.player[i].hit.hitlag === 0 && Math.pow(main_1.player[i].phys.kVel.x, 2) + Math.pow(main_1.player[i].phys.kVel.y, 2) >= 2.25) {\n        main_1.player[i].phys.face = sign;\n        (0, drawVfx_1.drawVfx)({\n            name: \"wallBounce\",\n            pos: new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.ECBp[1].y),\n            face: sign,\n            f: wallNormal\n        });\n        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLDAMAGE.init(i, input, wallNormal);\n    }\n    else if (main_1.player[i].hit.hitlag === 0) {\n        if (damageType !== undefined && damageType !== null\n            && main_1.player[i].phys.hurtBoxState === 0) {\n            // apply damage\n            dealWithDamagingStageCollision(i, wallNormal, false, pt, damageType);\n        }\n        else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].specialWallCollide) {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].onWallCollide(i, input, wallLabel, wallIndex);\n        }\n        else if (main_1.player[i].phys.canWallJump) {\n            if (main_1.player[i].phys.wallJumpTimer === 254) {\n                if (main_1.player[i].phys.posDelta.x >= 0.5) {\n                    main_1.player[i].phys.wallJumpTimer = 0;\n                }\n            }\n        }\n        if (main_1.player[i].phys.wallJumpTimer >= 0 && main_1.player[i].phys.wallJumpTimer < 120) {\n            if (sign * input[i][0].lsX >= 0.7 &&\n                sign * input[i][3].lsX <= 0 &&\n                main_1.player[i].charAttributes.walljump) {\n                main_1.player[i].phys.wallJumpTimer = 254;\n                main_1.player[i].phys.face = sign;\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WALLJUMP.init(i, input);\n            }\n            else {\n                main_1.player[i].phys.wallJumpTimer++;\n            }\n        }\n    }\n}\n;\nfunction dealWithPlatformCollision(i, alreadyGrounded, newPosition, ecbpBottom, platformIndex, input) {\n    const platform = (0, stage_1.getSurfaceFromStage)([\"p\", platformIndex], activeStage_1.activeStage);\n    const damageType = platform[2] === undefined ? null : platform[2].damageType;\n    const platLeft = (0, extremePoint_1.extremePoint)(platform, \"l\");\n    const platRight = (0, extremePoint_1.extremePoint)(platform, \"r\");\n    const platNormal = (0, environmentalCollision_1.outwardsWallNormal)(platLeft, platRight, \"g\");\n    if (main_1.player[i].hit.hitlag > 0 || alreadyGrounded || main_1.player[i].phys.grabbedBy !== -1) {\n        updatePosition(i, newPosition);\n    }\n    else {\n        land(i, ecbpBottom, 1, platformIndex, platNormal, input);\n    }\n}\n;\nfunction dealWithGroundCollision(i, alreadyGrounded, newPosition, ecbpBottom, groundIndex, input) {\n    const ground = (0, stage_1.getSurfaceFromStage)([\"g\", groundIndex], activeStage_1.activeStage);\n    const damageType = ground[2] === undefined ? null : ground[2].damageType;\n    const ignoreDamage = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"DAMAGEFALL\" || main_1.player[i].actionState === \"WALLDAMAGE\";\n    const groundLeft = (0, extremePoint_1.extremePoint)(ground, \"l\");\n    const groundRight = (0, extremePoint_1.extremePoint)(ground, \"r\");\n    const groundNormal = (0, environmentalCollision_1.outwardsWallNormal)(groundLeft, groundRight, \"g\");\n    if (!ignoreDamage && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        // apply damage\n        dealWithDamagingStageCollision(i, groundNormal, false, 0, damageType);\n    }\n    else {\n        if (main_1.player[i].hit.hitlag > 0 || alreadyGrounded || main_1.player[i].phys.grabbedBy !== -1) {\n            updatePosition(i, newPosition);\n        }\n        else {\n            land(i, ecbpBottom, 0, groundIndex, groundNormal, input);\n        }\n    }\n}\n;\nfunction fallOffGround(i, side, groundEdgePosition, disableFall, input) {\n    let [stillGrounded, backward] = [true, false];\n    let sign = 1;\n    if (side === \"r\") {\n        sign = -1;\n    }\n    if (disableFall) {\n        main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n        main_1.player[i].phys.pos.x = groundEdgePosition.x + (side === \"l\" ? environmentalCollision_1.additionalOffset : -environmentalCollision_1.additionalOffset);\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, (0, linAlg_1.subtract)(main_1.player[i].phys.pos, main_1.player[i].phys.ECBp[0]));\n    }\n    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canEdgeCancel) {\n        if (main_1.player[i].phys.face === sign) {\n            stillGrounded = false;\n            main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n            backward = true;\n        }\n        else if (Math.abs(input[i][0].lsX) > 0.6\n            || (main_1.player[i].phys.cVel.x === 0 && main_1.player[i].phys.kVel.x === 0)\n            || actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].disableTeeter\n            || main_1.player[i].phys.shielding) {\n            stillGrounded = false;\n            main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n        }\n        else {\n            main_1.player[i].phys.cVel.x = 0;\n            main_1.player[i].phys.pos.x = groundEdgePosition.x + sign * environmentalCollision_1.additionalOffset;\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].OTTOTTO.init(i, input);\n        }\n    }\n    else if (main_1.player[i].phys.cVel.x === 0\n        && main_1.player[i].phys.kVel.x === 0\n        && !actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].inGrab) {\n        stillGrounded = false;\n        main_1.player[i].phys.pos.y = Math.max(main_1.player[i].phys.pos.y, groundEdgePosition.y) + environmentalCollision_1.additionalOffset;\n    }\n    else {\n        main_1.player[i].phys.cVel.x = 0;\n        main_1.player[i].phys.pos.x = groundEdgePosition.x + sign * environmentalCollision_1.additionalOffset;\n    }\n    return [stillGrounded, backward];\n}\n;\n// ground type and index is a pair, either [\"g\", index] or [\"p\", index]\nfunction dealWithGround(i, ground, groundTypeAndIndex, connected, input) {\n    const damageType = ground[2] === undefined ? null : ground[2].damageType;\n    const ignoreDamage = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"DAMAGEFALL\" || main_1.player[i].actionState === \"WALLDAMAGE\";\n    const leftmostGroundPoint = (0, extremePoint_1.extremePoint)(ground, \"l\");\n    const rightmostGroundPoint = (0, extremePoint_1.extremePoint)(ground, \"r\");\n    const groundNormal = (0, environmentalCollision_1.outwardsWallNormal)(leftmostGroundPoint, rightmostGroundPoint, \"g\");\n    let [stillGrounded, backward] = [true, false];\n    let groundOrPlatform = 0;\n    if (groundTypeAndIndex[0] === \"p\") {\n        groundOrPlatform = 1;\n    }\n    let disableFall = false;\n    let maybeLeftGroundTypeAndIndex = null;\n    let maybeRightGroundTypeAndIndex = null;\n    // first check if the player is allowed to move along the ground, by checking there are no low ceilings\n    const ecb0Height = Math.max(environmentalCollision_1.additionalOffset, main_1.player[i].phys.ECB1[2].y - main_1.player[i].phys.ECB1[0].y - environmentalCollision_1.additionalOffset);\n    const maybeNextPosX = (0, environmentalCollision_1.moveAlongGround)(main_1.player[i].phys.ECB1[0], main_1.player[i].phys.ECBp[0], ecb0Height, ground, activeStage_1.activeStage.ceiling);\n    if (maybeNextPosX !== null) {\n        // ceiling has obstructed grounded movement\n        main_1.player[i].phys.pos.x = maybeNextPosX;\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, new Vec2D_1.Vec2D(maybeNextPosX - main_1.player[i].phys.ECBp[0].x, 0));\n    }\n    if (main_1.player[i].phys.ECBp[0].x < leftmostGroundPoint.x) {\n        if (connected !== null && connected !== undefined) {\n            maybeLeftGroundTypeAndIndex = groundTypeAndIndex[0] === \"g\"\n                ? connected[0][groundTypeAndIndex[1]][0]\n                : connected[1][groundTypeAndIndex[1]][0];\n        }\n        if (maybeLeftGroundTypeAndIndex === null || maybeLeftGroundTypeAndIndex === undefined) { // no other ground to the left\n            [stillGrounded, backward] = fallOffGround(i, \"l\", leftmostGroundPoint, disableFall, input);\n        }\n        else {\n            const [leftGroundType, leftGroundIndex] = maybeLeftGroundTypeAndIndex;\n            switch (leftGroundType) {\n                case \"g\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.ground[leftGroundIndex], [\"g\", leftGroundIndex], connected, input);\n                    break;\n                case \"p\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.platform[leftGroundIndex], [\"p\", leftGroundIndex], connected, input);\n                    break;\n                case \"r\":\n                    const rightWallToTheLeft = activeStage_1.activeStage.wallR[leftGroundIndex];\n                    if ((0, extremePoint_1.extremePoint)(rightWallToTheLeft, \"l\").y > leftmostGroundPoint.y) {\n                        disableFall = true;\n                    }\n                    [stillGrounded, backward] = fallOffGround(i, \"l\", leftmostGroundPoint, disableFall, input);\n                    break;\n                default: // surface to the left is neither ground, platform or right wall\n                    [stillGrounded, backward] = fallOffGround(i, \"l\", leftmostGroundPoint, disableFall, input);\n                    break;\n            }\n        }\n    }\n    else if (main_1.player[i].phys.ECBp[0].x > rightmostGroundPoint.x) {\n        if (connected !== null && connected !== undefined) {\n            maybeRightGroundTypeAndIndex = groundTypeAndIndex[0] === \"g\"\n                ? connected[0][groundTypeAndIndex[1]][1]\n                : connected[1][groundTypeAndIndex[1]][1];\n        }\n        if (maybeRightGroundTypeAndIndex === null || maybeRightGroundTypeAndIndex === undefined) { // no other ground to the right\n            [stillGrounded, backward] = fallOffGround(i, \"r\", rightmostGroundPoint, disableFall, input);\n        }\n        else {\n            const [rightGroundType, rightGroundIndex] = maybeRightGroundTypeAndIndex;\n            switch (rightGroundType) {\n                case \"g\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.ground[rightGroundIndex], [\"g\", rightGroundIndex], connected, input);\n                    break;\n                case \"p\":\n                    [stillGrounded, backward] = dealWithGround(i, activeStage_1.activeStage.platform[rightGroundIndex], [\"p\", rightGroundIndex], connected, input);\n                    break;\n                case \"l\":\n                    const leftWallToTheRight = activeStage_1.activeStage.wallL[rightGroundIndex];\n                    if ((0, extremePoint_1.extremePoint)(leftWallToTheRight, \"r\").y > rightmostGroundPoint.y) {\n                        disableFall = true;\n                    }\n                    [stillGrounded, backward] = fallOffGround(i, \"r\", rightmostGroundPoint, disableFall, input);\n                    break;\n                default: // surface to the right is neither ground, platform or left wall\n                    [stillGrounded, backward] = fallOffGround(i, \"r\", rightmostGroundPoint, disableFall, input);\n                    break;\n            }\n        }\n    }\n    else {\n        const ecbpBottom = main_1.player[i].phys.ECBp[0];\n        const yIntercept = (0, environmentalCollision_1.coordinateIntercept)([ecbpBottom, new Vec2D_1.Vec2D(ecbpBottom.x, ecbpBottom.y + 1)], ground);\n        main_1.player[i].phys.pos.y = main_1.player[i].phys.pos.y + yIntercept.y - ecbpBottom.y + environmentalCollision_1.additionalOffset;\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, new Vec2D_1.Vec2D(0, yIntercept.y - ecbpBottom.y + environmentalCollision_1.additionalOffset));\n        main_1.player[i].phys.onSurface = [groundOrPlatform, groundTypeAndIndex[1]];\n        main_1.player[i].phys.groundAngle = Math.atan2(groundNormal.y, groundNormal.x) || Math.PI / 2;\n    }\n    if (!ignoreDamage && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        // apply damage\n        dealWithDamagingStageCollision(i, groundNormal, false, 0, damageType);\n        stillGrounded = false;\n    }\n    return [stillGrounded, backward];\n}\n;\nfunction dealWithCeilingCollision(i, newPosition, ecbTop, ceilingIndex, input) {\n    updatePosition(i, newPosition);\n    const ceiling = (0, stage_1.getSurfaceFromStage)([\"c\", ceilingIndex], activeStage_1.activeStage);\n    const damageType = ceiling[2] === undefined ? null : ceiling[2].damageType;\n    const ceilingLeft = (0, extremePoint_1.extremePoint)(ceiling, \"l\");\n    const ceilingRight = (0, extremePoint_1.extremePoint)(ceiling, \"r\");\n    const ceilingNormal = (0, environmentalCollision_1.outwardsWallNormal)(ceilingLeft, ceilingRight, \"c\");\n    const ignoreDamage = main_1.player[i].actionState === \"DAMAGEFLYN\" || main_1.player[i].actionState === \"DAMAGEFALL\" || main_1.player[i].actionState === \"WALLDAMAGE\";\n    if (!ignoreDamage && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        // apply damage\n        dealWithDamagingStageCollision(i, ceilingNormal, false, 2, damageType);\n    }\n    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].headBonk && main_1.player[i].phys.cVel.y + main_1.player[i].phys.kVel.y > 0) {\n        if (main_1.player[i].hit.hitstun > 0) {\n            if (main_1.player[i].phys.techTimer > 0) {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHU.init(i, input);\n            }\n            else {\n                (0, drawVfx_1.drawVfx)({\n                    name: \"ceilingBounce\",\n                    pos: ecbTop,\n                    face: 1,\n                    f: ceilingNormal\n                });\n                sfx_1.sounds.bounce.play();\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].STOPCEIL.init(i, input, ceilingNormal);\n            }\n        }\n        else {\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].STOPCEIL.init(i, input);\n        }\n    }\n}\n;\nfunction dealWithCornerCollision(i, newPosition, ecb, angularParameter, damageType) {\n    updatePosition(i, newPosition);\n    const insideECBType = angularParameter < 2 ? \"l\" : \"r\";\n    const [same, other] = (0, environmentalCollision_1.getSameAndOther)(angularParameter);\n    const lowerECBPoint = other === 2 ? ecb[same] : ecb[0];\n    const upperECBPoint = other === 2 ? ecb[2] : ecb[same];\n    const normal = (0, environmentalCollision_1.outwardsWallNormal)(lowerECBPoint, upperECBPoint, insideECBType);\n    if (main_1.player[i].hit.hitlag === 0 && damageType !== undefined && damageType !== null\n        && main_1.player[i].phys.hurtBoxState === 0) {\n        dealWithDamagingStageCollision(i, normal, true, angularParameter, damageType);\n    }\n}\n;\nfunction land(i, newPosition, t, j, normal, input) {\n    main_1.player[i].phys.pos = newPosition;\n    main_1.player[i].phys.grounded = true;\n    main_1.player[i].phys.doubleJumped = false;\n    main_1.player[i].phys.jumpsUsed = 0;\n    main_1.player[i].phys.airborneTimer = 0;\n    main_1.player[i].phys.fastfalled = false;\n    main_1.player[i].phys.chargeFrames = 0;\n    main_1.player[i].phys.charging = false;\n    main_1.player[i].phys.wallJumpCount = 0;\n    main_1.player[i].phys.thrownHitbox = false;\n    main_1.player[i].phys.sideBJumpFlag = true;\n    main_1.player[i].phys.onSurface = [t, j];\n    main_1.player[i].phys.onLedge = -1;\n    main_1.player[i].rotation = 0;\n    main_1.player[i].rotationPoint = new Vec2D_1.Vec2D(0, 0);\n    main_1.player[i].colourOverlayBoolean = false;\n    main_1.player[i].hitboxes.active = [false, false, false, false];\n    let newNormal = normal;\n    if (newNormal === null || newNormal === undefined || (newNormal.x === 0 && newNormal.y === 0)) {\n        newNormal = new Vec2D_1.Vec2D(0, 1);\n    }\n    main_1.player[i].phys.groundAngle = Math.atan2(newNormal.y, newNormal.x);\n    switch (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].landType) {\n        case 0:\n            // LANDING / NIL\n            if (main_1.player[i].phys.cVel.y >= -1) {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].WAIT.init(i, input);\n            }\n            else {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].LANDING.init(i, input);\n            }\n            break;\n        case 1:\n            // OWN FUNCTION\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].land(i, input);\n            break;\n        case 2:\n            // KNOCKDOWN / TECH\n            if (main_1.player[i].phys.techTimer > 0) {\n                if (input[i][0].lsX * main_1.player[i].phys.face > 0.5) {\n                    actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHF.init(i, input);\n                }\n                else if (input[i][0].lsX * main_1.player[i].phys.face < -0.5) {\n                    actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHB.init(i, input);\n                }\n                else {\n                    actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].TECHN.init(i, input);\n                }\n            }\n            else {\n                actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].DOWNBOUND.init(i, input);\n            }\n            break;\n        default:\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].LANDING.init(i, input);\n            break;\n    }\n    main_1.player[i].phys.cVel.y = 0;\n    main_1.player[i].phys.kVel.y = 0;\n    main_1.player[i].hit.hitstun = 0;\n}\n;\nfunction hitlagSwitchUpdate(i, input) {\n    if (main_1.player[i].hit.hitlag > 0) {\n        main_1.player[i].hit.hitlag--;\n        if (main_1.player[i].hit.hitlag === 0 && main_1.player[i].hit.knockback > 0) {\n            if (main_1.player[i].phys.grabbedBy === -1 || main_1.player[i].hit.knockback > 50) {\n                const newAngle = (0, hitDetection_1.getLaunchAngle)(main_1.player[i].hit.angle, main_1.player[i].hit.knockback, main_1.player[i].hit.reverse, input[i][0].lsX, input[i][0].lsY, i);\n                main_1.player[i].phys.cVel.x = 0;\n                main_1.player[i].phys.cVel.y = 0;\n                //console.log(newAngle);\n                main_1.player[i].phys.kVel.x = (0, hitDetection_1.getHorizontalVelocity)(main_1.player[i].hit.knockback, newAngle);\n                main_1.player[i].phys.kVel.y = (0, hitDetection_1.getVerticalVelocity)(main_1.player[i].hit.knockback, newAngle, main_1.player[i].phys.grounded, main_1.player[i].hit.angle);\n                //console.log(player[i].phys.kVel);\n                main_1.player[i].phys.kDec.x = (0, hitDetection_1.getHorizontalDecay)(newAngle);\n                main_1.player[i].phys.kDec.y = (0, hitDetection_1.getVerticalDecay)(newAngle);\n                //console.log(player[i].phys.kDec);\n                //player[i].hit.hitstun = getHitstun(player[i].hit.knockback);\n                main_1.player[i].phys.onLedge = -1;\n                main_1.player[i].phys.charging = false;\n                main_1.player[i].phys.chargeFrames = 0;\n                main_1.player[i].phys.shielding = false;\n                /*if (player[i].phys.grounded){\n                 if (newAngle == 0 || newAngle > 270){\n                 player[i].phys.kVel.y = 0;\n                 player[i].phys.kDec.x = player[i].charAttributes.traction;\n                 }\n                 else if (newAngle > 180){\n                 player[i].phys.kVel.y = 0;\n                 player[i].phys.kDec.x = -player[i].charAttributes.traction;\n                 }\n                 }*/\n                if (main_1.player[i].phys.kVel.y === 0) {\n                    if (main_1.player[i].hit.knockback >= 80) {\n                        main_1.player[i].phys.grounded = false;\n                        main_1.player[i].phys.pos.y += 0.0001;\n                    }\n                }\n                if (main_1.player[i].phys.kVel.y > 0) {\n                    main_1.player[i].phys.grounded = false;\n                }\n            }\n            main_1.player[i].hit.knockback = 0;\n        }\n        //SDI / ASDI\n        switch (main_1.player[i].actionState) {\n            case \"DAMAGEN2\":\n            case \"DAMAGEFLYN\":\n            case \"GUARDON\":\n            case \"GUARD\":\n            case \"DOWNDAMAGE\":\n                if (main_1.player[i].hit.hitlag > 0) {\n                    if ((input[i][0].lsX > 0.7 && input[i][1].lsX < 0.7) ||\n                        (input[i][0].lsX < -0.7 && input[i][1].lsX > -0.7) ||\n                        (input[i][0].lsY > 0.7 && input[i][1].lsY < 0.7) ||\n                        (input[i][0].lsY < -0.7 && input[i][1].lsY > -0.7)) {\n                        if (!((input[i][0].lsX * input[i][0].lsX) + (input[i][0].lsY * input[i][0].lsY) < (0.49))) {\n                            main_1.player[i].phys.pos.x += input[i][0].lsX * 6;\n                            main_1.player[i].phys.pos.y += main_1.player[i].phys.grounded ? 0 : input[i][0].lsY * 6;\n                        }\n                    }\n                }\n                else {\n                    main_1.player[i].phys.pos.x += input[i][0].lsX * 3;\n                    main_1.player[i].phys.pos.y += main_1.player[i].phys.grounded ? 0 : input[i][0].lsY * 3;\n                }\n                break;\n            default:\n                break;\n        }\n        if (main_1.player[i].hit.hitlag === 0) {\n            // if hitlag just ended, do normal stuff as well\n            hitlagSwitchUpdate(i, input);\n        }\n    }\n    else {\n        if (main_1.player[i].hit.shieldstun > 0) {\n            //console.log(player[i].hit.shieldstun);\n            main_1.player[i].hit.shieldstun--;\n            if (main_1.player[i].hit.shieldstun < 0) {\n                main_1.player[i].hit.shieldstun = 0;\n            }\n        }\n        //console.log(actionStates[characterSelections[i]][player[i].actionState]);\n        main_1.player[i].phys.canWallJump = actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].wallJumpAble;\n        main_1.player[i].phys.bTurnaroundTimer--;\n        if (main_1.player[i].phys.bTurnaroundTimer < 0) {\n            main_1.player[i].phys.bTurnaroundTimer = 0;\n        }\n        if ((input[i][0].lsX > 0.9 && input[i][1].lsX < 0.9) ||\n            (input[i][0].lsX < -0.9 && input[i][1].lsX > -0.9)) {\n            main_1.player[i].phys.bTurnaroundTimer = 20;\n            main_1.player[i].phys.bTurnaroundDirection = Math.sign(input[i][0].lsX);\n        }\n        main_1.player[i].prevActionState = main_1.player[i].actionState;\n        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].main(i, input);\n        if (main_1.player[i].shocked > 0) {\n            main_1.player[i].shocked--;\n            if (main_1.player[i].shocked % 5 === 0) {\n                sfx_1.sounds.electricfizz.play();\n            }\n            (0, drawVfx_1.drawVfx)({\n                name: \"shocked\",\n                pos: new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + 5),\n                face: main_1.player[i].phys.face\n            });\n        }\n        if (main_1.player[i].burning > 0) {\n            main_1.player[i].burning--;\n            if (main_1.player[i].burning % 6 === 0) {\n                (0, drawVfx_1.drawVfx)({\n                    name: \"burning\",\n                    pos: new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + 5),\n                    face: main_1.player[i].phys.face\n                });\n            }\n        }\n        // TURBO MODE\n        // if just changed action states, remove ability to cancel\n        if (main_1.player[i].prevActionState !== main_1.player[i].actionState) {\n            main_1.player[i].hasHit = false;\n        }\n        if (settings_1.gameSettings.turbo && main_1.gameMode !== 5) {\n            if (main_1.player[i].hasHit) {\n                if (main_1.player[i].actionState !== \"CATCHATTACK\") {\n                    if (main_1.player[i].phys.grounded) {\n                        if ((0, actionStateShortcuts_1.turboGroundedInterrupt)(i, input)) {\n                            main_1.player[i].hasHit = false;\n                        }\n                    }\n                    else {\n                        if ((0, actionStateShortcuts_1.turboAirborneInterrupt)(i, input)) {\n                            main_1.player[i].hasHit = false;\n                        }\n                    }\n                }\n            }\n        }\n        if (Math.abs(main_1.player[i].phys.kVel.x) > 0) {\n            const oSign = Math.sign(main_1.player[i].phys.kVel.x);\n            if (main_1.player[i].phys.grounded) {\n                main_1.player[i].phys.kVel.x -= oSign * main_1.player[i].charAttributes.traction;\n            }\n            else {\n                main_1.player[i].phys.kVel.x -= main_1.player[i].phys.kDec.x;\n            }\n            if (oSign !== Math.sign(main_1.player[i].phys.kVel.x)) {\n                main_1.player[i].phys.kVel.x = 0;\n            }\n        }\n        if (Math.abs(main_1.player[i].phys.kVel.y) > 0) {\n            const oSign = Math.sign(main_1.player[i].phys.kVel.y);\n            if (main_1.player[i].phys.grounded) {\n                main_1.player[i].phys.kVel.y = 0;\n            }\n            main_1.player[i].phys.kVel.y -= main_1.player[i].phys.kDec.y;\n            if (oSign !== Math.sign(main_1.player[i].phys.kVel.y)) {\n                main_1.player[i].phys.kVel.y = 0;\n            }\n        }\n        main_1.player[i].phys.pos.x += main_1.player[i].phys.cVel.x + main_1.player[i].phys.kVel.x;\n        main_1.player[i].phys.pos.y += main_1.player[i].phys.cVel.y + main_1.player[i].phys.kVel.y;\n    }\n}\n;\nfunction hurtBoxStateUpdate(i) {\n    if (main_1.player[i].actionState === \"REBIRTH\" || main_1.player[i].actionState === \"REBIRTHWAIT\") {\n        main_1.player[i].phys.hurtBoxState = 1;\n    }\n    else {\n        main_1.player[i].phys.hurtBoxState = 0;\n    }\n    if (main_1.player[i].phys.invincibleTimer > 0) {\n        main_1.player[i].phys.invincibleTimer--;\n        main_1.player[i].phys.hurtBoxState = 2;\n    }\n    if (main_1.player[i].phys.intangibleTimer > 0) {\n        main_1.player[i].phys.intangibleTimer--;\n        main_1.player[i].phys.hurtBoxState = 1;\n    }\n}\n;\nfunction outOfCameraUpdate(i) {\n    if (main_1.player[i].phys.outOfCameraTimer >= 60) {\n        if (main_1.player[i].percent < 150) {\n            main_1.player[i].percent++;\n        }\n        (0, main_1.percentShake)(40, i);\n        sfx_1.sounds.outofcamera.play();\n        main_1.player[i].phys.outOfCameraTimer = 0;\n    }\n}\n;\nfunction lCancelUpdate(i, input) {\n    // if smash 64 lcancel, put any landingattackair action states into landing\n    if (settings_1.gameSettings.lCancelType === 2 && main_1.gameMode !== 5) {\n        if (main_1.player[i].phys.lCancel) {\n            if (main_1.player[i].actionState.substr(0, 16) === \"LANDINGATTACKAIR\") {\n                main_1.player[i].actionState = \"LANDING\";\n                main_1.player[i].timer = 1;\n            }\n        }\n    }\n    if (main_1.player[i].phys.lCancelTimer > 0) {\n        main_1.player[i].phys.lCancelTimer--;\n        if (main_1.player[i].phys.lCancelTimer === 0) {\n            main_1.player[i].phys.lCancel = false;\n        }\n    }\n    // l CANCEL\n    if (main_1.player[i].phys.lCancelTimer === 0 &&\n        ((input[i][0].lA > 0 && input[i][1].lA === 0) ||\n            (input[i][0].rA > 0 && input[i][1].rA === 0) ||\n            (input[i][0].z && !input[i][1].z))) {\n        // if smash 64 lcancel, increase window to 11 frames\n        if (settings_1.gameSettings.lCancelType === 2 && main_1.gameMode !== 5) {\n            main_1.player[i].phys.lCancelTimer = 11;\n        }\n        else {\n            main_1.player[i].phys.lCancelTimer = 7;\n        }\n        main_1.player[i].phys.lCancel = true;\n    }\n    // if auto lcancel is on, always lcancel\n    if (settings_1.gameSettings.lCancelType === 1 && main_1.gameMode !== 5) {\n        main_1.player[i].phys.lCancel = true;\n    }\n    // V Cancel\n    if (main_1.player[i].phys.vCancelTimer > 0) {\n        main_1.player[i].phys.vCancelTimer--;\n    }\n    if (main_1.player[i].phys.techTimer > 0) {\n        main_1.player[i].phys.techTimer--;\n    }\n    if (main_1.player[i].phys.shoulderLockout > 0) {\n        main_1.player[i].phys.shoulderLockout--;\n    }\n    if ((input[i][0].l && !input[i][1].l) ||\n        (input[i][0].r && !input[i][1].r)) {\n        if (!main_1.player[i].phys.grounded) {\n            if (main_1.player[i].phys.shoulderLockout === 0) {\n                main_1.player[i].phys.vCancelTimer = 3;\n                main_1.player[i].phys.techTimer = 20;\n            }\n        }\n        main_1.player[i].phys.shoulderLockout = 40;\n    }\n}\n;\nconst nullSquashDatum = { location: null, factor: 1 };\nconst ecbSquashData = [nullSquashDatum,\n    nullSquashDatum,\n    nullSquashDatum,\n    nullSquashDatum];\nfunction findAndResolveCollisions(i, input, oldBackward, oldNotTouchingWalls, ecbOffset) {\n    let stillGrounded = true;\n    let backward = oldBackward;\n    const notTouchingWalls = oldNotTouchingWalls;\n    const connected = activeStage_1.activeStage.connected;\n    // ------------------------------------------------------------------------------------------------------\n    // grounded state movement\n    if (main_1.player[i].phys.grounded) {\n        const oldPosition = new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y);\n        const relevantGroundIndex = main_1.player[i].phys.onSurface[1];\n        let relevantGroundType = \"g\";\n        let relevantGround = activeStage_1.activeStage.ground[relevantGroundIndex];\n        if (main_1.player[i].phys.onSurface[0] === 1) {\n            relevantGroundType = \"p\";\n            relevantGround = activeStage_1.activeStage.platform[relevantGroundIndex];\n        }\n        const relevantGroundTypeAndIndex = [relevantGroundType, relevantGroundIndex];\n        [stillGrounded, backward] = dealWithGround(i, relevantGround, relevantGroundTypeAndIndex, connected, input);\n    }\n    // end of grounded state movement\n    // ------------------------------------------------------------------------------------------------------\n    // ------------------------------------------------------------------------------------------------------\n    // main collision detection routine\n    const notIgnoringPlatforms = ((!actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canPassThrough || (input[i][0].lsY > -0.56)) && !main_1.player[i].phys.passing);\n    const isImmune = main_1.player[i].phys.hurtBoxState !== 0;\n    const playerStatusInfo = {\n        ignoringPlatforms: !notIgnoringPlatforms,\n        grounded: main_1.player[i].phys.grounded,\n        immune: isImmune\n    };\n    // type CollisionRoutineResult = { position : Vec2D, touching : null | SimpleTouchingDatum, squashDatum : SquashDatum, ecb : ECB};\n    const collisionData = (0, environmentalCollision_1.runCollisionRoutine)(main_1.player[i].phys.ECB1, main_1.player[i].phys.ECBp, main_1.player[i].phys.pos, ecbSquashData[i], playerStatusInfo, activeStage_1.activeStage);\n    ecbSquashData[i] = collisionData.squashDatum;\n    const newPosition = collisionData.position;\n    const newECB = collisionData.ecb;\n    const touchingDatum = collisionData.touching;\n    if (touchingDatum === null) {\n        updatePosition(i, newPosition);\n    }\n    else if (touchingDatum.kind === \"surface\") {\n        const surfaceLabel = touchingDatum.type;\n        const surfaceIndex = touchingDatum.index;\n        const pt = touchingDatum.pt;\n        switch (surfaceLabel[0].toLowerCase()) {\n            case \"l\": // player touching left wall\n                notTouchingWalls[0] = false;\n                dealWithWallCollision(i, newPosition, pt, \"l\", surfaceIndex, input);\n                break;\n            case \"r\": // player touching right wall\n                notTouchingWalls[1] = false;\n                dealWithWallCollision(i, newPosition, pt, \"r\", surfaceIndex, input);\n                break;\n            case \"g\": // player landed on ground\n                dealWithGroundCollision(i, main_1.player[i].phys.grounded, newPosition, newECB[0], surfaceIndex, input);\n                break;\n            case \"c\": // player touching ceiling\n                dealWithCeilingCollision(i, newPosition, newECB[2], surfaceIndex, input);\n                break;\n            case \"p\": // player landed on platform\n                dealWithPlatformCollision(i, main_1.player[i].phys.grounded, newPosition, newECB[0], surfaceIndex, input);\n                break;\n            default:\n                console.log(\"error in 'findAndResolveCollisions': unrecognised surface type.\");\n                break;\n        }\n    }\n    else if (touchingDatum.kind === \"corner\") {\n        const angularParameter = touchingDatum.angular;\n        const cornerDamageType = touchingDatum.damageType !== undefined ? touchingDatum.damageType : null;\n        dealWithCornerCollision(i, newPosition, newECB, angularParameter, cornerDamageType);\n    }\n    main_1.player[i].phys.ECB1 = newECB;\n    // finally, calculate how much squashing is required by the ground\n    if (main_1.player[i].phys.grounded) {\n        const groundSquashFactor = (0, environmentalCollision_1.groundedECBSquashFactor)(new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ecbOffset[3]) //    top non-squashed ECBp point\n        , new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y) // bottom non-squashed ECBp point, no offset as grounded\n        , (0, toList_1.toList)(activeStage_1.activeStage.ceiling));\n        if (groundSquashFactor !== null && (groundSquashFactor < ecbSquashData[i].factor)) {\n            ecbSquashData[i] = { location: 0, factor: groundSquashFactor };\n        }\n        if (ecbSquashData[i] !== null) {\n            ecbSquashData[i].location = 0;\n        }\n    }\n    return [stillGrounded, backward, notTouchingWalls];\n}\n;\nfunction dealWithLedges(i, input) {\n    const playerPosX = main_1.player[i].phys.pos.x;\n    const playerPosY = main_1.player[i].phys.pos.y;\n    //TODO find out what these magic numbers are\n    const ledgeSnapBoxOffset2 = main_1.player[i].charAttributes.ledgeSnapBoxOffset[2];\n    const ledgeSnapBoxOffset0 = main_1.player[i].charAttributes.ledgeSnapBoxOffset[0];\n    const ledgeSnapBoxOffset1 = main_1.player[i].charAttributes.ledgeSnapBoxOffset[1];\n    main_1.player[i].phys.ledgeSnapBoxF = new Box2D_1.Box2D([playerPosX, playerPosY + ledgeSnapBoxOffset2], [playerPosX + ledgeSnapBoxOffset0, playerPosY + ledgeSnapBoxOffset1]);\n    main_1.player[i].phys.ledgeSnapBoxB = new Box2D_1.Box2D([playerPosX - ledgeSnapBoxOffset0, playerPosY + ledgeSnapBoxOffset2], [playerPosX, playerPosY + ledgeSnapBoxOffset1]);\n    if (main_1.player[i].phys.ledgeRegrabCount) {\n        main_1.player[i].phys.ledgeRegrabTimeout--;\n        if (main_1.player[i].phys.ledgeRegrabTimeout === 0) {\n            main_1.player[i].phys.ledgeRegrabCount = false;\n        }\n    }\n    let lsBF = -1;\n    let lsBB = -1;\n    let foundLedge = 0;\n    if (main_1.player[i].phys.onLedge === -1 && !main_1.player[i].phys.ledgeRegrabCount) {\n        for (let j = 0; j < activeStage_1.activeStage.ledge.length; j++) {\n            let ledgeAvailable = true;\n            for (let k = 0; k < 4; k++) {\n                if (main_1.playerType[k] > -1) {\n                    if (k !== i) {\n                        if (main_1.player[k].phys.onLedge === j) {\n                            ledgeAvailable = false;\n                        }\n                    }\n                }\n            }\n            if (ledgeAvailable && !main_1.player[i].phys.grounded && main_1.player[i].hit.hitstun <= 0) {\n                const x = activeStage_1.activeStage[activeStage_1.activeStage.ledge[j][0]][activeStage_1.activeStage.ledge[j][1]][activeStage_1.activeStage.ledge[j][2]].x;\n                const y = activeStage_1.activeStage[activeStage_1.activeStage.ledge[j][0]][activeStage_1.activeStage.ledge[j][1]][activeStage_1.activeStage.ledge[j][2]].y;\n                if (x > main_1.player[i].phys.ledgeSnapBoxF.min.x &&\n                    x < main_1.player[i].phys.ledgeSnapBoxF.max.x &&\n                    y < main_1.player[i].phys.ledgeSnapBoxF.min.y &&\n                    y > main_1.player[i].phys.ledgeSnapBoxF.max.y) {\n                    if (activeStage_1.activeStage.ledge[j][2] === 0) {\n                        if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[0]) {\n                            lsBF = j;\n                        }\n                    }\n                    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        lsBF = j;\n                    }\n                }\n                if (x > main_1.player[i].phys.ledgeSnapBoxB.min.x &&\n                    x < main_1.player[i].phys.ledgeSnapBoxB.max.x &&\n                    y < main_1.player[i].phys.ledgeSnapBoxB.min.y &&\n                    y > main_1.player[i].phys.ledgeSnapBoxF.max.y) {\n                    if (activeStage_1.activeStage.ledge[j][2] === 1) {\n                        if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[0]) {\n                            lsBB = j;\n                        }\n                    }\n                    else if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        lsBB = j;\n                    }\n                }\n            }\n            if (main_1.player[i].phys.cVel.y < 0 && input[i][0].lsY > -0.5) {\n                if (lsBF > -1) {\n                    foundLedge = activeStage_1.activeStage.ledge[lsBF];\n                    if (foundLedge[2] * -2 + 1 === main_1.player[i].phys.face || actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        main_1.player[i].phys.onLedge = lsBF;\n                        main_1.player[i].phys.ledgeRegrabTimeout = 30;\n                        main_1.player[i].phys.face = foundLedge[2] * -2 + 1;\n                        main_1.player[i].phys.pos = new Vec2D_1.Vec2D(activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].x + main_1.edgeOffset[0][0], activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].y + main_1.edgeOffset[0][1]);\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].CLIFFCATCH.init(i, input);\n                    }\n                }\n                else if (lsBB > -1) {\n                    foundLedge = activeStage_1.activeStage.ledge[lsBB];\n                    if (foundLedge[2] * -2 + 1 === main_1.player[i].phys.face || actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].canGrabLedge[1]) {\n                        main_1.player[i].phys.onLedge = lsBB;\n                        main_1.player[i].phys.ledgeRegrabTimeout = 30;\n                        main_1.player[i].phys.face = foundLedge[2] * -2 + 1;\n                        main_1.player[i].phys.pos = new Vec2D_1.Vec2D(activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].x + main_1.edgeOffset[1][0], activeStage_1.activeStage[foundLedge[0]][foundLedge[1]][foundLedge[2]].y + main_1.edgeOffset[1][1]);\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].CLIFFCATCH.init(i, input);\n                    }\n                }\n            }\n        }\n    }\n}\n;\nfunction dealWithDeath(i, input) {\n    if (!actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].dead && main_1.player[i].actionState !== \"SLEEP\") {\n        let state = 0;\n        if (main_1.player[i].phys.pos.x < activeStage_1.activeStage.blastzone.min.x) {\n            state = \"DEADLEFT\";\n        }\n        else if (main_1.player[i].phys.pos.x > activeStage_1.activeStage.blastzone.max.x) {\n            state = \"DEADRIGHT\";\n        }\n        else if (main_1.player[i].phys.pos.y < activeStage_1.activeStage.blastzone.min.y) {\n            state = \"DEADDOWN\";\n        }\n        else if (main_1.player[i].phys.pos.y > activeStage_1.activeStage.blastzone.max.y && main_1.player[i].phys.kVel.y >= 2.4) {\n            state = \"DEADUP\";\n        }\n        if (state !== 0) {\n            main_1.player[i].phys.outOfCameraTimer = 0;\n            (0, actionStateShortcuts_1.turnOffHitboxes)(i);\n            main_1.player[i].stocks--;\n            main_1.player[i].colourOverlayBoolean = false;\n            render_1.lostStockQueue.push([i, main_1.player[i].stocks, 0]);\n            if (main_1.player[i].stocks === 0 && main_1.versusMode) {\n                main_1.player[i].stocks = 1;\n            }\n            actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][state].init(i, input);\n        }\n    }\n}\n;\nfunction updateHitboxes(i) {\n    main_1.player[i].phys.isInterpolated = false;\n    for (let j = 0; j < 4; j++) {\n        if (main_1.player[i].hitboxes.active[j] && main_1.player[i].phys.prevFrameHitboxes.active[j]) {\n            if (main_1.player[i].phys.prevFrameHitboxes.id[j].offset[main_1.player[i].phys.prevFrameHitboxes.frame] === undefined) {\n                continue;\n            }\n            if (main_1.player[i].hitboxes.id[j].offset[main_1.player[i].hitboxes.frame] === undefined) {\n                continue;\n            }\n            const h1 = new Vec2D_1.Vec2D(main_1.player[i].phys.posPrev.x + (main_1.player[i].phys.prevFrameHitboxes.id[j].offset[main_1.player[i].phys.prevFrameHitboxes.frame].x * main_1.player[i].phys.facePrev), main_1.player[i].phys.posPrev.y + main_1.player[i].phys.prevFrameHitboxes.id[j].offset[main_1.player[i].phys.prevFrameHitboxes.frame].y);\n            const h2 = new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x + (main_1.player[i].hitboxes.id[j].offset[main_1.player[i].hitboxes.frame].x * main_1.player[i].phys.face), main_1.player[i].phys.pos.y + main_1.player[i].hitboxes.id[j].offset[main_1.player[i].hitboxes.frame].y);\n            const a = h2.x - h1.x;\n            const b = h2.y - h1.y;\n            let x = 0;\n            if (!(a === 0 || b === 0)) {\n                x = Math.atan(Math.abs(a) / Math.abs(b));\n            }\n            {\n                const opp = Math.sin(x) * main_1.player[i].hitboxes.id[j].size;\n                const adj = Math.cos(x) * main_1.player[i].hitboxes.id[j].size;\n                const sigma = [h1.x, h1.y];\n                let alpha1;\n                let alpha2;\n                let beta1;\n                let beta2;\n                if ((a > 0 && b > 0) || (a <= 0 && b <= 0)) {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                else {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                main_1.player[i].phys.interPolatedHitbox[j] = [alpha1, alpha2, beta2, beta1];\n            }\n            {\n                const opp = Math.sin(x) * main_1.player[i].hitboxes.id[j].size - settings_1.gameSettings.phantomThreshold;\n                const adj = Math.cos(x) * main_1.player[i].hitboxes.id[j].size - settings_1.gameSettings.phantomThreshold;\n                const sigma = [h1.x, h1.y];\n                let alpha1;\n                let alpha2;\n                let beta1;\n                let beta2;\n                if ((a > 0 && b > 0) || (a <= 0 && b <= 0)) {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                else {\n                    alpha1 = new Vec2D_1.Vec2D((sigma[0] - adj), (sigma[1] - opp));\n                    alpha2 = new Vec2D_1.Vec2D((alpha1.x + a), (alpha1.y + b));\n                    beta1 = new Vec2D_1.Vec2D((sigma[0] + adj), (sigma[1] + opp));\n                    beta2 = new Vec2D_1.Vec2D((beta1.x + a), (beta1.y + b));\n                }\n                main_1.player[i].phys.interPolatedHitboxPhantom[j] = [alpha1, alpha2, beta2, beta1];\n                main_1.player[i].phys.isInterpolated = true;\n            }\n        }\n    }\n}\n;\nfunction physics(i, input) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    main_1.player[i].phys.passing = false;\n    main_1.player[i].phys.posPrev = new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y);\n    main_1.player[i].phys.facePrev = main_1.player[i].phys.face;\n    (0, deepCopyObject_1.deepObjectMerge)(true, main_1.player[i].phys.prevFrameHitboxes, main_1.player[i].hitboxes);\n    hitlagSwitchUpdate(i, input);\n    hurtBoxStateUpdate(i);\n    outOfCameraUpdate(i);\n    lCancelUpdate(i, input);\n    if (!main_1.player[i].phys.grounded) {\n        main_1.player[i].phys.airborneTimer++;\n    }\n    //console.log(player[i].timer);\n    let frame = Math.floor(main_1.player[i].timer);\n    if (frame === 0) {\n        frame = 1;\n    }\n    if (frame > characters_1.framesData[main_1.characterSelections[i]][main_1.player[i].actionState]) {\n        frame = characters_1.framesData[main_1.characterSelections[i]][main_1.player[i].actionState];\n    }\n    //console.log(actionStates[characterSelections[i]][player[i].actionState].name+\" \"+(frame-1));\n    /* global ecb */\n    var ecb;\n    const ecbOffset = actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].dead ? [0, 0, 0, 0] : [ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][0] * main_1.player[i].charAttributes.ecbScale, ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][1] * main_1.player[i].charAttributes.ecbScale, ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][2] * main_1.player[i].charAttributes.ecbScale, ecb[main_1.characterSelections[i]][main_1.player[i].actionState][frame - 1][3] * main_1.player[i].charAttributes.ecbScale];\n    const playerPosX = main_1.player[i].phys.pos.x;\n    const playerPosY = main_1.player[i].phys.pos.y;\n    main_1.player[i].phys.ECBp = [\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ((main_1.player[i].phys.grounded || main_1.player[i].phys.airborneTimer < 10) ? 0 : ecbOffset[0])),\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x + Math.max(1, ecbOffset[1]), main_1.player[i].phys.pos.y + ecbOffset[2]),\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ecbOffset[3]),\n        new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x - ecbOffset[1], main_1.player[i].phys.pos.y + ecbOffset[2])\n    ];\n    if (ecbSquashData[i] !== null && ecbSquashData[i].factor < 1) {\n        if (ecbSquashData[i].factor * 2 * ecbOffset[1] < environmentalCollision_1.smallestECBWidth) {\n            ecbSquashData[i].factor = (environmentalCollision_1.smallestECBWidth + 2 * environmentalCollision_1.additionalOffset) / (2 * ecbOffset[1]);\n        }\n        main_1.player[i].phys.ECBp = (0, ecbTransform_1.squashECBAt)(main_1.player[i].phys.ECBp, { factor: ecbSquashData[i].factor, location: 0 });\n        if (!main_1.player[i].phys.grounded) {\n            main_1.player[i].phys.ECBp = (0, ecbTransform_1.moveECB)(main_1.player[i].phys.ECBp, new Vec2D_1.Vec2D(0, (ecbSquashData[i].factor - 1) * ecbOffset[0]));\n        }\n    }\n    if (!actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].ignoreCollision) {\n        let notTouchingWalls = [true, true];\n        let stillGrounded = true;\n        let backward = false;\n        [stillGrounded, backward, notTouchingWalls] = findAndResolveCollisions(i, input, backward, notTouchingWalls, ecbOffset);\n        if (main_1.player[i].phys.grabbedBy === -1) {\n            if (notTouchingWalls[0] && notTouchingWalls[1] && main_1.player[i].phys.canWallJump) {\n                main_1.player[i].phys.wallJumpTimer = 254;\n            }\n            if (!notTouchingWalls[0] || !notTouchingWalls[1]) {\n                if (main_1.player[i].phys.grounded) {\n                    const s = main_1.player[i].phys.onSurface[1];\n                    const surface = main_1.player[i].phys.onSurface[0] ? activeStage_1.activeStage.platform[s] : activeStage_1.activeStage.ground[s];\n                    if (main_1.player[i].phys.pos.x < surface[0].x - 0.1 || main_1.player[i].phys.pos.x > surface[1].x + 0.1) {\n                        stillGrounded = false;\n                    }\n                }\n            }\n            if (!stillGrounded) {\n                main_1.player[i].phys.grounded = false;\n                if (typeof actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].airborneState !== 'undefined') {\n                    main_1.player[i].actionState = actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].airborneState;\n                }\n                else {\n                    if (actionStateShortcuts_1.actionStates[main_1.characterSelections[i]][main_1.player[i].actionState].missfoot && backward) {\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].MISSFOOT.init(i, input);\n                    }\n                    else {\n                        if (main_1.player[i].phys.grabbing !== -1) {\n                            actionStateShortcuts_1.actionStates[main_1.characterSelections[main_1.player[i].phys.grabbing]].FALL.init(main_1.player[i].phys.grabbing, input, true);\n                            main_1.player[main_1.player[i].phys.grabbing].phys.grabbedBy = -1;\n                            main_1.player[i].phys.grabbing = -1;\n                        }\n                        actionStateShortcuts_1.actionStates[main_1.characterSelections[i]].FALL.init(i, input);\n                    }\n                    if (Math.abs(main_1.player[i].phys.cVel.x) > main_1.player[i].charAttributes.aerialHmaxV) {\n                        main_1.player[i].phys.cVel.x = Math.sign(main_1.player[i].phys.cVel.x) * main_1.player[i].charAttributes.aerialHmaxV;\n                    }\n                }\n                main_1.player[i].phys.shielding = false;\n            }\n            if (main_1.player[i].phys.grounded) {\n                for (let j = 0; j < 4; j++) {\n                    if (main_1.playerType[j] > -1) {\n                        if (i !== j) {\n                            if (main_1.player[j].phys.grounded &&\n                                main_1.player[j].phys.onSurface[0] === main_1.player[i].phys.onSurface[0] &&\n                                main_1.player[j].phys.onSurface[1] === main_1.player[i].phys.onSurface[1]) {\n                                if (main_1.player[i].phys.grabbing !== j && main_1.player[i].phys.grabbedBy !== j) {\n                                    // TODO: this pushing code needs to account for players on slanted surfaces\n                                    const diff = Math.abs(main_1.player[i].phys.pos.x - main_1.player[j].phys.pos.x);\n                                    if (diff < 6.5 && diff > 0) {\n                                        main_1.player[j].phys.pos.x += Math.sign(main_1.player[i].phys.pos.x - main_1.player[j].phys.pos.x) * -0.3;\n                                    }\n                                    else if (diff === 0 && Math.abs(main_1.player[i].phys.cVel.x) > Math.abs(main_1.player[j].phys.cVel.x)) {\n                                        main_1.player[j].phys.pos.x += Math.sign(main_1.player[i].phys.cVel.x) * -0.3;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    else { // player ignoring collisions\n        main_1.player[i].phys.ECB1 = [\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ((main_1.player[i].phys.grounded || main_1.player[i].phys.airborneTimer < 10) ? 0 : ecbOffset[0])),\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x + ecbOffset[1], main_1.player[i].phys.pos.y + ecbOffset[2]),\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x, main_1.player[i].phys.pos.y + ecbOffset[3]),\n            new Vec2D_1.Vec2D(main_1.player[i].phys.pos.x - ecbOffset[1], main_1.player[i].phys.pos.y + ecbOffset[2])\n        ];\n    }\n    if (main_1.player[i].phys.shielding === false) {\n        main_1.player[i].phys.shieldHP += 0.07;\n        if (main_1.player[i].phys.shieldHP > 60) {\n            main_1.player[i].phys.shieldHP = 60;\n        }\n    }\n    dealWithLedges(i, input);\n    dealWithDeath(i, input);\n    main_1.player[i].phys.hurtbox = new Box2D_1.Box2D([playerPosX - main_1.player[i].charAttributes.hurtboxOffset[0], playerPosY + main_1.player[i].charAttributes.hurtboxOffset[1]], [playerPosX + main_1.player[i].charAttributes.hurtboxOffset[0], playerPosY]);\n    if (main_1.gameMode === 3 && main_1.player[i].phys.posPrev.y > -80 && playerPosY <= -80) {\n        sfx_1.sounds.lowdown.play();\n    }\n    updateHitboxes(i);\n    main_1.player[i].phys.posDelta = new Vec2D_1.Vec2D(Math.abs(playerPosX - main_1.player[i].phys.posPrev.x), Math.abs(playerPosY - main_1.player[i].phys.posPrev.y));\n    if (main_1.showDebug) {\n        (_a = document.getElementById('actState' + i)) === null || _a === void 0 ? void 0 : _a.innerHTML = main_1.player[i].currentAction + \" \" + main_1.player[i].currentSubaction + \" : \" + main_1.player[i].actionState;\n        (_b = document.getElementById('stateNum' + i)) === null || _b === void 0 ? void 0 : _b.innerHTML = frame.toString();\n        (_c = document.getElementById('face' + i)) === null || _c === void 0 ? void 0 : _c.innerHTML = main_1.player[i].phys.face;\n        (_d = document.getElementById(\"velocityX\" + i)) === null || _d === void 0 ? void 0 : _d.innerHTML = main_1.player[i].phys.cVel.x.toFixed(5);\n        (_e = document.getElementById(\"velocityY\" + i)) === null || _e === void 0 ? void 0 : _e.innerHTML = main_1.player[i].phys.cVel.y.toFixed(5);\n        (_f = document.getElementById(\"kvelocityX\" + i)) === null || _f === void 0 ? void 0 : _f.innerHTML = main_1.player[i].phys.kVel.x.toFixed(5);\n        (_g = document.getElementById(\"kvelocityY\" + i)) === null || _g === void 0 ? void 0 : _g.innerHTML = main_1.player[i].phys.kVel.y.toFixed(5);\n        (_h = document.getElementById(\"pvelocityX\" + i)) === null || _h === void 0 ? void 0 : _h.innerHTML = playerPosX.toFixed(5);\n        (_j = document.getElementById(\"pvelocityY\" + i)) === null || _j === void 0 ? void 0 : _j.innerHTML = playerPosY.toFixed(5);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGh5c2ljcy9waHlzaWNzLnRzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsd0NBQWM7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsb0RBQW9CO0FBQ2pELGNBQWMsbUJBQU8sQ0FBQyxzQ0FBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxzQ0FBYTtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQyxxRUFBd0I7QUFDL0QsdUJBQXVCLG1CQUFPLENBQUMscURBQWdCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDRDQUFnQjtBQUN6QyxpQ0FBaUMsbUJBQU8sQ0FBQyx5RUFBMEI7QUFDbkUseUJBQXlCLG1CQUFPLENBQUMsc0VBQTZCO0FBQzlELGtCQUFrQixtQkFBTyxDQUFDLHNEQUFxQjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4Q0FBaUI7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsMERBQXVCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLG9EQUFvQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvREFBb0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsc0RBQXFCO0FBQzlDLHVCQUF1QixtQkFBTyxDQUFDLHNFQUE2QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyxrRUFBMkI7QUFDMUQsaUJBQWlCLG1CQUFPLENBQUMsNENBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUE0QztBQUNwRTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLDhDQUE4QztBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21lbGVlbGlnaHQvLi9zcmMvcGh5c2ljcy9waHlzaWNzLnRzPzJmZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL0BmbG93XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxhbmQgPSBsYW5kO1xuZXhwb3J0cy5waHlzaWNzID0gcGh5c2ljcztcbmNvbnN0IG1haW5fMSA9IHJlcXVpcmUoXCIuLi9tYWluL21haW5cIik7XG5jb25zdCBjaGFyYWN0ZXJzXzEgPSByZXF1aXJlKFwiLi4vbWFpbi9jaGFyYWN0ZXJzXCIpO1xuY29uc3Qgc2Z4XzEgPSByZXF1aXJlKFwiLi4vbWFpbi9zZnhcIik7XG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3NldHRpbmdzXCIpO1xuY29uc3QgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMSA9IHJlcXVpcmUoXCIuL2FjdGlvblN0YXRlU2hvcnRjdXRzXCIpO1xuY29uc3QgaGl0RGV0ZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9oaXREZXRlY3Rpb25cIik7XG5jb25zdCByZW5kZXJfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3JlbmRlclwiKTtcbmNvbnN0IGVudmlyb25tZW50YWxDb2xsaXNpb25fMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50YWxDb2xsaXNpb25cIik7XG5jb25zdCBkZWVwQ29weU9iamVjdF8xID0gcmVxdWlyZShcIi4uL21haW4vdXRpbC9kZWVwQ29weU9iamVjdFwiKTtcbmNvbnN0IGRyYXdWZnhfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3ZmeC9kcmF3VmZ4XCIpO1xuY29uc3Qgc3RhZ2VfMSA9IHJlcXVpcmUoXCIuLi9zdGFnZXMvc3RhZ2VcIik7XG5jb25zdCBhY3RpdmVTdGFnZV8xID0gcmVxdWlyZShcIi4uL3N0YWdlcy9hY3RpdmVTdGFnZVwiKTtcbmNvbnN0IEJveDJEXzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL0JveDJEXCIpO1xuY29uc3QgVmVjMkRfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3V0aWwvVmVjMkRcIik7XG5jb25zdCB0b0xpc3RfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3V0aWwvdG9MaXN0XCIpO1xuY29uc3QgZXh0cmVtZVBvaW50XzEgPSByZXF1aXJlKFwiLi4vc3RhZ2VzL3V0aWwvZXh0cmVtZVBvaW50XCIpO1xuY29uc3QgZWNiVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL2VjYlRyYW5zZm9ybVwiKTtcbmNvbnN0IGxpbkFsZ18xID0gcmVxdWlyZShcIi4uL21haW4vbGluQWxnXCIpO1xuZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oaSwgbmV3UG9zaXRpb24pIHtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zID0gbmV3UG9zaXRpb247XG59XG47XG5mdW5jdGlvbiBkZWFsV2l0aERhbWFnaW5nU3RhZ2VDb2xsaXNpb24oaSwgbm9ybWFsLCBjb3JuZXIsIGFuZ3VsYXIsIGRhbWFnZVR5cGUpIHtcbiAgICBjb25zdCBjb2xsaXNpb25EYXRhID0geyBub3JtYWw6IG5vcm1hbCwgYW5ndWxhcjogYW5ndWxhciwgY29ybmVyOiBjb3JuZXIgfTtcbiAgICBsZXQgZGFtYWdlVHlwZUluZGV4ID0gLTE7XG4gICAgc3dpdGNoIChkYW1hZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJmaXJlXCI6XG4gICAgICAgICAgICBkYW1hZ2VUeXBlSW5kZXggPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbGVjdHJpY1wiOlxuICAgICAgICAgICAgZGFtYWdlVHlwZUluZGV4ID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2xhc2hcIjpcbiAgICAgICAgICAgIGRhbWFnZVR5cGVJbmRleCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhcmtuZXNzXCI6XG4gICAgICAgICAgICBkYW1hZ2VUeXBlSW5kZXggPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGRhbWFnZVR5cGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgaGl0RGV0ZWN0aW9uXzEuaGl0UXVldWUucHVzaChbaSwgY29sbGlzaW9uRGF0YSwgZGFtYWdlVHlwZUluZGV4LCBmYWxzZSwgZmFsc2UsIHRydWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWFsV2l0aFdhbGxDb2xsaXNpb24oaSwgbmV3UG9zaXRpb24sIHB0LCB3YWxsVHlwZSwgd2FsbEluZGV4LCBpbnB1dCkge1xuICAgIHVwZGF0ZVBvc2l0aW9uKGksIG5ld1Bvc2l0aW9uKTtcbiAgICBsZXQgd2FsbExhYmVsID0gXCJMXCI7XG4gICAgbGV0IHNpZ24gPSAtMTtcbiAgICBsZXQgaXNSaWdodCA9IDA7XG4gICAgaWYgKHdhbGxUeXBlWzBdLnRvTG93ZXJDYXNlKCkgPT09IFwiclwiKSB7XG4gICAgICAgIHdhbGxMYWJlbCA9IFwiUlwiO1xuICAgICAgICBzaWduID0gMTtcbiAgICAgICAgaXNSaWdodCA9IDE7XG4gICAgfVxuICAgIGNvbnN0IHdhbGwgPSAoMCwgc3RhZ2VfMS5nZXRTdXJmYWNlRnJvbVN0YWdlKShbd2FsbFR5cGUsIHdhbGxJbmRleF0sIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UpO1xuICAgIGNvbnN0IHdhbGxCb3R0b20gPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KSh3YWxsLCBcImJcIik7XG4gICAgY29uc3Qgd2FsbFRvcCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKHdhbGwsIFwidFwiKTtcbiAgICBjb25zdCB3YWxsTm9ybWFsID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5vdXR3YXJkc1dhbGxOb3JtYWwpKHdhbGxCb3R0b20sIHdhbGxUb3AsIHdhbGxUeXBlKTtcbiAgICBjb25zdCBkYW1hZ2VUeXBlID0gd2FsbFsyXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHdhbGxbMl0uZGFtYWdlVHlwZTtcbiAgICBjb25zdCBpbkRhbWFnZVN0YXRlID0gbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9PT0gXCJEQU1BR0VGTFlOXCIgfHwgbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9PT0gXCJXQUxMREFNQUdFXCIgfHwgbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9PT0gXCJEQU1BR0VGQUxMXCI7XG4gICAgaWYgKGluRGFtYWdlU3RhdGUgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLnRlY2hUaW1lciA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgPSBzaWduO1xuICAgICAgICBpZiAoaW5wdXRbaV1bMF0ueCB8fCBpbnB1dFtpXVswXS55IHx8IGlucHV0W2ldWzBdLmxzWSA+IDAuNykge1xuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLldBTExURUNISlVNUC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5XQUxMVEVDSC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbkRhbWFnZVN0YXRlICYmIE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbCkgIT09IHNpZ24gJiYgbWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID09PSAwICYmIE1hdGgucG93KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLngsIDIpICsgTWF0aC5wb3cobWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSwgMikgPj0gMi4yNSkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZSA9IHNpZ247XG4gICAgICAgICgwLCBkcmF3VmZ4XzEuZHJhd1ZmeCkoe1xuICAgICAgICAgICAgbmFtZTogXCJ3YWxsQm91bmNlXCIsXG4gICAgICAgICAgICBwb3M6IG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCwgbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnBbMV0ueSksXG4gICAgICAgICAgICBmYWNlOiBzaWduLFxuICAgICAgICAgICAgZjogd2FsbE5vcm1hbFxuICAgICAgICB9KTtcbiAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLldBTExEQU1BR0UuaW5pdChpLCBpbnB1dCwgd2FsbE5vcm1hbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZyA9PT0gMCkge1xuICAgICAgICBpZiAoZGFtYWdlVHlwZSAhPT0gdW5kZWZpbmVkICYmIGRhbWFnZVR5cGUgIT09IG51bGxcbiAgICAgICAgICAgICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGRhbWFnZVxuICAgICAgICAgICAgZGVhbFdpdGhEYW1hZ2luZ1N0YWdlQ29sbGlzaW9uKGksIHdhbGxOb3JtYWwsIGZhbHNlLCBwdCwgZGFtYWdlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLnNwZWNpYWxXYWxsQ29sbGlkZSkge1xuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLm9uV2FsbENvbGxpZGUoaSwgaW5wdXQsIHdhbGxMYWJlbCwgd2FsbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuY2FuV2FsbEp1bXApIHtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMud2FsbEp1bXBUaW1lciA9PT0gMjU0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3NEZWx0YS54ID49IDAuNSkge1xuICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMud2FsbEp1bXBUaW1lciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMud2FsbEp1bXBUaW1lciA+PSAwICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy53YWxsSnVtcFRpbWVyIDwgMTIwKSB7XG4gICAgICAgICAgICBpZiAoc2lnbiAqIGlucHV0W2ldWzBdLmxzWCA+PSAwLjcgJiZcbiAgICAgICAgICAgICAgICBzaWduICogaW5wdXRbaV1bM10ubHNYIDw9IDAgJiZcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLndhbGxqdW1wKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLndhbGxKdW1wVGltZXIgPSAyNTQ7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgPSBzaWduO1xuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5XQUxMSlVNUC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy53YWxsSnVtcFRpbWVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG47XG5mdW5jdGlvbiBkZWFsV2l0aFBsYXRmb3JtQ29sbGlzaW9uKGksIGFscmVhZHlHcm91bmRlZCwgbmV3UG9zaXRpb24sIGVjYnBCb3R0b20sIHBsYXRmb3JtSW5kZXgsIGlucHV0KSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSAoMCwgc3RhZ2VfMS5nZXRTdXJmYWNlRnJvbVN0YWdlKShbXCJwXCIsIHBsYXRmb3JtSW5kZXhdLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlKTtcbiAgICBjb25zdCBkYW1hZ2VUeXBlID0gcGxhdGZvcm1bMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBwbGF0Zm9ybVsyXS5kYW1hZ2VUeXBlO1xuICAgIGNvbnN0IHBsYXRMZWZ0ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkocGxhdGZvcm0sIFwibFwiKTtcbiAgICBjb25zdCBwbGF0UmlnaHQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShwbGF0Zm9ybSwgXCJyXCIpO1xuICAgIGNvbnN0IHBsYXROb3JtYWwgPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLm91dHdhcmRzV2FsbE5vcm1hbCkocGxhdExlZnQsIHBsYXRSaWdodCwgXCJnXCIpO1xuICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5oaXRsYWcgPiAwIHx8IGFscmVhZHlHcm91bmRlZCB8fCBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJlZEJ5ICE9PSAtMSkge1xuICAgICAgICB1cGRhdGVQb3NpdGlvbihpLCBuZXdQb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsYW5kKGksIGVjYnBCb3R0b20sIDEsIHBsYXRmb3JtSW5kZXgsIHBsYXROb3JtYWwsIGlucHV0KTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBkZWFsV2l0aEdyb3VuZENvbGxpc2lvbihpLCBhbHJlYWR5R3JvdW5kZWQsIG5ld1Bvc2l0aW9uLCBlY2JwQm90dG9tLCBncm91bmRJbmRleCwgaW5wdXQpIHtcbiAgICBjb25zdCBncm91bmQgPSAoMCwgc3RhZ2VfMS5nZXRTdXJmYWNlRnJvbVN0YWdlKShbXCJnXCIsIGdyb3VuZEluZGV4XSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZSk7XG4gICAgY29uc3QgZGFtYWdlVHlwZSA9IGdyb3VuZFsyXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdyb3VuZFsyXS5kYW1hZ2VUeXBlO1xuICAgIGNvbnN0IGlnbm9yZURhbWFnZSA9IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkxZTlwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkFMTFwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiV0FMTERBTUFHRVwiO1xuICAgIGNvbnN0IGdyb3VuZExlZnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShncm91bmQsIFwibFwiKTtcbiAgICBjb25zdCBncm91bmRSaWdodCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKGdyb3VuZCwgXCJyXCIpO1xuICAgIGNvbnN0IGdyb3VuZE5vcm1hbCA9ICgwLCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEub3V0d2FyZHNXYWxsTm9ybWFsKShncm91bmRMZWZ0LCBncm91bmRSaWdodCwgXCJnXCIpO1xuICAgIGlmICghaWdub3JlRGFtYWdlICYmIGRhbWFnZVR5cGUgIT09IHVuZGVmaW5lZCAmJiBkYW1hZ2VUeXBlICE9PSBudWxsXG4gICAgICAgICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPT09IDApIHtcbiAgICAgICAgLy8gYXBwbHkgZGFtYWdlXG4gICAgICAgIGRlYWxXaXRoRGFtYWdpbmdTdGFnZUNvbGxpc2lvbihpLCBncm91bmROb3JtYWwsIGZhbHNlLCAwLCBkYW1hZ2VUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5oaXRsYWcgPiAwIHx8IGFscmVhZHlHcm91bmRlZCB8fCBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJlZEJ5ICE9PSAtMSkge1xuICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24oaSwgbmV3UG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFuZChpLCBlY2JwQm90dG9tLCAwLCBncm91bmRJbmRleCwgZ3JvdW5kTm9ybWFsLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG47XG5mdW5jdGlvbiBmYWxsT2ZmR3JvdW5kKGksIHNpZGUsIGdyb3VuZEVkZ2VQb3NpdGlvbiwgZGlzYWJsZUZhbGwsIGlucHV0KSB7XG4gICAgbGV0IFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBbdHJ1ZSwgZmFsc2VdO1xuICAgIGxldCBzaWduID0gMTtcbiAgICBpZiAoc2lkZSA9PT0gXCJyXCIpIHtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cbiAgICBpZiAoZGlzYWJsZUZhbGwpIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ID0gTWF0aC5tYXgobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55LCBncm91bmRFZGdlUG9zaXRpb24ueSkgKyBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldDtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ID0gZ3JvdW5kRWRnZVBvc2l0aW9uLnggKyAoc2lkZSA9PT0gXCJsXCIgPyBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldCA6IC1lbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldCk7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwID0gKDAsIGVjYlRyYW5zZm9ybV8xLm1vdmVFQ0IpKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwLCAoMCwgbGluQWxnXzEuc3VidHJhY3QpKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwWzBdKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5jYW5FZGdlQ2FuY2VsKSB7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZSA9PT0gc2lnbikge1xuICAgICAgICAgICAgc3RpbGxHcm91bmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ID0gTWF0aC5tYXgobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55LCBncm91bmRFZGdlUG9zaXRpb24ueSkgKyBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldDtcbiAgICAgICAgICAgIGJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhpbnB1dFtpXVswXS5sc1gpID4gMC42XG4gICAgICAgICAgICB8fCAobWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCA9PT0gMCAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54ID09PSAwKVxuICAgICAgICAgICAgfHwgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmRpc2FibGVUZWV0ZXJcbiAgICAgICAgICAgIHx8IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5zaGllbGRpbmcpIHtcbiAgICAgICAgICAgIHN0aWxsR3JvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA9IE1hdGgubWF4KG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSwgZ3JvdW5kRWRnZVBvc2l0aW9uLnkpICsgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54ID0gMDtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA9IGdyb3VuZEVkZ2VQb3NpdGlvbi54ICsgc2lnbiAqIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5hZGRpdGlvbmFsT2Zmc2V0O1xuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLk9UVE9UVE8uaW5pdChpLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCA9PT0gMFxuICAgICAgICAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54ID09PSAwXG4gICAgICAgICYmICFhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uaW5HcmFiKSB7XG4gICAgICAgIHN0aWxsR3JvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ID0gTWF0aC5tYXgobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55LCBncm91bmRFZGdlUG9zaXRpb24ueSkgKyBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnggPSAwO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggPSBncm91bmRFZGdlUG9zaXRpb24ueCArIHNpZ24gKiBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldDtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF07XG59XG47XG4vLyBncm91bmQgdHlwZSBhbmQgaW5kZXggaXMgYSBwYWlyLCBlaXRoZXIgW1wiZ1wiLCBpbmRleF0gb3IgW1wicFwiLCBpbmRleF1cbmZ1bmN0aW9uIGRlYWxXaXRoR3JvdW5kKGksIGdyb3VuZCwgZ3JvdW5kVHlwZUFuZEluZGV4LCBjb25uZWN0ZWQsIGlucHV0KSB7XG4gICAgY29uc3QgZGFtYWdlVHlwZSA9IGdyb3VuZFsyXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdyb3VuZFsyXS5kYW1hZ2VUeXBlO1xuICAgIGNvbnN0IGlnbm9yZURhbWFnZSA9IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkxZTlwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkFMTFwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiV0FMTERBTUFHRVwiO1xuICAgIGNvbnN0IGxlZnRtb3N0R3JvdW5kUG9pbnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShncm91bmQsIFwibFwiKTtcbiAgICBjb25zdCByaWdodG1vc3RHcm91bmRQb2ludCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKGdyb3VuZCwgXCJyXCIpO1xuICAgIGNvbnN0IGdyb3VuZE5vcm1hbCA9ICgwLCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEub3V0d2FyZHNXYWxsTm9ybWFsKShsZWZ0bW9zdEdyb3VuZFBvaW50LCByaWdodG1vc3RHcm91bmRQb2ludCwgXCJnXCIpO1xuICAgIGxldCBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gW3RydWUsIGZhbHNlXTtcbiAgICBsZXQgZ3JvdW5kT3JQbGF0Zm9ybSA9IDA7XG4gICAgaWYgKGdyb3VuZFR5cGVBbmRJbmRleFswXSA9PT0gXCJwXCIpIHtcbiAgICAgICAgZ3JvdW5kT3JQbGF0Zm9ybSA9IDE7XG4gICAgfVxuICAgIGxldCBkaXNhYmxlRmFsbCA9IGZhbHNlO1xuICAgIGxldCBtYXliZUxlZnRHcm91bmRUeXBlQW5kSW5kZXggPSBudWxsO1xuICAgIGxldCBtYXliZVJpZ2h0R3JvdW5kVHlwZUFuZEluZGV4ID0gbnVsbDtcbiAgICAvLyBmaXJzdCBjaGVjayBpZiB0aGUgcGxheWVyIGlzIGFsbG93ZWQgdG8gbW92ZSBhbG9uZyB0aGUgZ3JvdW5kLCBieSBjaGVja2luZyB0aGVyZSBhcmUgbm8gbG93IGNlaWxpbmdzXG4gICAgY29uc3QgZWNiMEhlaWdodCA9IE1hdGgubWF4KGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5hZGRpdGlvbmFsT2Zmc2V0LCBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCMVsyXS55IC0gbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQjFbMF0ueSAtIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5hZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICBjb25zdCBtYXliZU5leHRQb3NYID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5tb3ZlQWxvbmdHcm91bmQpKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0IxWzBdLCBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcFswXSwgZWNiMEhlaWdodCwgZ3JvdW5kLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmNlaWxpbmcpO1xuICAgIGlmIChtYXliZU5leHRQb3NYICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGNlaWxpbmcgaGFzIG9ic3RydWN0ZWQgZ3JvdW5kZWQgbW92ZW1lbnRcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ID0gbWF5YmVOZXh0UG9zWDtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnAgPSAoMCwgZWNiVHJhbnNmb3JtXzEubW92ZUVDQikobWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnAsIG5ldyBWZWMyRF8xLlZlYzJEKG1heWJlTmV4dFBvc1ggLSBtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcFswXS54LCAwKSk7XG4gICAgfVxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcFswXS54IDwgbGVmdG1vc3RHcm91bmRQb2ludC54KSB7XG4gICAgICAgIGlmIChjb25uZWN0ZWQgIT09IG51bGwgJiYgY29ubmVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1heWJlTGVmdEdyb3VuZFR5cGVBbmRJbmRleCA9IGdyb3VuZFR5cGVBbmRJbmRleFswXSA9PT0gXCJnXCJcbiAgICAgICAgICAgICAgICA/IGNvbm5lY3RlZFswXVtncm91bmRUeXBlQW5kSW5kZXhbMV1dWzBdXG4gICAgICAgICAgICAgICAgOiBjb25uZWN0ZWRbMV1bZ3JvdW5kVHlwZUFuZEluZGV4WzFdXVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVMZWZ0R3JvdW5kVHlwZUFuZEluZGV4ID09PSBudWxsIHx8IG1heWJlTGVmdEdyb3VuZFR5cGVBbmRJbmRleCA9PT0gdW5kZWZpbmVkKSB7IC8vIG5vIG90aGVyIGdyb3VuZCB0byB0aGUgbGVmdFxuICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGZhbGxPZmZHcm91bmQoaSwgXCJsXCIsIGxlZnRtb3N0R3JvdW5kUG9pbnQsIGRpc2FibGVGYWxsLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBbbGVmdEdyb3VuZFR5cGUsIGxlZnRHcm91bmRJbmRleF0gPSBtYXliZUxlZnRHcm91bmRUeXBlQW5kSW5kZXg7XG4gICAgICAgICAgICBzd2l0Y2ggKGxlZnRHcm91bmRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGRlYWxXaXRoR3JvdW5kKGksIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuZ3JvdW5kW2xlZnRHcm91bmRJbmRleF0sIFtcImdcIiwgbGVmdEdyb3VuZEluZGV4XSwgY29ubmVjdGVkLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwXCI6XG4gICAgICAgICAgICAgICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBkZWFsV2l0aEdyb3VuZChpLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLnBsYXRmb3JtW2xlZnRHcm91bmRJbmRleF0sIFtcInBcIiwgbGVmdEdyb3VuZEluZGV4XSwgY29ubmVjdGVkLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0V2FsbFRvVGhlTGVmdCA9IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2Uud2FsbFJbbGVmdEdyb3VuZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKHJpZ2h0V2FsbFRvVGhlTGVmdCwgXCJsXCIpLnkgPiBsZWZ0bW9zdEdyb3VuZFBvaW50LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVGYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZmFsbE9mZkdyb3VuZChpLCBcImxcIiwgbGVmdG1vc3RHcm91bmRQb2ludCwgZGlzYWJsZUZhbGwsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLy8gc3VyZmFjZSB0byB0aGUgbGVmdCBpcyBuZWl0aGVyIGdyb3VuZCwgcGxhdGZvcm0gb3IgcmlnaHQgd2FsbFxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZmFsbE9mZkdyb3VuZChpLCBcImxcIiwgbGVmdG1vc3RHcm91bmRQb2ludCwgZGlzYWJsZUZhbGwsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnBbMF0ueCA+IHJpZ2h0bW9zdEdyb3VuZFBvaW50LngpIHtcbiAgICAgICAgaWYgKGNvbm5lY3RlZCAhPT0gbnVsbCAmJiBjb25uZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWF5YmVSaWdodEdyb3VuZFR5cGVBbmRJbmRleCA9IGdyb3VuZFR5cGVBbmRJbmRleFswXSA9PT0gXCJnXCJcbiAgICAgICAgICAgICAgICA/IGNvbm5lY3RlZFswXVtncm91bmRUeXBlQW5kSW5kZXhbMV1dWzFdXG4gICAgICAgICAgICAgICAgOiBjb25uZWN0ZWRbMV1bZ3JvdW5kVHlwZUFuZEluZGV4WzFdXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmVSaWdodEdyb3VuZFR5cGVBbmRJbmRleCA9PT0gbnVsbCB8fCBtYXliZVJpZ2h0R3JvdW5kVHlwZUFuZEluZGV4ID09PSB1bmRlZmluZWQpIHsgLy8gbm8gb3RoZXIgZ3JvdW5kIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkXSA9IGZhbGxPZmZHcm91bmQoaSwgXCJyXCIsIHJpZ2h0bW9zdEdyb3VuZFBvaW50LCBkaXNhYmxlRmFsbCwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW3JpZ2h0R3JvdW5kVHlwZSwgcmlnaHRHcm91bmRJbmRleF0gPSBtYXliZVJpZ2h0R3JvdW5kVHlwZUFuZEluZGV4O1xuICAgICAgICAgICAgc3dpdGNoIChyaWdodEdyb3VuZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZGVhbFdpdGhHcm91bmQoaSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5ncm91bmRbcmlnaHRHcm91bmRJbmRleF0sIFtcImdcIiwgcmlnaHRHcm91bmRJbmRleF0sIGNvbm5lY3RlZCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZGVhbFdpdGhHcm91bmQoaSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5wbGF0Zm9ybVtyaWdodEdyb3VuZEluZGV4XSwgW1wicFwiLCByaWdodEdyb3VuZEluZGV4XSwgY29ubmVjdGVkLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRXYWxsVG9UaGVSaWdodCA9IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2Uud2FsbExbcmlnaHRHcm91bmRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShsZWZ0V2FsbFRvVGhlUmlnaHQsIFwiclwiKS55ID4gcmlnaHRtb3N0R3JvdW5kUG9pbnQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUZhbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBmYWxsT2ZmR3JvdW5kKGksIFwiclwiLCByaWdodG1vc3RHcm91bmRQb2ludCwgZGlzYWJsZUZhbGwsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogLy8gc3VyZmFjZSB0byB0aGUgcmlnaHQgaXMgbmVpdGhlciBncm91bmQsIHBsYXRmb3JtIG9yIGxlZnQgd2FsbFxuICAgICAgICAgICAgICAgICAgICBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdID0gZmFsbE9mZkdyb3VuZChpLCBcInJcIiwgcmlnaHRtb3N0R3JvdW5kUG9pbnQsIGRpc2FibGVGYWxsLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBlY2JwQm90dG9tID0gbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnBbMF07XG4gICAgICAgIGNvbnN0IHlJbnRlcmNlcHQgPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmNvb3JkaW5hdGVJbnRlcmNlcHQpKFtlY2JwQm90dG9tLCBuZXcgVmVjMkRfMS5WZWMyRChlY2JwQm90dG9tLngsIGVjYnBCb3R0b20ueSArIDEpXSwgZ3JvdW5kKTtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ID0gbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgeUludGVyY2VwdC55IC0gZWNicEJvdHRvbS55ICsgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQ7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwID0gKDAsIGVjYlRyYW5zZm9ybV8xLm1vdmVFQ0IpKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwLCBuZXcgVmVjMkRfMS5WZWMyRCgwLCB5SW50ZXJjZXB0LnkgLSBlY2JwQm90dG9tLnkgKyBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuYWRkaXRpb25hbE9mZnNldCkpO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMub25TdXJmYWNlID0gW2dyb3VuZE9yUGxhdGZvcm0sIGdyb3VuZFR5cGVBbmRJbmRleFsxXV07XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRBbmdsZSA9IE1hdGguYXRhbjIoZ3JvdW5kTm9ybWFsLnksIGdyb3VuZE5vcm1hbC54KSB8fCBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgaWYgKCFpZ25vcmVEYW1hZ2UgJiYgZGFtYWdlVHlwZSAhPT0gdW5kZWZpbmVkICYmIGRhbWFnZVR5cGUgIT09IG51bGxcbiAgICAgICAgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLmh1cnRCb3hTdGF0ZSA9PT0gMCkge1xuICAgICAgICAvLyBhcHBseSBkYW1hZ2VcbiAgICAgICAgZGVhbFdpdGhEYW1hZ2luZ1N0YWdlQ29sbGlzaW9uKGksIGdyb3VuZE5vcm1hbCwgZmFsc2UsIDAsIGRhbWFnZVR5cGUpO1xuICAgICAgICBzdGlsbEdyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBbc3RpbGxHcm91bmRlZCwgYmFja3dhcmRdO1xufVxuO1xuZnVuY3Rpb24gZGVhbFdpdGhDZWlsaW5nQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBlY2JUb3AsIGNlaWxpbmdJbmRleCwgaW5wdXQpIHtcbiAgICB1cGRhdGVQb3NpdGlvbihpLCBuZXdQb3NpdGlvbik7XG4gICAgY29uc3QgY2VpbGluZyA9ICgwLCBzdGFnZV8xLmdldFN1cmZhY2VGcm9tU3RhZ2UpKFtcImNcIiwgY2VpbGluZ0luZGV4XSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZSk7XG4gICAgY29uc3QgZGFtYWdlVHlwZSA9IGNlaWxpbmdbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjZWlsaW5nWzJdLmRhbWFnZVR5cGU7XG4gICAgY29uc3QgY2VpbGluZ0xlZnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShjZWlsaW5nLCBcImxcIik7XG4gICAgY29uc3QgY2VpbGluZ1JpZ2h0ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkoY2VpbGluZywgXCJyXCIpO1xuICAgIGNvbnN0IGNlaWxpbmdOb3JtYWwgPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLm91dHdhcmRzV2FsbE5vcm1hbCkoY2VpbGluZ0xlZnQsIGNlaWxpbmdSaWdodCwgXCJjXCIpO1xuICAgIGNvbnN0IGlnbm9yZURhbWFnZSA9IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkxZTlwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiREFNQUdFRkFMTFwiIHx8IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgPT09IFwiV0FMTERBTUFHRVwiO1xuICAgIGlmICghaWdub3JlRGFtYWdlICYmIGRhbWFnZVR5cGUgIT09IHVuZGVmaW5lZCAmJiBkYW1hZ2VUeXBlICE9PSBudWxsXG4gICAgICAgICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPT09IDApIHtcbiAgICAgICAgLy8gYXBwbHkgZGFtYWdlXG4gICAgICAgIGRlYWxXaXRoRGFtYWdpbmdTdGFnZUNvbGxpc2lvbihpLCBjZWlsaW5nTm9ybWFsLCBmYWxzZSwgMiwgZGFtYWdlVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5oZWFkQm9uayAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC55ICsgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSA+IDApIHtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdHN0dW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnRlY2hUaW1lciA+IDApIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uVEVDSFUuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoMCwgZHJhd1ZmeF8xLmRyYXdWZngpKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJjZWlsaW5nQm91bmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvczogZWNiVG9wLFxuICAgICAgICAgICAgICAgICAgICBmYWNlOiAxLFxuICAgICAgICAgICAgICAgICAgICBmOiBjZWlsaW5nTm9ybWFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2Z4XzEuc291bmRzLmJvdW5jZS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLlNUT1BDRUlMLmluaXQoaSwgaW5wdXQsIGNlaWxpbmdOb3JtYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLlNUT1BDRUlMLmluaXQoaSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gZGVhbFdpdGhDb3JuZXJDb2xsaXNpb24oaSwgbmV3UG9zaXRpb24sIGVjYiwgYW5ndWxhclBhcmFtZXRlciwgZGFtYWdlVHlwZSkge1xuICAgIHVwZGF0ZVBvc2l0aW9uKGksIG5ld1Bvc2l0aW9uKTtcbiAgICBjb25zdCBpbnNpZGVFQ0JUeXBlID0gYW5ndWxhclBhcmFtZXRlciA8IDIgPyBcImxcIiA6IFwiclwiO1xuICAgIGNvbnN0IFtzYW1lLCBvdGhlcl0gPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmdldFNhbWVBbmRPdGhlcikoYW5ndWxhclBhcmFtZXRlcik7XG4gICAgY29uc3QgbG93ZXJFQ0JQb2ludCA9IG90aGVyID09PSAyID8gZWNiW3NhbWVdIDogZWNiWzBdO1xuICAgIGNvbnN0IHVwcGVyRUNCUG9pbnQgPSBvdGhlciA9PT0gMiA/IGVjYlsyXSA6IGVjYltzYW1lXTtcbiAgICBjb25zdCBub3JtYWwgPSAoMCwgZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLm91dHdhcmRzV2FsbE5vcm1hbCkobG93ZXJFQ0JQb2ludCwgdXBwZXJFQ0JQb2ludCwgaW5zaWRlRUNCVHlwZSk7XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZyA9PT0gMCAmJiBkYW1hZ2VUeXBlICE9PSB1bmRlZmluZWQgJiYgZGFtYWdlVHlwZSAhPT0gbnVsbFxuICAgICAgICAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID09PSAwKSB7XG4gICAgICAgIGRlYWxXaXRoRGFtYWdpbmdTdGFnZUNvbGxpc2lvbihpLCBub3JtYWwsIHRydWUsIGFuZ3VsYXJQYXJhbWV0ZXIsIGRhbWFnZVR5cGUpO1xuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIGxhbmQoaSwgbmV3UG9zaXRpb24sIHQsIGosIG5vcm1hbCwgaW5wdXQpIHtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zID0gbmV3UG9zaXRpb247XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkID0gdHJ1ZTtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZG91YmxlSnVtcGVkID0gZmFsc2U7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmp1bXBzVXNlZCA9IDA7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmFpcmJvcm5lVGltZXIgPSAwO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYXN0ZmFsbGVkID0gZmFsc2U7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNoYXJnZUZyYW1lcyA9IDA7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNoYXJnaW5nID0gZmFsc2U7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLndhbGxKdW1wQ291bnQgPSAwO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy50aHJvd25IaXRib3ggPSBmYWxzZTtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuc2lkZUJKdW1wRmxhZyA9IHRydWU7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLm9uU3VyZmFjZSA9IFt0LCBqXTtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMub25MZWRnZSA9IC0xO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucm90YXRpb24gPSAwO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucm90YXRpb25Qb2ludCA9IG5ldyBWZWMyRF8xLlZlYzJEKDAsIDApO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0uY29sb3VyT3ZlcmxheUJvb2xlYW4gPSBmYWxzZTtcbiAgICBtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmFjdGl2ZSA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07XG4gICAgbGV0IG5ld05vcm1hbCA9IG5vcm1hbDtcbiAgICBpZiAobmV3Tm9ybWFsID09PSBudWxsIHx8IG5ld05vcm1hbCA9PT0gdW5kZWZpbmVkIHx8IChuZXdOb3JtYWwueCA9PT0gMCAmJiBuZXdOb3JtYWwueSA9PT0gMCkpIHtcbiAgICAgICAgbmV3Tm9ybWFsID0gbmV3IFZlYzJEXzEuVmVjMkQoMCwgMSk7XG4gICAgfVxuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRBbmdsZSA9IE1hdGguYXRhbjIobmV3Tm9ybWFsLnksIG5ld05vcm1hbC54KTtcbiAgICBzd2l0Y2ggKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5sYW5kVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAvLyBMQU5ESU5HIC8gTklMXG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueSA+PSAtMSkge1xuICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5XQUlULmluaXQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLkxBTkRJTkcuaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gT1dOIEZVTkNUSU9OXG4gICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0ubGFuZChpLCBpbnB1dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gS05PQ0tET1dOIC8gVEVDSFxuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy50ZWNoVGltZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0W2ldWzBdLmxzWCAqIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlID4gMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5URUNIRi5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRbaV1bMF0ubHNYICogbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgPCAtMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5URUNIQi5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXS5URUNITi5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uRE9XTkJPVU5ELmluaXQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uTEFORElORy5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC55ID0gMDtcbiAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55ID0gMDtcbiAgICBtYWluXzEucGxheWVyW2ldLmhpdC5oaXRzdHVuID0gMDtcbn1cbjtcbmZ1bmN0aW9uIGhpdGxhZ1N3aXRjaFVwZGF0ZShpLCBpbnB1dCkge1xuICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5oaXRsYWcgPiAwKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uaGl0LmhpdGxhZy0tO1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID09PSAwICYmIG1haW5fMS5wbGF5ZXJbaV0uaGl0Lmtub2NrYmFjayA+IDApIHtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJlZEJ5ID09PSAtMSB8fCBtYWluXzEucGxheWVyW2ldLmhpdC5rbm9ja2JhY2sgPiA1MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0FuZ2xlID0gKDAsIGhpdERldGVjdGlvbl8xLmdldExhdW5jaEFuZ2xlKShtYWluXzEucGxheWVyW2ldLmhpdC5hbmdsZSwgbWFpbl8xLnBsYXllcltpXS5oaXQua25vY2tiYWNrLCBtYWluXzEucGxheWVyW2ldLmhpdC5yZXZlcnNlLCBpbnB1dFtpXVswXS5sc1gsIGlucHV0W2ldWzBdLmxzWSwgaSk7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCA9IDA7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueSA9IDA7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhuZXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCA9ICgwLCBoaXREZXRlY3Rpb25fMS5nZXRIb3Jpem9udGFsVmVsb2NpdHkpKG1haW5fMS5wbGF5ZXJbaV0uaGl0Lmtub2NrYmFjaywgbmV3QW5nbGUpO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgPSAoMCwgaGl0RGV0ZWN0aW9uXzEuZ2V0VmVydGljYWxWZWxvY2l0eSkobWFpbl8xLnBsYXllcltpXS5oaXQua25vY2tiYWNrLCBuZXdBbmdsZSwgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkLCBtYWluXzEucGxheWVyW2ldLmhpdC5hbmdsZSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwbGF5ZXJbaV0ucGh5cy5rVmVsKTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua0RlYy54ID0gKDAsIGhpdERldGVjdGlvbl8xLmdldEhvcml6b250YWxEZWNheSkobmV3QW5nbGUpO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rRGVjLnkgPSAoMCwgaGl0RGV0ZWN0aW9uXzEuZ2V0VmVydGljYWxEZWNheSkobmV3QW5nbGUpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocGxheWVyW2ldLnBoeXMua0RlYyk7XG4gICAgICAgICAgICAgICAgLy9wbGF5ZXJbaV0uaGl0LmhpdHN0dW4gPSBnZXRIaXRzdHVuKHBsYXllcltpXS5oaXQua25vY2tiYWNrKTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMub25MZWRnZSA9IC0xO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jaGFyZ2VGcmFtZXMgPSAwO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5zaGllbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvKmlmIChwbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCl7XG4gICAgICAgICAgICAgICAgIGlmIChuZXdBbmdsZSA9PSAwIHx8IG5ld0FuZ2xlID4gMjcwKXtcbiAgICAgICAgICAgICAgICAgcGxheWVyW2ldLnBoeXMua1ZlbC55ID0gMDtcbiAgICAgICAgICAgICAgICAgcGxheWVyW2ldLnBoeXMua0RlYy54ID0gcGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLnRyYWN0aW9uO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld0FuZ2xlID4gMTgwKXtcbiAgICAgICAgICAgICAgICAgcGxheWVyW2ldLnBoeXMua1ZlbC55ID0gMDtcbiAgICAgICAgICAgICAgICAgcGxheWVyW2ldLnBoeXMua0RlYy54ID0gLXBsYXllcltpXS5jaGFyQXR0cmlidXRlcy50cmFjdGlvbjtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQua25vY2tiYWNrID49IDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArPSAwLjAwMDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uaGl0Lmtub2NrYmFjayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy9TREkgLyBBU0RJXG4gICAgICAgIHN3aXRjaCAobWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcIkRBTUFHRU4yXCI6XG4gICAgICAgICAgICBjYXNlIFwiREFNQUdFRkxZTlwiOlxuICAgICAgICAgICAgY2FzZSBcIkdVQVJET05cIjpcbiAgICAgICAgICAgIGNhc2UgXCJHVUFSRFwiOlxuICAgICAgICAgICAgY2FzZSBcIkRPV05EQU1BR0VcIjpcbiAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGlucHV0W2ldWzBdLmxzWCA+IDAuNyAmJiBpbnB1dFtpXVsxXS5sc1ggPCAwLjcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXRbaV1bMF0ubHNYIDwgLTAuNyAmJiBpbnB1dFtpXVsxXS5sc1ggPiAtMC43KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0W2ldWzBdLmxzWSA+IDAuNyAmJiBpbnB1dFtpXVsxXS5sc1kgPCAwLjcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXRbaV1bMF0ubHNZIDwgLTAuNyAmJiBpbnB1dFtpXVsxXS5sc1kgPiAtMC43KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoKGlucHV0W2ldWzBdLmxzWCAqIGlucHV0W2ldWzBdLmxzWCkgKyAoaW5wdXRbaV1bMF0ubHNZICogaW5wdXRbaV1bMF0ubHNZKSA8ICgwLjQ5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggKz0gaW5wdXRbaV1bMF0ubHNYICogNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKz0gbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkID8gMCA6IGlucHV0W2ldWzBdLmxzWSAqIDY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCArPSBpbnB1dFtpXVswXS5sc1ggKiAzO1xuICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKz0gbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkID8gMCA6IGlucHV0W2ldWzBdLmxzWSAqIDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5oaXQuaGl0bGFnID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiBoaXRsYWcganVzdCBlbmRlZCwgZG8gbm9ybWFsIHN0dWZmIGFzIHdlbGxcbiAgICAgICAgICAgIGhpdGxhZ1N3aXRjaFVwZGF0ZShpLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdC5zaGllbGRzdHVuID4gMCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwbGF5ZXJbaV0uaGl0LnNoaWVsZHN0dW4pO1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5oaXQuc2hpZWxkc3R1bi0tO1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGl0LnNoaWVsZHN0dW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5oaXQuc2hpZWxkc3R1biA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhhY3Rpb25TdGF0ZXNbY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bcGxheWVyW2ldLmFjdGlvblN0YXRlXSk7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jYW5XYWxsSnVtcCA9IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS53YWxsSnVtcEFibGU7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5iVHVybmFyb3VuZFRpbWVyLS07XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuYlR1cm5hcm91bmRUaW1lciA8IDApIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5iVHVybmFyb3VuZFRpbWVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlucHV0W2ldWzBdLmxzWCA+IDAuOSAmJiBpbnB1dFtpXVsxXS5sc1ggPCAwLjkpIHx8XG4gICAgICAgICAgICAoaW5wdXRbaV1bMF0ubHNYIDwgLTAuOSAmJiBpbnB1dFtpXVsxXS5sc1ggPiAtMC45KSkge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmJUdXJuYXJvdW5kVGltZXIgPSAyMDtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5iVHVybmFyb3VuZERpcmVjdGlvbiA9IE1hdGguc2lnbihpbnB1dFtpXVswXS5sc1gpO1xuICAgICAgICB9XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucHJldkFjdGlvblN0YXRlID0gbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZTtcbiAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLm1haW4oaSwgaW5wdXQpO1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5zaG9ja2VkID4gMCkge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5zaG9ja2VkLS07XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5zaG9ja2VkICUgNSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNmeF8xLnNvdW5kcy5lbGVjdHJpY2ZpenoucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGRyYXdWZnhfMS5kcmF3VmZ4KSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJzaG9ja2VkXCIsXG4gICAgICAgICAgICAgICAgcG9zOiBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIDUpLFxuICAgICAgICAgICAgICAgIGZhY2U6IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5idXJuaW5nID4gMCkge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5idXJuaW5nLS07XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5idXJuaW5nICUgNiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICgwLCBkcmF3VmZ4XzEuZHJhd1ZmeCkoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImJ1cm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIDUpLFxuICAgICAgICAgICAgICAgICAgICBmYWNlOiBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRVUkJPIE1PREVcbiAgICAgICAgLy8gaWYganVzdCBjaGFuZ2VkIGFjdGlvbiBzdGF0ZXMsIHJlbW92ZSBhYmlsaXR5IHRvIGNhbmNlbFxuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5wcmV2QWN0aW9uU3RhdGUgIT09IG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uaGFzSGl0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzXzEuZ2FtZVNldHRpbmdzLnR1cmJvICYmIG1haW5fMS5nYW1lTW9kZSAhPT0gNSkge1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uaGFzSGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgIT09IFwiQ0FUQ0hBVFRBQ0tcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIGFjdGlvblN0YXRlU2hvcnRjdXRzXzEudHVyYm9Hcm91bmRlZEludGVycnVwdCkoaSwgaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5oYXNIaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS50dXJib0FpcmJvcm5lSW50ZXJydXB0KShpLCBpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLmhhc0hpdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLmFicyhtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54KSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9TaWduID0gTWF0aC5zaWduKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLngpO1xuICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCkge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnggLT0gb1NpZ24gKiBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLnRyYWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCAtPSBtYWluXzEucGxheWVyW2ldLnBoeXMua0RlYy54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9TaWduICE9PSBNYXRoLnNpZ24obWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueCkpIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMobWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvU2lnbiA9IE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55KTtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQpIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC55ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgLT0gbWFpbl8xLnBsYXllcltpXS5waHlzLmtEZWMueTtcbiAgICAgICAgICAgIGlmIChvU2lnbiAhPT0gTWF0aC5zaWduKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkpKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmtWZWwueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54ICs9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnggKyBtYWluXzEucGxheWVyW2ldLnBoeXMua1ZlbC54O1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKz0gbWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueSArIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnk7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gaHVydEJveFN0YXRlVXBkYXRlKGkpIHtcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9PT0gXCJSRUJJUlRIXCIgfHwgbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9PT0gXCJSRUJJUlRIV0FJVFwiKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmh1cnRCb3hTdGF0ZSA9IDA7XG4gICAgfVxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuaW52aW5jaWJsZVRpbWVyID4gMCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaW52aW5jaWJsZVRpbWVyLS07XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Qm94U3RhdGUgPSAyO1xuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmludGFuZ2libGVUaW1lciA+IDApIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmludGFuZ2libGVUaW1lci0tO1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlID0gMTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBvdXRPZkNhbWVyYVVwZGF0ZShpKSB7XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vdXRPZkNhbWVyYVRpbWVyID49IDYwKSB7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBlcmNlbnQgPCAxNTApIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGVyY2VudCsrO1xuICAgICAgICB9XG4gICAgICAgICgwLCBtYWluXzEucGVyY2VudFNoYWtlKSg0MCwgaSk7XG4gICAgICAgIHNmeF8xLnNvdW5kcy5vdXRvZmNhbWVyYS5wbGF5KCk7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vdXRPZkNhbWVyYVRpbWVyID0gMDtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBsQ2FuY2VsVXBkYXRlKGksIGlucHV0KSB7XG4gICAgLy8gaWYgc21hc2ggNjQgbGNhbmNlbCwgcHV0IGFueSBsYW5kaW5nYXR0YWNrYWlyIGFjdGlvbiBzdGF0ZXMgaW50byBsYW5kaW5nXG4gICAgaWYgKHNldHRpbmdzXzEuZ2FtZVNldHRpbmdzLmxDYW5jZWxUeXBlID09PSAyICYmIG1haW5fMS5nYW1lTW9kZSAhPT0gNSkge1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmxDYW5jZWwpIHtcbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlLnN1YnN0cigwLCAxNikgPT09IFwiTEFORElOR0FUVEFDS0FJUlwiKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9IFwiTEFORElOR1wiO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0udGltZXIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbFRpbWVyID4gMCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbFRpbWVyLS07XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbFRpbWVyID09PSAwKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMubENhbmNlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGwgQ0FOQ0VMXG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sQ2FuY2VsVGltZXIgPT09IDAgJiZcbiAgICAgICAgKChpbnB1dFtpXVswXS5sQSA+IDAgJiYgaW5wdXRbaV1bMV0ubEEgPT09IDApIHx8XG4gICAgICAgICAgICAoaW5wdXRbaV1bMF0uckEgPiAwICYmIGlucHV0W2ldWzFdLnJBID09PSAwKSB8fFxuICAgICAgICAgICAgKGlucHV0W2ldWzBdLnogJiYgIWlucHV0W2ldWzFdLnopKSkge1xuICAgICAgICAvLyBpZiBzbWFzaCA2NCBsY2FuY2VsLCBpbmNyZWFzZSB3aW5kb3cgdG8gMTEgZnJhbWVzXG4gICAgICAgIGlmIChzZXR0aW5nc18xLmdhbWVTZXR0aW5ncy5sQ2FuY2VsVHlwZSA9PT0gMiAmJiBtYWluXzEuZ2FtZU1vZGUgIT09IDUpIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sQ2FuY2VsVGltZXIgPSAxMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sQ2FuY2VsVGltZXIgPSA3O1xuICAgICAgICB9XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sQ2FuY2VsID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgYXV0byBsY2FuY2VsIGlzIG9uLCBhbHdheXMgbGNhbmNlbFxuICAgIGlmIChzZXR0aW5nc18xLmdhbWVTZXR0aW5ncy5sQ2FuY2VsVHlwZSA9PT0gMSAmJiBtYWluXzEuZ2FtZU1vZGUgIT09IDUpIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmxDYW5jZWwgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBWIENhbmNlbFxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMudkNhbmNlbFRpbWVyID4gMCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMudkNhbmNlbFRpbWVyLS07XG4gICAgfVxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMudGVjaFRpbWVyID4gMCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMudGVjaFRpbWVyLS07XG4gICAgfVxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuc2hvdWxkZXJMb2Nrb3V0ID4gMCkge1xuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuc2hvdWxkZXJMb2Nrb3V0LS07XG4gICAgfVxuICAgIGlmICgoaW5wdXRbaV1bMF0ubCAmJiAhaW5wdXRbaV1bMV0ubCkgfHxcbiAgICAgICAgKGlucHV0W2ldWzBdLnIgJiYgIWlucHV0W2ldWzFdLnIpKSB7XG4gICAgICAgIGlmICghbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnNob3VsZGVyTG9ja291dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy52Q2FuY2VsVGltZXIgPSAzO1xuICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy50ZWNoVGltZXIgPSAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuc2hvdWxkZXJMb2Nrb3V0ID0gNDA7XG4gICAgfVxufVxuO1xuY29uc3QgbnVsbFNxdWFzaERhdHVtID0geyBsb2NhdGlvbjogbnVsbCwgZmFjdG9yOiAxIH07XG5jb25zdCBlY2JTcXVhc2hEYXRhID0gW251bGxTcXVhc2hEYXR1bSxcbiAgICBudWxsU3F1YXNoRGF0dW0sXG4gICAgbnVsbFNxdWFzaERhdHVtLFxuICAgIG51bGxTcXVhc2hEYXR1bV07XG5mdW5jdGlvbiBmaW5kQW5kUmVzb2x2ZUNvbGxpc2lvbnMoaSwgaW5wdXQsIG9sZEJhY2t3YXJkLCBvbGROb3RUb3VjaGluZ1dhbGxzLCBlY2JPZmZzZXQpIHtcbiAgICBsZXQgc3RpbGxHcm91bmRlZCA9IHRydWU7XG4gICAgbGV0IGJhY2t3YXJkID0gb2xkQmFja3dhcmQ7XG4gICAgY29uc3Qgbm90VG91Y2hpbmdXYWxscyA9IG9sZE5vdFRvdWNoaW5nV2FsbHM7XG4gICAgY29uc3QgY29ubmVjdGVkID0gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5jb25uZWN0ZWQ7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ3JvdW5kZWQgc3RhdGUgbW92ZW1lbnRcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkpO1xuICAgICAgICBjb25zdCByZWxldmFudEdyb3VuZEluZGV4ID0gbWFpbl8xLnBsYXllcltpXS5waHlzLm9uU3VyZmFjZVsxXTtcbiAgICAgICAgbGV0IHJlbGV2YW50R3JvdW5kVHlwZSA9IFwiZ1wiO1xuICAgICAgICBsZXQgcmVsZXZhbnRHcm91bmQgPSBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmdyb3VuZFtyZWxldmFudEdyb3VuZEluZGV4XTtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vblN1cmZhY2VbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIHJlbGV2YW50R3JvdW5kVHlwZSA9IFwicFwiO1xuICAgICAgICAgICAgcmVsZXZhbnRHcm91bmQgPSBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLnBsYXRmb3JtW3JlbGV2YW50R3JvdW5kSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbGV2YW50R3JvdW5kVHlwZUFuZEluZGV4ID0gW3JlbGV2YW50R3JvdW5kVHlwZSwgcmVsZXZhbnRHcm91bmRJbmRleF07XG4gICAgICAgIFtzdGlsbEdyb3VuZGVkLCBiYWNrd2FyZF0gPSBkZWFsV2l0aEdyb3VuZChpLCByZWxldmFudEdyb3VuZCwgcmVsZXZhbnRHcm91bmRUeXBlQW5kSW5kZXgsIGNvbm5lY3RlZCwgaW5wdXQpO1xuICAgIH1cbiAgICAvLyBlbmQgb2YgZ3JvdW5kZWQgc3RhdGUgbW92ZW1lbnRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBtYWluIGNvbGxpc2lvbiBkZXRlY3Rpb24gcm91dGluZVxuICAgIGNvbnN0IG5vdElnbm9yaW5nUGxhdGZvcm1zID0gKCghYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmNhblBhc3NUaHJvdWdoIHx8IChpbnB1dFtpXVswXS5sc1kgPiAtMC41NikpICYmICFtYWluXzEucGxheWVyW2ldLnBoeXMucGFzc2luZyk7XG4gICAgY29uc3QgaXNJbW11bmUgPSBtYWluXzEucGxheWVyW2ldLnBoeXMuaHVydEJveFN0YXRlICE9PSAwO1xuICAgIGNvbnN0IHBsYXllclN0YXR1c0luZm8gPSB7XG4gICAgICAgIGlnbm9yaW5nUGxhdGZvcm1zOiAhbm90SWdub3JpbmdQbGF0Zm9ybXMsXG4gICAgICAgIGdyb3VuZGVkOiBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQsXG4gICAgICAgIGltbXVuZTogaXNJbW11bmVcbiAgICB9O1xuICAgIC8vIHR5cGUgQ29sbGlzaW9uUm91dGluZVJlc3VsdCA9IHsgcG9zaXRpb24gOiBWZWMyRCwgdG91Y2hpbmcgOiBudWxsIHwgU2ltcGxlVG91Y2hpbmdEYXR1bSwgc3F1YXNoRGF0dW0gOiBTcXVhc2hEYXR1bSwgZWNiIDogRUNCfTtcbiAgICBjb25zdCBjb2xsaXNpb25EYXRhID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5ydW5Db2xsaXNpb25Sb3V0aW5lKShtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCMSwgbWFpbl8xLnBsYXllcltpXS5waHlzLkVDQnAsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MsIGVjYlNxdWFzaERhdGFbaV0sIHBsYXllclN0YXR1c0luZm8sIGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UpO1xuICAgIGVjYlNxdWFzaERhdGFbaV0gPSBjb2xsaXNpb25EYXRhLnNxdWFzaERhdHVtO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gY29sbGlzaW9uRGF0YS5wb3NpdGlvbjtcbiAgICBjb25zdCBuZXdFQ0IgPSBjb2xsaXNpb25EYXRhLmVjYjtcbiAgICBjb25zdCB0b3VjaGluZ0RhdHVtID0gY29sbGlzaW9uRGF0YS50b3VjaGluZztcbiAgICBpZiAodG91Y2hpbmdEYXR1bSA9PT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVQb3NpdGlvbihpLCBuZXdQb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRvdWNoaW5nRGF0dW0ua2luZCA9PT0gXCJzdXJmYWNlXCIpIHtcbiAgICAgICAgY29uc3Qgc3VyZmFjZUxhYmVsID0gdG91Y2hpbmdEYXR1bS50eXBlO1xuICAgICAgICBjb25zdCBzdXJmYWNlSW5kZXggPSB0b3VjaGluZ0RhdHVtLmluZGV4O1xuICAgICAgICBjb25zdCBwdCA9IHRvdWNoaW5nRGF0dW0ucHQ7XG4gICAgICAgIHN3aXRjaCAoc3VyZmFjZUxhYmVsWzBdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsXCI6IC8vIHBsYXllciB0b3VjaGluZyBsZWZ0IHdhbGxcbiAgICAgICAgICAgICAgICBub3RUb3VjaGluZ1dhbGxzWzBdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVhbFdpdGhXYWxsQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBwdCwgXCJsXCIsIHN1cmZhY2VJbmRleCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJcIjogLy8gcGxheWVyIHRvdWNoaW5nIHJpZ2h0IHdhbGxcbiAgICAgICAgICAgICAgICBub3RUb3VjaGluZ1dhbGxzWzFdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVhbFdpdGhXYWxsQ29sbGlzaW9uKGksIG5ld1Bvc2l0aW9uLCBwdCwgXCJyXCIsIHN1cmZhY2VJbmRleCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdcIjogLy8gcGxheWVyIGxhbmRlZCBvbiBncm91bmRcbiAgICAgICAgICAgICAgICBkZWFsV2l0aEdyb3VuZENvbGxpc2lvbihpLCBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQsIG5ld1Bvc2l0aW9uLCBuZXdFQ0JbMF0sIHN1cmZhY2VJbmRleCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNcIjogLy8gcGxheWVyIHRvdWNoaW5nIGNlaWxpbmdcbiAgICAgICAgICAgICAgICBkZWFsV2l0aENlaWxpbmdDb2xsaXNpb24oaSwgbmV3UG9zaXRpb24sIG5ld0VDQlsyXSwgc3VyZmFjZUluZGV4LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicFwiOiAvLyBwbGF5ZXIgbGFuZGVkIG9uIHBsYXRmb3JtXG4gICAgICAgICAgICAgICAgZGVhbFdpdGhQbGF0Zm9ybUNvbGxpc2lvbihpLCBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQsIG5ld1Bvc2l0aW9uLCBuZXdFQ0JbMF0sIHN1cmZhY2VJbmRleCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIGluICdmaW5kQW5kUmVzb2x2ZUNvbGxpc2lvbnMnOiB1bnJlY29nbmlzZWQgc3VyZmFjZSB0eXBlLlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0b3VjaGluZ0RhdHVtLmtpbmQgPT09IFwiY29ybmVyXCIpIHtcbiAgICAgICAgY29uc3QgYW5ndWxhclBhcmFtZXRlciA9IHRvdWNoaW5nRGF0dW0uYW5ndWxhcjtcbiAgICAgICAgY29uc3QgY29ybmVyRGFtYWdlVHlwZSA9IHRvdWNoaW5nRGF0dW0uZGFtYWdlVHlwZSAhPT0gdW5kZWZpbmVkID8gdG91Y2hpbmdEYXR1bS5kYW1hZ2VUeXBlIDogbnVsbDtcbiAgICAgICAgZGVhbFdpdGhDb3JuZXJDb2xsaXNpb24oaSwgbmV3UG9zaXRpb24sIG5ld0VDQiwgYW5ndWxhclBhcmFtZXRlciwgY29ybmVyRGFtYWdlVHlwZSk7XG4gICAgfVxuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0IxID0gbmV3RUNCO1xuICAgIC8vIGZpbmFsbHksIGNhbGN1bGF0ZSBob3cgbXVjaCBzcXVhc2hpbmcgaXMgcmVxdWlyZWQgYnkgdGhlIGdyb3VuZFxuICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQpIHtcbiAgICAgICAgY29uc3QgZ3JvdW5kU3F1YXNoRmFjdG9yID0gKDAsIGVudmlyb25tZW50YWxDb2xsaXNpb25fMS5ncm91bmRlZEVDQlNxdWFzaEZhY3RvcikobmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyBlY2JPZmZzZXRbM10pIC8vICAgIHRvcCBub24tc3F1YXNoZWQgRUNCcCBwb2ludFxuICAgICAgICAsIG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55KSAvLyBib3R0b20gbm9uLXNxdWFzaGVkIEVDQnAgcG9pbnQsIG5vIG9mZnNldCBhcyBncm91bmRlZFxuICAgICAgICAsICgwLCB0b0xpc3RfMS50b0xpc3QpKGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuY2VpbGluZykpO1xuICAgICAgICBpZiAoZ3JvdW5kU3F1YXNoRmFjdG9yICE9PSBudWxsICYmIChncm91bmRTcXVhc2hGYWN0b3IgPCBlY2JTcXVhc2hEYXRhW2ldLmZhY3RvcikpIHtcbiAgICAgICAgICAgIGVjYlNxdWFzaERhdGFbaV0gPSB7IGxvY2F0aW9uOiAwLCBmYWN0b3I6IGdyb3VuZFNxdWFzaEZhY3RvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlY2JTcXVhc2hEYXRhW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICBlY2JTcXVhc2hEYXRhW2ldLmxvY2F0aW9uID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkLCBub3RUb3VjaGluZ1dhbGxzXTtcbn1cbjtcbmZ1bmN0aW9uIGRlYWxXaXRoTGVkZ2VzKGksIGlucHV0KSB7XG4gICAgY29uc3QgcGxheWVyUG9zWCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueDtcbiAgICBjb25zdCBwbGF5ZXJQb3NZID0gbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55O1xuICAgIC8vVE9ETyBmaW5kIG91dCB3aGF0IHRoZXNlIG1hZ2ljIG51bWJlcnMgYXJlXG4gICAgY29uc3QgbGVkZ2VTbmFwQm94T2Zmc2V0MiA9IG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMubGVkZ2VTbmFwQm94T2Zmc2V0WzJdO1xuICAgIGNvbnN0IGxlZGdlU25hcEJveE9mZnNldDAgPSBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLmxlZGdlU25hcEJveE9mZnNldFswXTtcbiAgICBjb25zdCBsZWRnZVNuYXBCb3hPZmZzZXQxID0gbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5sZWRnZVNuYXBCb3hPZmZzZXRbMV07XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEYgPSBuZXcgQm94MkRfMS5Cb3gyRChbcGxheWVyUG9zWCwgcGxheWVyUG9zWSArIGxlZGdlU25hcEJveE9mZnNldDJdLCBbcGxheWVyUG9zWCArIGxlZGdlU25hcEJveE9mZnNldDAsIHBsYXllclBvc1kgKyBsZWRnZVNuYXBCb3hPZmZzZXQxXSk7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEIgPSBuZXcgQm94MkRfMS5Cb3gyRChbcGxheWVyUG9zWCAtIGxlZGdlU25hcEJveE9mZnNldDAsIHBsYXllclBvc1kgKyBsZWRnZVNuYXBCb3hPZmZzZXQyXSwgW3BsYXllclBvc1gsIHBsYXllclBvc1kgKyBsZWRnZVNuYXBCb3hPZmZzZXQxXSk7XG4gICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVJlZ3JhYkNvdW50KSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVJlZ3JhYlRpbWVvdXQtLTtcbiAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVJlZ3JhYlRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVJlZ3JhYkNvdW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGxzQkYgPSAtMTtcbiAgICBsZXQgbHNCQiA9IC0xO1xuICAgIGxldCBmb3VuZExlZGdlID0gMDtcbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLm9uTGVkZ2UgPT09IC0xICYmICFtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VSZWdyYWJDb3VudCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBsZWRnZUF2YWlsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDQ7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyVHlwZVtrXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltrXS5waHlzLm9uTGVkZ2UgPT09IGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWRnZUF2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZGdlQXZhaWxhYmxlICYmICFtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQgJiYgbWFpbl8xLnBsYXllcltpXS5oaXQuaGl0c3R1biA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2VbYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVswXV1bYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVsxXV1bYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVsyXV0ueDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZVthY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmxlZGdlW2pdWzBdXVthY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmxlZGdlW2pdWzFdXVthY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmxlZGdlW2pdWzJdXS55O1xuICAgICAgICAgICAgICAgIGlmICh4ID4gbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEYubWluLnggJiZcbiAgICAgICAgICAgICAgICAgICAgeCA8IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hGLm1heC54ICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPCBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VTbmFwQm94Ri5taW4ueSAmJlxuICAgICAgICAgICAgICAgICAgICB5ID4gbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEYubWF4LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UubGVkZ2Vbal1bMl0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uY2FuR3JhYkxlZGdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHNCRiA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmNhbkdyYWJMZWRnZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbHNCRiA9IGo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPiBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VTbmFwQm94Qi5taW4ueCAmJlxuICAgICAgICAgICAgICAgICAgICB4IDwgbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlU25hcEJveEIubWF4LnggJiZcbiAgICAgICAgICAgICAgICAgICAgeSA8IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVNuYXBCb3hCLm1pbi55ICYmXG4gICAgICAgICAgICAgICAgICAgIHkgPiBtYWluXzEucGxheWVyW2ldLnBoeXMubGVkZ2VTbmFwQm94Ri5tYXgueSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtqXVsyXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5jYW5HcmFiTGVkZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsc0JCID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uY2FuR3JhYkxlZGdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsc0JCID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC55IDwgMCAmJiBpbnB1dFtpXVswXS5sc1kgPiAtMC41KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxzQkYgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZExlZGdlID0gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5sZWRnZVtsc0JGXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kTGVkZ2VbMl0gKiAtMiArIDEgPT09IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlIHx8IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5jYW5HcmFiTGVkZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vbkxlZGdlID0gbHNCRjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5sZWRnZVJlZ3JhYlRpbWVvdXQgPSAzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlID0gZm91bmRMZWRnZVsyXSAqIC0yICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MgPSBuZXcgVmVjMkRfMS5WZWMyRChhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlW2ZvdW5kTGVkZ2VbMF1dW2ZvdW5kTGVkZ2VbMV1dW2ZvdW5kTGVkZ2VbMl1dLnggKyBtYWluXzEuZWRnZU9mZnNldFswXVswXSwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZVtmb3VuZExlZGdlWzBdXVtmb3VuZExlZGdlWzFdXVtmb3VuZExlZGdlWzJdXS55ICsgbWFpbl8xLmVkZ2VPZmZzZXRbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLkNMSUZGQ0FUQ0guaW5pdChpLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobHNCQiA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTGVkZ2UgPSBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLmxlZGdlW2xzQkJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRMZWRnZVsyXSAqIC0yICsgMSA9PT0gbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgfHwgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmNhbkdyYWJMZWRnZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLm9uTGVkZ2UgPSBsc0JCO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmxlZGdlUmVncmFiVGltZW91dCA9IDMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2UgPSBmb3VuZExlZGdlWzJdICogLTIgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcyA9IG5ldyBWZWMyRF8xLlZlYzJEKGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2VbZm91bmRMZWRnZVswXV1bZm91bmRMZWRnZVsxXV1bZm91bmRMZWRnZVsyXV0ueCArIG1haW5fMS5lZGdlT2Zmc2V0WzFdWzBdLCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlW2ZvdW5kTGVkZ2VbMF1dW2ZvdW5kTGVkZ2VbMV1dW2ZvdW5kTGVkZ2VbMl1dLnkgKyBtYWluXzEuZWRnZU9mZnNldFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uQ0xJRkZDQVRDSC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIGRlYWxXaXRoRGVhdGgoaSwgaW5wdXQpIHtcbiAgICBpZiAoIWFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5kZWFkICYmIG1haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGUgIT09IFwiU0xFRVBcIikge1xuICAgICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54IDwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5ibGFzdHpvbmUubWluLngpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJERUFETEVGVFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA+IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuYmxhc3R6b25lLm1heC54KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiREVBRFJJR0hUXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55IDwgYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5ibGFzdHpvbmUubWluLnkpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJERUFERE9XTlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSA+IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuYmxhc3R6b25lLm1heC55ICYmIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkgPj0gMi40KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiREVBRFVQXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlICE9PSAwKSB7XG4gICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMub3V0T2ZDYW1lcmFUaW1lciA9IDA7XG4gICAgICAgICAgICAoMCwgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS50dXJuT2ZmSGl0Ym94ZXMpKGkpO1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5zdG9ja3MtLTtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0uY29sb3VyT3ZlcmxheUJvb2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJlbmRlcl8xLmxvc3RTdG9ja1F1ZXVlLnB1c2goW2ksIG1haW5fMS5wbGF5ZXJbaV0uc3RvY2tzLCAwXSk7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5zdG9ja3MgPT09IDAgJiYgbWFpbl8xLnZlcnN1c01vZGUpIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnN0b2NrcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bc3RhdGVdLmluaXQoaSwgaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gdXBkYXRlSGl0Ym94ZXMoaSkge1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5pc0ludGVycG9sYXRlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmFjdGl2ZVtqXSAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMucHJldkZyYW1lSGl0Ym94ZXMuYWN0aXZlW2pdKSB7XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmlkW2pdLm9mZnNldFttYWluXzEucGxheWVyW2ldLnBoeXMucHJldkZyYW1lSGl0Ym94ZXMuZnJhbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmlkW2pdLm9mZnNldFttYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmZyYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoMSA9IG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3NQcmV2LnggKyAobWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmlkW2pdLm9mZnNldFttYWluXzEucGxheWVyW2ldLnBoeXMucHJldkZyYW1lSGl0Ym94ZXMuZnJhbWVdLnggKiBtYWluXzEucGxheWVyW2ldLnBoeXMuZmFjZVByZXYpLCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zUHJldi55ICsgbWFpbl8xLnBsYXllcltpXS5waHlzLnByZXZGcmFtZUhpdGJveGVzLmlkW2pdLm9mZnNldFttYWluXzEucGxheWVyW2ldLnBoeXMucHJldkZyYW1lSGl0Ym94ZXMuZnJhbWVdLnkpO1xuICAgICAgICAgICAgY29uc3QgaDIgPSBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggKyAobWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5pZFtqXS5vZmZzZXRbbWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5mcmFtZV0ueCAqIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlKSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgbWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5pZFtqXS5vZmZzZXRbbWFpbl8xLnBsYXllcltpXS5oaXRib3hlcy5mcmFtZV0ueSk7XG4gICAgICAgICAgICBjb25zdCBhID0gaDIueCAtIGgxLng7XG4gICAgICAgICAgICBjb25zdCBiID0gaDIueSAtIGgxLnk7XG4gICAgICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgICAgICBpZiAoIShhID09PSAwIHx8IGIgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGguYXRhbihNYXRoLmFicyhhKSAvIE1hdGguYWJzKGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHAgPSBNYXRoLnNpbih4KSAqIG1haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuaWRbal0uc2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGogPSBNYXRoLmNvcyh4KSAqIG1haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuaWRbal0uc2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWdtYSA9IFtoMS54LCBoMS55XTtcbiAgICAgICAgICAgICAgICBsZXQgYWxwaGExO1xuICAgICAgICAgICAgICAgIGxldCBhbHBoYTI7XG4gICAgICAgICAgICAgICAgbGV0IGJldGExO1xuICAgICAgICAgICAgICAgIGxldCBiZXRhMjtcbiAgICAgICAgICAgICAgICBpZiAoKGEgPiAwICYmIGIgPiAwKSB8fCAoYSA8PSAwICYmIGIgPD0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbmV3IFZlYzJEXzEuVmVjMkQoKHNpZ21hWzBdICsgYWRqKSwgKHNpZ21hWzFdIC0gb3BwKSk7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IG5ldyBWZWMyRF8xLlZlYzJEKChhbHBoYTEueCArIGEpLCAoYWxwaGExLnkgKyBiKSk7XG4gICAgICAgICAgICAgICAgICAgIGJldGExID0gbmV3IFZlYzJEXzEuVmVjMkQoKHNpZ21hWzBdIC0gYWRqKSwgKHNpZ21hWzFdICsgb3BwKSk7XG4gICAgICAgICAgICAgICAgICAgIGJldGEyID0gbmV3IFZlYzJEXzEuVmVjMkQoKGJldGExLnggKyBhKSwgKGJldGExLnkgKyBiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBuZXcgVmVjMkRfMS5WZWMyRCgoc2lnbWFbMF0gLSBhZGopLCAoc2lnbWFbMV0gLSBvcHApKTtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gbmV3IFZlYzJEXzEuVmVjMkQoKGFscGhhMS54ICsgYSksIChhbHBoYTEueSArIGIpKTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YTEgPSBuZXcgVmVjMkRfMS5WZWMyRCgoc2lnbWFbMF0gKyBhZGopLCAoc2lnbWFbMV0gKyBvcHApKTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YTIgPSBuZXcgVmVjMkRfMS5WZWMyRCgoYmV0YTEueCArIGEpLCAoYmV0YTEueSArIGIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmludGVyUG9sYXRlZEhpdGJveFtqXSA9IFthbHBoYTEsIGFscGhhMiwgYmV0YTIsIGJldGExXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHAgPSBNYXRoLnNpbih4KSAqIG1haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMuaWRbal0uc2l6ZSAtIHNldHRpbmdzXzEuZ2FtZVNldHRpbmdzLnBoYW50b21UaHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqID0gTWF0aC5jb3MoeCkgKiBtYWluXzEucGxheWVyW2ldLmhpdGJveGVzLmlkW2pdLnNpemUgLSBzZXR0aW5nc18xLmdhbWVTZXR0aW5ncy5waGFudG9tVGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ21hID0gW2gxLngsIGgxLnldO1xuICAgICAgICAgICAgICAgIGxldCBhbHBoYTE7XG4gICAgICAgICAgICAgICAgbGV0IGFscGhhMjtcbiAgICAgICAgICAgICAgICBsZXQgYmV0YTE7XG4gICAgICAgICAgICAgICAgbGV0IGJldGEyO1xuICAgICAgICAgICAgICAgIGlmICgoYSA+IDAgJiYgYiA+IDApIHx8IChhIDw9IDAgJiYgYiA8PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBuZXcgVmVjMkRfMS5WZWMyRCgoc2lnbWFbMF0gKyBhZGopLCAoc2lnbWFbMV0gLSBvcHApKTtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gbmV3IFZlYzJEXzEuVmVjMkQoKGFscGhhMS54ICsgYSksIChhbHBoYTEueSArIGIpKTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YTEgPSBuZXcgVmVjMkRfMS5WZWMyRCgoc2lnbWFbMF0gLSBhZGopLCAoc2lnbWFbMV0gKyBvcHApKTtcbiAgICAgICAgICAgICAgICAgICAgYmV0YTIgPSBuZXcgVmVjMkRfMS5WZWMyRCgoYmV0YTEueCArIGEpLCAoYmV0YTEueSArIGIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IG5ldyBWZWMyRF8xLlZlYzJEKChzaWdtYVswXSAtIGFkaiksIChzaWdtYVsxXSAtIG9wcCkpO1xuICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBuZXcgVmVjMkRfMS5WZWMyRCgoYWxwaGExLnggKyBhKSwgKGFscGhhMS55ICsgYikpO1xuICAgICAgICAgICAgICAgICAgICBiZXRhMSA9IG5ldyBWZWMyRF8xLlZlYzJEKChzaWdtYVswXSArIGFkaiksIChzaWdtYVsxXSArIG9wcCkpO1xuICAgICAgICAgICAgICAgICAgICBiZXRhMiA9IG5ldyBWZWMyRF8xLlZlYzJEKChiZXRhMS54ICsgYSksIChiZXRhMS55ICsgYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaW50ZXJQb2xhdGVkSGl0Ym94UGhhbnRvbVtqXSA9IFthbHBoYTEsIGFscGhhMiwgYmV0YTIsIGJldGExXTtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuaXNJbnRlcnBvbGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gcGh5c2ljcyhpLCBpbnB1dCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wYXNzaW5nID0gZmFsc2U7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvc1ByZXYgPSBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSk7XG4gICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2VQcmV2ID0gbWFpbl8xLnBsYXllcltpXS5waHlzLmZhY2U7XG4gICAgKDAsIGRlZXBDb3B5T2JqZWN0XzEuZGVlcE9iamVjdE1lcmdlKSh0cnVlLCBtYWluXzEucGxheWVyW2ldLnBoeXMucHJldkZyYW1lSGl0Ym94ZXMsIG1haW5fMS5wbGF5ZXJbaV0uaGl0Ym94ZXMpO1xuICAgIGhpdGxhZ1N3aXRjaFVwZGF0ZShpLCBpbnB1dCk7XG4gICAgaHVydEJveFN0YXRlVXBkYXRlKGkpO1xuICAgIG91dE9mQ2FtZXJhVXBkYXRlKGkpO1xuICAgIGxDYW5jZWxVcGRhdGUoaSwgaW5wdXQpO1xuICAgIGlmICghbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5haXJib3JuZVRpbWVyKys7XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2cocGxheWVyW2ldLnRpbWVyKTtcbiAgICBsZXQgZnJhbWUgPSBNYXRoLmZsb29yKG1haW5fMS5wbGF5ZXJbaV0udGltZXIpO1xuICAgIGlmIChmcmFtZSA9PT0gMCkge1xuICAgICAgICBmcmFtZSA9IDE7XG4gICAgfVxuICAgIGlmIChmcmFtZSA+IGNoYXJhY3RlcnNfMS5mcmFtZXNEYXRhW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXSkge1xuICAgICAgICBmcmFtZSA9IGNoYXJhY3RlcnNfMS5mcmFtZXNEYXRhW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXTtcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhhY3Rpb25TdGF0ZXNbY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bcGxheWVyW2ldLmFjdGlvblN0YXRlXS5uYW1lK1wiIFwiKyhmcmFtZS0xKSk7XG4gICAgLyogZ2xvYmFsIGVjYiAqL1xuICAgIHZhciBlY2I7XG4gICAgY29uc3QgZWNiT2Zmc2V0ID0gYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmRlYWQgPyBbMCwgMCwgMCwgMF0gOiBbZWNiW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXVtmcmFtZSAtIDFdWzBdICogbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5lY2JTY2FsZSwgZWNiW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXVtmcmFtZSAtIDFdWzFdICogbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5lY2JTY2FsZSwgZWNiW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXVtmcmFtZSAtIDFdWzJdICogbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5lY2JTY2FsZSwgZWNiW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXVtmcmFtZSAtIDFdWzNdICogbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5lY2JTY2FsZV07XG4gICAgY29uc3QgcGxheWVyUG9zWCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueDtcbiAgICBjb25zdCBwbGF5ZXJQb3NZID0gbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55O1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwID0gW1xuICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArICgobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkIHx8IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5haXJib3JuZVRpbWVyIDwgMTApID8gMCA6IGVjYk9mZnNldFswXSkpLFxuICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggKyBNYXRoLm1heCgxLCBlY2JPZmZzZXRbMV0pLCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyBlY2JPZmZzZXRbMl0pLFxuICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLngsIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueSArIGVjYk9mZnNldFszXSksXG4gICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCAtIGVjYk9mZnNldFsxXSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgZWNiT2Zmc2V0WzJdKVxuICAgIF07XG4gICAgaWYgKGVjYlNxdWFzaERhdGFbaV0gIT09IG51bGwgJiYgZWNiU3F1YXNoRGF0YVtpXS5mYWN0b3IgPCAxKSB7XG4gICAgICAgIGlmIChlY2JTcXVhc2hEYXRhW2ldLmZhY3RvciAqIDIgKiBlY2JPZmZzZXRbMV0gPCBlbnZpcm9ubWVudGFsQ29sbGlzaW9uXzEuc21hbGxlc3RFQ0JXaWR0aCkge1xuICAgICAgICAgICAgZWNiU3F1YXNoRGF0YVtpXS5mYWN0b3IgPSAoZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLnNtYWxsZXN0RUNCV2lkdGggKyAyICogZW52aXJvbm1lbnRhbENvbGxpc2lvbl8xLmFkZGl0aW9uYWxPZmZzZXQpIC8gKDIgKiBlY2JPZmZzZXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwID0gKDAsIGVjYlRyYW5zZm9ybV8xLnNxdWFzaEVDQkF0KShtYWluXzEucGxheWVyW2ldLnBoeXMuRUNCcCwgeyBmYWN0b3I6IGVjYlNxdWFzaERhdGFbaV0uZmFjdG9yLCBsb2NhdGlvbjogMCB9KTtcbiAgICAgICAgaWYgKCFtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQpIHtcbiAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwID0gKDAsIGVjYlRyYW5zZm9ybV8xLm1vdmVFQ0IpKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0JwLCBuZXcgVmVjMkRfMS5WZWMyRCgwLCAoZWNiU3F1YXNoRGF0YVtpXS5mYWN0b3IgLSAxKSAqIGVjYk9mZnNldFswXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW21haW5fMS5wbGF5ZXJbaV0uYWN0aW9uU3RhdGVdLmlnbm9yZUNvbGxpc2lvbikge1xuICAgICAgICBsZXQgbm90VG91Y2hpbmdXYWxscyA9IFt0cnVlLCB0cnVlXTtcbiAgICAgICAgbGV0IHN0aWxsR3JvdW5kZWQgPSB0cnVlO1xuICAgICAgICBsZXQgYmFja3dhcmQgPSBmYWxzZTtcbiAgICAgICAgW3N0aWxsR3JvdW5kZWQsIGJhY2t3YXJkLCBub3RUb3VjaGluZ1dhbGxzXSA9IGZpbmRBbmRSZXNvbHZlQ29sbGlzaW9ucyhpLCBpbnB1dCwgYmFja3dhcmQsIG5vdFRvdWNoaW5nV2FsbHMsIGVjYk9mZnNldCk7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJlZEJ5ID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKG5vdFRvdWNoaW5nV2FsbHNbMF0gJiYgbm90VG91Y2hpbmdXYWxsc1sxXSAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuY2FuV2FsbEp1bXApIHtcbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMud2FsbEp1bXBUaW1lciA9IDI1NDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm90VG91Y2hpbmdXYWxsc1swXSB8fCAhbm90VG91Y2hpbmdXYWxsc1sxXSkge1xuICAgICAgICAgICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JvdW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vblN1cmZhY2VbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1cmZhY2UgPSBtYWluXzEucGxheWVyW2ldLnBoeXMub25TdXJmYWNlWzBdID8gYWN0aXZlU3RhZ2VfMS5hY3RpdmVTdGFnZS5wbGF0Zm9ybVtzXSA6IGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2UuZ3JvdW5kW3NdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54IDwgc3VyZmFjZVswXS54IC0gMC4xIHx8IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCA+IHN1cmZhY2VbMV0ueCArIDAuMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RpbGxHcm91bmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGlsbEdyb3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV1bbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZV0uYWlyYm9ybmVTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5haXJib3JuZVN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvblN0YXRlU2hvcnRjdXRzXzEuYWN0aW9uU3RhdGVzW21haW5fMS5jaGFyYWN0ZXJTZWxlY3Rpb25zW2ldXVttYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlXS5taXNzZm9vdCAmJiBiYWNrd2FyZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uU3RhdGVTaG9ydGN1dHNfMS5hY3Rpb25TdGF0ZXNbbWFpbl8xLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dLk1JU1NGT09ULmluaXQoaSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncmFiYmluZyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1ttYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJpbmddXS5GQUxMLmluaXQobWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiaW5nLCBpbnB1dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllclttYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJpbmddLnBoeXMuZ3JhYmJlZEJ5ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLmdyYWJiaW5nID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1ttYWluXzEuY2hhcmFjdGVyU2VsZWN0aW9uc1tpXV0uRkFMTC5pbml0KGksIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobWFpbl8xLnBsYXllcltpXS5waHlzLmNWZWwueCkgPiBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLmFlcmlhbEhtYXhWKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54ID0gTWF0aC5zaWduKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLngpICogbWFpbl8xLnBsYXllcltpXS5jaGFyQXR0cmlidXRlcy5hZXJpYWxIbWF4VjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2ldLnBoeXMuc2hpZWxkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLmdyb3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJUeXBlW2pdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbal0ucGh5cy5ncm91bmRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2pdLnBoeXMub25TdXJmYWNlWzBdID09PSBtYWluXzEucGxheWVyW2ldLnBoeXMub25TdXJmYWNlWzBdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fMS5wbGF5ZXJbal0ucGh5cy5vblN1cmZhY2VbMV0gPT09IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5vblN1cmZhY2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncmFiYmluZyAhPT0gaiAmJiBtYWluXzEucGxheWVyW2ldLnBoeXMuZ3JhYmJlZEJ5ICE9PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIHB1c2hpbmcgY29kZSBuZWVkcyB0byBhY2NvdW50IGZvciBwbGF5ZXJzIG9uIHNsYW50ZWQgc3VyZmFjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnggLSBtYWluXzEucGxheWVyW2pdLnBoeXMucG9zLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPCA2LjUgJiYgZGlmZiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluXzEucGxheWVyW2pdLnBoeXMucG9zLnggKz0gTWF0aC5zaWduKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCAtIG1haW5fMS5wbGF5ZXJbal0ucGh5cy5wb3MueCkgKiAtMC4zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlmZiA9PT0gMCAmJiBNYXRoLmFicyhtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54KSA+IE1hdGguYWJzKG1haW5fMS5wbGF5ZXJbal0ucGh5cy5jVmVsLngpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl8xLnBsYXllcltqXS5waHlzLnBvcy54ICs9IE1hdGguc2lnbihtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54KSAqIC0wLjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7IC8vIHBsYXllciBpZ25vcmluZyBjb2xsaXNpb25zXG4gICAgICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5FQ0IxID0gW1xuICAgICAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQobWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy54LCBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zLnkgKyAoKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5ncm91bmRlZCB8fCBtYWluXzEucGxheWVyW2ldLnBoeXMuYWlyYm9ybmVUaW1lciA8IDEwKSA/IDAgOiBlY2JPZmZzZXRbMF0pKSxcbiAgICAgICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCArIGVjYk9mZnNldFsxXSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgZWNiT2Zmc2V0WzJdKSxcbiAgICAgICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgZWNiT2Zmc2V0WzNdKSxcbiAgICAgICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3MueCAtIGVjYk9mZnNldFsxXSwgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvcy55ICsgZWNiT2Zmc2V0WzJdKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBpZiAobWFpbl8xLnBsYXllcltpXS5waHlzLnNoaWVsZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnNoaWVsZEhQICs9IDAuMDc7XG4gICAgICAgIGlmIChtYWluXzEucGxheWVyW2ldLnBoeXMuc2hpZWxkSFAgPiA2MCkge1xuICAgICAgICAgICAgbWFpbl8xLnBsYXllcltpXS5waHlzLnNoaWVsZEhQID0gNjA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhbFdpdGhMZWRnZXMoaSwgaW5wdXQpO1xuICAgIGRlYWxXaXRoRGVhdGgoaSwgaW5wdXQpO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5odXJ0Ym94ID0gbmV3IEJveDJEXzEuQm94MkQoW3BsYXllclBvc1ggLSBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLmh1cnRib3hPZmZzZXRbMF0sIHBsYXllclBvc1kgKyBtYWluXzEucGxheWVyW2ldLmNoYXJBdHRyaWJ1dGVzLmh1cnRib3hPZmZzZXRbMV1dLCBbcGxheWVyUG9zWCArIG1haW5fMS5wbGF5ZXJbaV0uY2hhckF0dHJpYnV0ZXMuaHVydGJveE9mZnNldFswXSwgcGxheWVyUG9zWV0pO1xuICAgIGlmIChtYWluXzEuZ2FtZU1vZGUgPT09IDMgJiYgbWFpbl8xLnBsYXllcltpXS5waHlzLnBvc1ByZXYueSA+IC04MCAmJiBwbGF5ZXJQb3NZIDw9IC04MCkge1xuICAgICAgICBzZnhfMS5zb3VuZHMubG93ZG93bi5wbGF5KCk7XG4gICAgfVxuICAgIHVwZGF0ZUhpdGJveGVzKGkpO1xuICAgIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3NEZWx0YSA9IG5ldyBWZWMyRF8xLlZlYzJEKE1hdGguYWJzKHBsYXllclBvc1ggLSBtYWluXzEucGxheWVyW2ldLnBoeXMucG9zUHJldi54KSwgTWF0aC5hYnMocGxheWVyUG9zWSAtIG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5wb3NQcmV2LnkpKTtcbiAgICBpZiAobWFpbl8xLnNob3dEZWJ1Zykge1xuICAgICAgICAoX2EgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0U3RhdGUnICsgaSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbm5lckhUTUwgPSBtYWluXzEucGxheWVyW2ldLmN1cnJlbnRBY3Rpb24gKyBcIiBcIiArIG1haW5fMS5wbGF5ZXJbaV0uY3VycmVudFN1YmFjdGlvbiArIFwiIDogXCIgKyBtYWluXzEucGxheWVyW2ldLmFjdGlvblN0YXRlO1xuICAgICAgICAoX2IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGVOdW0nICsgaSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbm5lckhUTUwgPSBmcmFtZS50b1N0cmluZygpO1xuICAgICAgICAoX2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmFjZScgKyBpKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmlubmVySFRNTCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5mYWNlO1xuICAgICAgICAoX2QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInZlbG9jaXR5WFwiICsgaSkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pbm5lckhUTUwgPSBtYWluXzEucGxheWVyW2ldLnBoeXMuY1ZlbC54LnRvRml4ZWQoNSk7XG4gICAgICAgIChfZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidmVsb2NpdHlZXCIgKyBpKSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmlubmVySFRNTCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5jVmVsLnkudG9GaXhlZCg1KTtcbiAgICAgICAgKF9mID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJrdmVsb2NpdHlYXCIgKyBpKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmlubmVySFRNTCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLngudG9GaXhlZCg1KTtcbiAgICAgICAgKF9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJrdmVsb2NpdHlZXCIgKyBpKSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmlubmVySFRNTCA9IG1haW5fMS5wbGF5ZXJbaV0ucGh5cy5rVmVsLnkudG9GaXhlZCg1KTtcbiAgICAgICAgKF9oID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwdmVsb2NpdHlYXCIgKyBpKSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmlubmVySFRNTCA9IHBsYXllclBvc1gudG9GaXhlZCg1KTtcbiAgICAgICAgKF9qID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwdmVsb2NpdHlZXCIgKyBpKSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmlubmVySFRNTCA9IHBsYXllclBvc1kudG9GaXhlZCg1KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/physics/physics.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("677ce438f76d0d72e1c6")
/******/ })();
/******/ 
/******/ }
);