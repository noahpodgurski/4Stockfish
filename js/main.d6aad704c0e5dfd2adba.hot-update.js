/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatemeleelight"]("main",{

/***/ "./src/main/multiplayer/encode.js":
/*!****************************************!*\
  !*** ./src/main/multiplayer/encode.js ***!
  \****************************************/
/***/ (() => {

throw new Error("Module build failed (from ./node_modules/thread-loader/dist/cjs.js):\nThread Loader (Worker 0)\nC:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\src\\main\\multiplayer\\encode.js: Missing semicolon. (76:55)\n\n\u001b[0m \u001b[90m 74 |\u001b[39m }\n \u001b[90m 75 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 76 |\u001b[39m functionbooleansToByte( b0\u001b[33m,\u001b[39m b1\u001b[33m,\u001b[39m b2\u001b[33m,\u001b[39m b3\u001b[33m,\u001b[39m b4\u001b[33m,\u001b[39m b5\u001b[33m,\u001b[39m b6\u001b[33m,\u001b[39m b7) {\n \u001b[90m    |\u001b[39m                                                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 77 |\u001b[39m   \u001b[36mreturn\u001b[39m b0\u001b[33m?\u001b[39m\u001b[35m128\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b1\u001b[33m?\u001b[39m\u001b[35m64\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b2\u001b[33m?\u001b[39m\u001b[35m32\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b3\u001b[33m?\u001b[39m\u001b[35m16\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b4\u001b[33m?\u001b[39m\u001b[35m8\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b5\u001b[33m?\u001b[39m\u001b[35m4\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b6\u001b[33m?\u001b[39m\u001b[35m2\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m \u001b[33m+\u001b[39m b7\u001b[33m?\u001b[39m\u001b[35m1\u001b[39m\u001b[33m:\u001b[39m\u001b[35m0\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 78 |\u001b[39m }\n \u001b[90m 79 |\u001b[39m\u001b[0m\n\n    at constructor (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:349:19)\n    at FlowParserMixin.raise (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:3247:19)\n    at FlowParserMixin.semicolon (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:3573:10)\n    at FlowParserMixin.parseExpressionStatement (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12739:10)\n    at FlowParserMixin.parseExpressionStatement (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:5060:18)\n    at FlowParserMixin.parseStatementContent (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12354:19)\n    at FlowParserMixin.parseStatementLike (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12217:17)\n    at FlowParserMixin.parseStatementLike (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:5038:24)\n    at FlowParserMixin.parseModuleItem (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12194:17)\n    at FlowParserMixin.parseBlockOrModuleBlockBody (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12770:36)\n    at FlowParserMixin.parseBlockBody (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12763:10)\n    at FlowParserMixin.parseProgram (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12091:10)\n    at FlowParserMixin.parseTopLevel (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:12081:25)\n    at FlowParserMixin.parseTopLevel (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:5805:28)\n    at FlowParserMixin.parse (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:13893:10)\n    at parse (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\parser\\lib\\index.js:13927:38)\n    at parser (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\core\\lib\\parser\\index.js:41:34)\n    at parser.next (<anonymous>)\n    at normalizeFile (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\core\\lib\\transformation\\normalize-file.js:64:37)\n    at normalizeFile.next (<anonymous>)\n    at run (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\core\\lib\\transformation\\index.js:21:50)\n    at run.next (<anonymous>)\n    at transform (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\core\\lib\\transform.js:22:33)\n    at transform.next (<anonymous>)\n    at step (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:261:32)\n    at C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:273:13\n    at async.call.result.err.err (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:223:11)\n    at C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:189:28\n    at C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\@babel\\core\\lib\\gensync-utils\\async.js:67:7\n    at C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:113:33\n    at step (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:287:14)\n    at C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:273:13\n    at async.call.result.err.err (C:\\Users\\noahp\\Documents\\Programming\\Software-Projects\\4Stockfish\\node_modules\\gensync\\index.js:223:11)");

/***/ }),

/***/ "./src/input/gamepad/gamepadCalibration.ts":
/*!*************************************************!*\
  !*** ./src/input/gamepad/gamepadCalibration.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @flow\n/*eslint indent:0*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.customGamepadInfoIsUsable = void 0;\nexports.setClickObject = setClickObject;\nexports.setClickObjectNumber = setClickObjectNumber;\nexports.setCustomGamepadInfoIsUsable = setCustomGamepadInfoIsUsable;\nexports.runCalibration = runCalibration;\nconst Vec2D_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../main/util/Vec2D.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst deepCopy_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../main/util/deepCopy.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst main_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../main/main.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst controllermenu_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../menus/controllermenu.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst gamepadInfo_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './gamepadInfo.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst gamepad_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './gamepad.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst custom_js_1 = __webpack_require__(/*! ./gamepads/custom.js */ \"./src/input/gamepad/gamepads/custom.js\");\nconst findGamepadInfo_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './findGamepadInfo.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst sfx_js_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../../main/sfx.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst calibrationInProgress = [false, false, false, false];\nfunction setCalibrationInProgress(i, booleanean) {\n    calibrationInProgress[i] = booleanean;\n}\nconst nullSnapshots = {\n    b0: [], bL: [], bR: [], bU: [],\n    a0: [], aL: [], aR: [], aU: []\n};\nlet clickObject = null;\nfunction setClickObject(click) {\n    if (clickObject === null) {\n        clickObject = click;\n    }\n}\nlet clickObjectNumber = 0;\nfunction setClickObjectNumber(k) {\n    clickObjectNumber = k;\n}\nexports.customGamepadInfoIsUsable = [true, null, null, null, null, null, null, null];\nlet listening = false;\nconst ids = [\"a\", \"b\", \"x\", \"y\", \"s\", \"r\", \"l\", \"z\", \"dpad\", \"icon\", \"ls\", \"cs\"];\n// add listeners for click\n// these turn off when the SVG is not displayed, so shouldn't impact performance\nfunction listen() {\n    var _a, _b;\n    // $FlowFixMe ignore the following type error\n    const svgDoc = (_a = document.getElementById(\"gamepadSVGCalibration\")) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n    for (let i = 0; i < ids.length; i++) {\n        const id = ids[i];\n        if (id === null) {\n            throw \"id is null\";\n        }\n        // eslint-disable-next-line no-loop-func\n        (_b = svgDoc === null || svgDoc === void 0 ? void 0 : svgDoc.getElementById(id)) === null || _b === void 0 ? void 0 : _b.addEventListener('click', () => {\n            clickObject = id;\n        });\n    }\n    listening = true;\n}\nconst defaultTexts = [\"Click button, trigger or analog stick to rebind.\"];\nconst errorText = [\"Error: no controller detected\"];\n// figure out which custom gamepad infos are usable by the current controller\n// sets the value for customGamepadInfoIsUsable\nfunction setCustomGamepadInfoIsUsable(j) {\n    const currentGamepad = (0, gamepad_js_1.getGamepad)(j);\n    if (currentGamepad) {\n        const currentGamepadId = currentGamepad.id;\n        if ((0, findGamepadInfo_js_1.getGamepadNameAndInfo)(currentGamepadId) === null) {\n            exports.customGamepadInfoIsUsable[0] = null;\n        }\n        else {\n            exports.customGamepadInfoIsUsable[0] = true;\n        }\n        for (let k = 1; k < 8; k++) {\n            const maybeCustomGamepadInfo = (0, custom_js_1.getCustomGamepadInfo)(k);\n            if (maybeCustomGamepadInfo === null) {\n                exports.customGamepadInfoIsUsable[k] = null;\n            }\n            else {\n                if (currentGamepadId === maybeCustomGamepadInfo.fullID) {\n                    exports.customGamepadInfoIsUsable[k] = true;\n                }\n                else {\n                    exports.customGamepadInfoIsUsable[k] = false;\n                }\n            }\n        }\n    }\n    else {\n        exports.customGamepadInfoIsUsable[0] = null;\n    }\n}\nfunction runCalibration(i) {\n    if (!calibrationInProgress[i]) {\n        setCalibrationInProgress(i, true);\n        const interval = 2000;\n        const j = main_js_1.currentPlayers[i];\n        const prevGamepadInfo = main_js_1.mType[i] === null || main_js_1.mType[i] === \"keyboard\" ? gamepadInfo_js_1.nullGamepadInfo : main_js_1.mType[i];\n        const gamepadInfo = (0, deepCopy_js_1.deepCopyObject)(true, prevGamepadInfo);\n        setCustomGamepadInfoIsUsable(j);\n        clickObject = null;\n        if (listening === false) {\n            listen();\n        }\n        (0, controllermenu_js_1.updateControllerMenu)(false, [\"Mouse-click the start button to begin calibration.\"], 0);\n        preCalibrationLoop(i, j, gamepadInfo, interval);\n    }\n}\nfunction resetGamepadInfo(j) {\n    const gamepad = (0, gamepad_js_1.getGamepad)(j);\n    let baseGamepadInfo = gamepadInfo_js_1.nullGamepadInfo;\n    if (gamepad !== undefined && gamepad !== null && gamepad.id !== undefined && gamepad.id !== null) {\n        const maybeNameAndInfo = (0, findGamepadInfo_js_1.getGamepadNameAndInfo)(gamepad.id);\n        if (maybeNameAndInfo !== null) {\n            baseGamepadInfo = (0, deepCopy_js_1.deepCopyObject)(true, maybeNameAndInfo[1]);\n        }\n    }\n    return baseGamepadInfo;\n}\nfunction saveSound() {\n    sfx_js_1.sounds.star.play();\n}\nfunction preCalibrationLoop(i, j, gamepadInfo, interval) {\n    if (clickObject === \"s\") {\n        sfx_js_1.sounds.blunthit.play();\n        (0, custom_js_1.setCustomGamepadInfo)(j, gamepadInfo);\n        (0, main_js_1.setUsingCustomControls)(i, true);\n        (0, controllermenu_js_1.updateControllerMenu)(false, [\"Finding controller neutral point.\", \"Do not press anything.\"], interval);\n        // take null snapshot\n        setTimeout(() => {\n            (0, main_js_1.setControllerReset)(i);\n            saveSound();\n            const gamepad = (0, gamepad_js_1.getGamepad)(j);\n            if (gamepad !== undefined && gamepad !== null) {\n                const snapshots = nullSnapshots;\n                snapshots.b0 = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.buttons);\n                snapshots.a0 = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.axes);\n                calibrationLoop(i, j, gamepadInfo, snapshots, interval);\n                (0, controllermenu_js_1.updateControllerMenu)(false, defaultTexts, 0);\n            }\n            else {\n                (0, controllermenu_js_1.updateControllerMenu)(false, errorText, 0);\n            }\n        }, interval);\n    }\n    else if (clickObject === \"exit\") {\n        sfx_js_1.sounds.menuBack.play();\n        (0, controllermenu_js_1.updateControllerMenu)(true, [\"Quitting calibration menu.\"], interval);\n        setCalibrationInProgress(i, false);\n    }\n    else if (clickObject === \"reset\") {\n        sfx_js_1.sounds.loudelectricfizz.play();\n        (0, controllermenu_js_1.setCustomInUse)(0);\n        const baseGamepadInfo = resetGamepadInfo(j);\n        (0, main_js_1.setUsingCustomControls)(i, false, baseGamepadInfo);\n        (0, controllermenu_js_1.updateControllerMenu)(false, [\"Controller bindings have been reset.\", \"Click the start button to begin calibration.\"], 0);\n        setTimeout(() => preCalibrationLoop(i, j, baseGamepadInfo, interval), 16);\n    }\n    else if (clickObject === \"center\") {\n        saveSound();\n        (0, main_js_1.setControllerReset)(i);\n        (0, controllermenu_js_1.updateControllerMenu)(false, [\"Controller has been re-centered.\", \"Click the start button to begin calibration.\"], 0);\n        setTimeout(() => preCalibrationLoop(i, j, gamepadInfo, interval), 16);\n    }\n    else if (clickObject === \"loadCustom\") {\n        if (clickObjectNumber === 0) {\n            (0, controllermenu_js_1.setCustomInUse)(0);\n            const baseGamepadInfo = resetGamepadInfo(j);\n            (0, main_js_1.setUsingCustomControls)(i, false, baseGamepadInfo);\n            (0, controllermenu_js_1.updateControllerMenu)(false, [\"Now using default controller bindings.\", \"Click the start button to begin calibration.\"], 0);\n            setTimeout(() => preCalibrationLoop(i, j, baseGamepadInfo, interval), 16);\n        }\n        else {\n            const newCustomGamepadInfo = (0, custom_js_1.getCustomGamepadInfo)(clickObjectNumber);\n            if (newCustomGamepadInfo === null || exports.customGamepadInfoIsUsable[clickObjectNumber] !== true) {\n                sfx_js_1.sounds.deny.play();\n                setTimeout(() => preCalibrationLoop(i, j, gamepadInfo, interval), 16);\n            }\n            else {\n                const newGamepadInfo = newCustomGamepadInfo.gamepadInfo;\n                (0, controllermenu_js_1.setCustomInUse)(clickObjectNumber);\n                (0, custom_js_1.setCustomGamepadInfo)(j, newGamepadInfo);\n                (0, main_js_1.setUsingCustomControls)(i, true);\n                (0, controllermenu_js_1.updateControllerMenu)(false, [\"Now using custom bindings #\" + clickObjectNumber + \".\", \"Click the start button to begin calibration.\"], 0);\n                setTimeout(() => preCalibrationLoop(i, j, newGamepadInfo, interval), 16);\n            }\n        }\n    }\n    else if (clickObject === \"saveCustom\") {\n        if (clickObjectNumber < 1) {\n            sfx_js_1.sounds.deny.play();\n        }\n        else {\n            exports.customGamepadInfoIsUsable[clickObjectNumber] = true;\n            (0, custom_js_1.storeCustomGamepadInfo)(gamepadInfo, (0, gamepad_js_1.getGamepad)(j).id, (\"custom\" + clickObjectNumber), clickObjectNumber);\n            (0, controllermenu_js_1.setCustomInUse)(clickObjectNumber);\n        }\n        setTimeout(() => preCalibrationLoop(i, j, gamepadInfo, interval), 16);\n    }\n    else {\n        if (clickObject === \"icon\") {\n            sfx_js_1.sounds.shout8.play();\n            sfx_js_1.sounds.sword3.play();\n        }\n        setTimeout(() => preCalibrationLoop(i, j, gamepadInfo, interval), 16);\n    }\n    clickObject = null;\n}\n;\nfunction calibrationLoop(i, j, gamepadInfo, snapshots, interval) {\n    if (clickObject === null) {\n        setTimeout(() => {\n            calibrationLoop(i, j, gamepadInfo, snapshots, interval);\n        }, 16);\n    }\n    else {\n        calibrateObject(i, j, gamepadInfo, snapshots, interval);\n    }\n}\n;\nfunction calibrateObject(i, j, gamepadInfo, snapshots, interval) {\n    let texts;\n    let gamepad;\n    let totalInterval = interval + 16;\n    if (clickObject === null) {\n        console.log(\"error in function 'calibrateObject': calibration called on null object\");\n    }\n    else if (clickObject === \"icon\") {\n        sfx_js_1.sounds.shout8.play();\n        sfx_js_1.sounds.sword3.play();\n    }\n    else if (clickObject === \"exit\") {\n        sfx_js_1.sounds.menuBack.play();\n        setCalibrationInProgress(i, false);\n        (0, controllermenu_js_1.updateControllerMenu)(true, [\"Quitting calibration menu.\"], interval);\n    }\n    else if (clickObject === \"reset\") {\n        sfx_js_1.sounds.loudelectricfizz.play();\n        (0, controllermenu_js_1.setCustomInUse)(0);\n        const baseGamepadInfo = resetGamepadInfo(j);\n        (0, custom_js_1.setCustomGamepadInfo)(j, baseGamepadInfo);\n        (0, main_js_1.setUsingCustomControls)(i, false, baseGamepadInfo);\n        (0, controllermenu_js_1.updateControllerMenu)(false, [\"Controller bindings have been reset.\", \"Click the start button to begin calibration.\"], 0);\n        setTimeout(() => preCalibrationLoop(i, j, baseGamepadInfo, interval), 16);\n    }\n    else if (clickObject === \"center\") {\n        saveSound();\n        (0, main_js_1.setControllerReset)(i);\n        (0, controllermenu_js_1.updateControllerMenu)(false, [\"Controller has been re-centered.\", \"Click the start button to continue calibration.\"], 0);\n        setTimeout(() => preCalibrationLoop(i, j, gamepadInfo, interval), 16);\n        totalInterval = 16;\n    }\n    else if (clickObject === \"loadCustom\") {\n        if (clickObjectNumber === 0) {\n            (0, controllermenu_js_1.setCustomInUse)(0);\n            const baseGamepadInfo = resetGamepadInfo(j);\n            (0, main_js_1.setUsingCustomControls)(i, false, baseGamepadInfo);\n            (0, controllermenu_js_1.updateControllerMenu)(false, [\"Now using default controller bindings.\", \"Click the start button to begin calibration.\"], 0);\n            setTimeout(() => preCalibrationLoop(i, j, baseGamepadInfo, interval), 16);\n        }\n        else {\n            const newCustomGamepadInfo = (0, custom_js_1.getCustomGamepadInfo)(clickObjectNumber);\n            if (newCustomGamepadInfo === null || exports.customGamepadInfoIsUsable[clickObjectNumber] !== true) {\n                sfx_js_1.sounds.deny.play();\n                setTimeout(() => preCalibrationLoop(i, j, gamepadInfo, interval), 16);\n            }\n            else {\n                const newGamepadInfo = newCustomGamepadInfo.gamepadInfo;\n                (0, controllermenu_js_1.setCustomInUse)(clickObjectNumber);\n                (0, custom_js_1.setCustomGamepadInfo)(j, newGamepadInfo);\n                (0, main_js_1.setUsingCustomControls)(i, true);\n                (0, controllermenu_js_1.updateControllerMenu)(false, [\"Now using custom bindings #\" + clickObjectNumber + \".\", \"Click the start button to begin calibration.\"], 0);\n                setTimeout(() => preCalibrationLoop(i, j, newGamepadInfo, interval), 16);\n            }\n        }\n    }\n    else if (clickObject === \"saveCustom\") {\n        if (clickObjectNumber < 1) {\n            sfx_js_1.sounds.deny.play();\n        }\n        else {\n            exports.customGamepadInfoIsUsable[clickObjectNumber] = true;\n            (0, custom_js_1.storeCustomGamepadInfo)(gamepadInfo, (0, gamepad_js_1.getGamepad)(j).id, (\"custom\" + clickObjectNumber), clickObjectNumber);\n            (0, controllermenu_js_1.setCustomInUse)(clickObjectNumber);\n        }\n    }\n    else if (clickObject === \"l\" || clickObject === \"r\") {\n        texts = [\"Fully depress \" + clickObject.toUpperCase() + \" trigger.\", \"Keep holding down the trigger.\"];\n        const t = clickObject; // passed as-is in the closure\n        const tA = clickObject + \"A\";\n        (0, controllermenu_js_1.updateControllerMenu)(false, texts, interval);\n        setTimeout(() => {\n            saveSound();\n            gamepad = (0, gamepad_js_1.getGamepad)(j);\n            gamepadInfo[t] = scanForButton(snapshots.b0, gamepad.buttons, snapshots.a0, gamepad.axes, true);\n            gamepadInfo[tA] = scanForTrigger(snapshots.b0, gamepad.buttons, snapshots.a0, gamepad.axes);\n            (0, controllermenu_js_1.updateControllerMenu)(false, defaultTexts, 0);\n            if (t === \"l\" && gamepadInfo.lA !== null && (gamepadInfo.lA.kind === \"value\" || gamepadInfo.lA.kind === \"axis\")) {\n                gamepadInfo.isGC = Math.abs(gamepadInfo.lA.min + 0.866) < 0.01 ? true : false; // hacky but hey\n            }\n        }, interval);\n    }\n    else if (clickObject === \"ls\" || clickObject === \"cs\" || clickObject === \"dpad\") {\n        let sep = \",\";\n        if (clickObject === \"ls\") {\n            texts = [\"Move left analog stick all the way \", \"and keep it there.\"];\n        }\n        else if (clickObject === \"cs\") {\n            texts = [\"Move c-stick all the way \", \"and keep it there.\"];\n        }\n        else {\n            sep = \".\";\n            texts = [\"Press and hold d-pad \"];\n        }\n        totalInterval += 5 * interval;\n        (0, controllermenu_js_1.updateControllerMenu)(false, [texts[0] + \"left\" + sep, texts[1]], 1.5 * interval);\n        setTimeout(() => {\n            saveSound();\n            gamepad = (0, gamepad_js_1.getGamepad)(j);\n            snapshots.bL = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.buttons);\n            snapshots.aL = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.axes);\n            (0, controllermenu_js_1.updateControllerMenu)(false, [texts[0] + \"right\" + sep, texts[1]], 1.5 * interval);\n        }, 1.5 * interval);\n        setTimeout(() => {\n            saveSound();\n            gamepad = (0, gamepad_js_1.getGamepad)(j);\n            snapshots.bR = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.buttons);\n            snapshots.aR = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.axes);\n            (0, controllermenu_js_1.updateControllerMenu)(false, [texts[0] + \"up\" + sep, texts[1]], 1.5 * interval);\n        }, 3 * interval);\n        setTimeout(() => {\n            saveSound();\n            gamepad = (0, gamepad_js_1.getGamepad)(j);\n            snapshots.bU = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.buttons);\n            snapshots.aU = (0, deepCopy_js_1.deepCopyArray)(true, gamepad.axes);\n            (0, controllermenu_js_1.updateControllerMenu)(false, [texts[0] + \"down\" + sep, texts[1]], 1.5 * interval);\n        }, 4.5 * interval);\n        if (clickObject === \"dpad\") {\n            setTimeout(() => {\n                saveSound();\n                gamepad = (0, gamepad_js_1.getGamepad)(j);\n                gamepadInfo.dpad = scanForDPad(snapshots.b0, snapshots.bL, snapshots.bR, snapshots.bU, gamepad.buttons, snapshots.a0, snapshots.aL, snapshots.aR, snapshots.aU, gamepad.axes);\n                (0, controllermenu_js_1.updateControllerMenu)(false, defaultTexts, 0);\n            }, 6 * interval);\n        }\n        else {\n            const clickNow = clickObject; // passed as-is in the closure\n            setTimeout(() => {\n                saveSound();\n                gamepad = (0, gamepad_js_1.getGamepad)(j);\n                gamepadInfo[clickNow] = scanForStick(snapshots.b0, snapshots.bL, snapshots.bR, snapshots.bU, gamepad.buttons, snapshots.a0, snapshots.aL, snapshots.aR, snapshots.aU, gamepad.axes);\n                (0, controllermenu_js_1.updateControllerMenu)(false, defaultTexts, 0);\n            }, 6 * interval);\n        }\n    }\n    else { // only plain buttons left now\n        const buttonName = clickObject === \"s\" ? \"start\" : clickObject.toUpperCase();\n        texts = [\"Press and hold \" + buttonName + \".\"];\n        const clickNow = clickObject;\n        (0, controllermenu_js_1.updateControllerMenu)(false, texts, interval);\n        setTimeout(() => {\n            saveSound();\n            gamepad = (0, gamepad_js_1.getGamepad)(j);\n            gamepadInfo[clickNow] = scanForButton(snapshots.b0, gamepad.buttons, snapshots.a0, gamepad.axes);\n            (0, controllermenu_js_1.updateControllerMenu)(false, defaultTexts, 0);\n        }, interval);\n    }\n    if (clickObject !== \"exit\" && clickObject !== \"reset\" && clickObject !== \"center\" && clickObject !== \"loadCustom\") {\n        if (clickObject !== null) {\n            sfx_js_1.sounds.blunthit.play();\n            setTimeout(() => {\n                (0, custom_js_1.setCustomGamepadInfo)(j, gamepadInfo);\n                calibrationLoop(i, j, gamepadInfo, snapshots, interval);\n            }, totalInterval);\n        }\n        else {\n            setTimeout(() => {\n                calibrationLoop(i, j, gamepadInfo, snapshots, interval);\n            }, totalInterval);\n        }\n    }\n    if (clickObject !== null && clickObject !== \"saveCustom\" && clickObject !== \"loadCustom\"\n        && clickObject !== \"center\" && clickObject !== \"icon\" && clickObject !== \"exit\" && clickObject !== \"reset\") {\n        (0, controllermenu_js_1.setCustomInUse)(null);\n    }\n    if (clickObject !== null) {\n        clickObject = null;\n    }\n}\nfunction scanForButton(buttons0, buttons1, axes0, axes1, onlyPressed = false) {\n    let buttonInfo = null;\n    const bLg = buttons1.length;\n    for (let i = 0; i < bLg; i++) {\n        if (detectedButtonPressed(buttons0[i].pressed, buttons1[i].pressed)) {\n            buttonInfo = { kind: \"pressed\", index: i };\n            break;\n        }\n        else if (!onlyPressed && detectedButtonValue(buttons0[i].value, buttons1[i].value)) {\n            buttonInfo = { kind: \"value\", index: i, threshold: 0.75 };\n            break;\n        }\n    }\n    if (!onlyPressed && buttonInfo === null) {\n        const aLg = axes1.length;\n        for (let j = 0; j < aLg; j++) {\n            if (detectedButtonValue(axes0[j], axes1[j])) {\n                buttonInfo = { kind: \"axis\", index: j, threshold: 0.75 };\n                break;\n            }\n        }\n    }\n    return buttonInfo;\n}\n;\nfunction detectedButtonPressed(pressed0, pressed1) {\n    return pressed1 && !pressed0;\n}\n;\nfunction detectedButtonValue(value0, value1) {\n    return (value0 < 0.25 && value1 > 0.75);\n}\n;\nfunction scanForTrigger(buttons0, buttons1, axes0, axes1) {\n    let minMax;\n    let triggerInfo = null;\n    const aLg = axes1.length;\n    for (let i = 0; i < aLg && triggerInfo === null; i++) {\n        minMax = detectedTrigger(axes0[i], axes1[i]);\n        if (minMax !== null) {\n            triggerInfo = { kind: \"axis\", index: i, min: minMax[0], max: minMax[1] };\n            break;\n        }\n    }\n    if (triggerInfo === null) {\n        const bLg = buttons1.length;\n        for (let j = 0; j < bLg && triggerInfo === null; j++) {\n            minMax = detectedTrigger(buttons0[j].value, buttons1[j].value);\n            if (minMax !== null) {\n                triggerInfo = { kind: \"value\", index: j, min: minMax[0], max: minMax[1] };\n                break;\n            }\n        }\n    }\n    return triggerInfo;\n}\nfunction detectedTrigger(axis0, axis1) {\n    if (Math.abs(axis1 - axis0) < 0.5) {\n        return null;\n    }\n    else {\n        return getMinAndMax(axis0, axis1);\n    }\n}\nfunction getMinAndMax(axis0, axis1) {\n    const min = axis0 < -0.87 ? -1 : axis0 < -0.5 ? -0.866 : axis0 > 0.87 ? 1 : axis0 > 0.5 ? 0.8667 : 0;\n    const max = min === 0 ? Math.sign(axis1) : -min;\n    return [min, max];\n}\nfunction scanForStick(buttons0, buttonsL, buttonsR, buttonsU, buttonsD, axes0, axesL, axesR, axesU, axesD) {\n    let stickInfo = null;\n    let xDiff = 0;\n    let yDiff = 0;\n    let newXDiff = 0;\n    let newYDiff = 0;\n    let xIndex;\n    let yIndex;\n    let kind;\n    let cardinals = null;\n    const aLg = axes0.length;\n    kind = \"axes\";\n    for (let i = 0; i < aLg; i++) {\n        newXDiff = axesR[i] - axesL[i];\n        if (Math.abs(newXDiff) > Math.abs(xDiff)) {\n            xDiff = newXDiff;\n            xIndex = i;\n        }\n        newYDiff = axesU[i] - axesD[i];\n        if (Math.abs(newYDiff) > Math.abs(yDiff)) {\n            yDiff = newYDiff;\n            yIndex = i;\n        }\n    }\n    if (xIndex !== undefined && yIndex !== undefined && Math.abs(xDiff) > 0.5 && Math.abs(yDiff) > 0.5) {\n        cardinals = {\n            center: new Vec2D_js_1.Vec2D(axes0[xIndex], axes0[yIndex]),\n            left: axesL[xIndex],\n            right: axesR[xIndex],\n            up: axesU[yIndex],\n            down: axesD[yIndex]\n        };\n    }\n    if (Math.abs(xDiff) < 0.5 || Math.abs(yDiff) < 0.5) {\n        const bLg = buttons0.length;\n        kind = \"value\";\n        for (let j = 0; j < bLg; j++) {\n            newXDiff = buttonsR[j].value - buttonsL[j].value;\n            if (Math.abs(newXDiff) > Math.abs(xDiff)) {\n                xDiff = newXDiff;\n                xIndex = j;\n            }\n            newYDiff = buttonsU[j].value - buttonsD[j].value;\n            if (Math.abs(newYDiff) > Math.abs(yDiff)) {\n                yDiff = newYDiff;\n                yIndex = j;\n            }\n        }\n        if (xIndex !== undefined && yIndex !== undefined && Math.abs(xDiff) > 0.5 && Math.abs(yDiff) > 0.5) {\n            cardinals = {\n                center: new Vec2D_js_1.Vec2D(buttons0[xIndex].value, buttons0[yIndex].value),\n                left: buttonsL[xIndex].value,\n                right: buttonsR[xIndex].value,\n                up: buttonsU[yIndex].value,\n                down: buttonsD[yIndex].value\n            };\n        }\n    }\n    if (xIndex !== undefined && yIndex !== undefined) {\n        if (kind === \"axes\") {\n            stickInfo = { kind: \"axes\", xIndex: xIndex, yIndex: yIndex, cardinals: cardinals };\n        }\n        else {\n            stickInfo = { kind: \"value\", xIndex: xIndex, yIndex: yIndex, cardinals: cardinals };\n        }\n    }\n    return stickInfo;\n}\nfunction scanForDPad(buttons0, buttonsL, buttonsR, buttonsU, buttonsD, axes0, axesL, axesR, axesU, axesD) {\n    let dPadInfo = null;\n    const bLg = buttons0.length;\n    let lIndex;\n    let rIndex;\n    let uIndex;\n    let dIndex;\n    for (let i = 0; i < bLg; i++) {\n        if (lIndex === undefined && detectedButtonPressed(buttons0[i].pressed, buttonsL[i].pressed)) {\n            lIndex = i;\n        }\n        if (rIndex === undefined && detectedButtonPressed(buttons0[i].pressed, buttonsR[i].pressed)) {\n            rIndex = i;\n        }\n        if (uIndex === undefined && detectedButtonPressed(buttons0[i].pressed, buttonsU[i].pressed)) {\n            uIndex = i;\n        }\n        if (dIndex === undefined && detectedButtonPressed(buttons0[i].pressed, buttonsD[i].pressed)) {\n            dIndex = i;\n        }\n    }\n    if (lIndex !== undefined && rIndex !== undefined && uIndex !== undefined && dIndex !== undefined) {\n        dPadInfo = {\n            kind: \"buttons\",\n            upIndex: uIndex, downIndex: dIndex,\n            leftIndex: lIndex, rightIndex: rIndex\n        };\n    }\n    else {\n        let xDiff = 0;\n        let yDiff = 0;\n        let newXDiff = 0;\n        let newYDiff = 0;\n        let xIndex;\n        let yIndex;\n        const aLg = axes0.length;\n        for (let i = 0; i < aLg; i++) {\n            newXDiff = axesR[i] - axesL[i];\n            if (Math.abs(newXDiff) > Math.abs(xDiff)) {\n                xDiff = newXDiff;\n                xIndex = i;\n            }\n            newYDiff = axesU[i] - axesD[i];\n            if (Math.abs(newYDiff) > Math.abs(yDiff)) {\n                yDiff = newYDiff;\n                yIndex = i;\n            }\n        }\n        if (xIndex !== undefined && yIndex !== undefined) {\n            if (Math.abs(xDiff) > 0.5 && Math.abs(yDiff) > 0.5 && xIndex !== yIndex) {\n                dPadInfo = {\n                    kind: \"2axes\",\n                    xIndex: xIndex, yIndex: yIndex,\n                    xFlip: (xDiff < 0), yFlip: (yDiff < 0)\n                };\n            }\n            else { // lol\n                dPadInfo = { kind: \"axis\", index: xIndex };\n            }\n        }\n    }\n    return dPadInfo;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5wdXQvZ2FtZXBhZC9nYW1lcGFkQ2FsaWJyYXRpb24udHMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQyxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLG9DQUFvQztBQUNwQyxzQkFBc0I7QUFDdEIsbUJBQW1CLG1CQUFPLENBQUMsdUpBQTBCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDBKQUE2QjtBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQyxpSkFBb0I7QUFDOUMsNEJBQTRCLG1CQUFPLENBQUMsNEpBQStCO0FBQ25FLHlCQUF5QixtQkFBTyxDQUFDLCtJQUFrQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQywySUFBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBc0I7QUFDbEQsNkJBQTZCLG1CQUFPLENBQUMsbUpBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLGdKQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWxlZWxpZ2h0Ly4vc3JjL2lucHV0L2dhbWVwYWQvZ2FtZXBhZENhbGlicmF0aW9uLnRzP2VlYTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBAZmxvd1xuLyplc2xpbnQgaW5kZW50OjAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jdXN0b21HYW1lcGFkSW5mb0lzVXNhYmxlID0gdm9pZCAwO1xuZXhwb3J0cy5zZXRDbGlja09iamVjdCA9IHNldENsaWNrT2JqZWN0O1xuZXhwb3J0cy5zZXRDbGlja09iamVjdE51bWJlciA9IHNldENsaWNrT2JqZWN0TnVtYmVyO1xuZXhwb3J0cy5zZXRDdXN0b21HYW1lcGFkSW5mb0lzVXNhYmxlID0gc2V0Q3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZTtcbmV4cG9ydHMucnVuQ2FsaWJyYXRpb24gPSBydW5DYWxpYnJhdGlvbjtcbmNvbnN0IFZlYzJEX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vbWFpbi91dGlsL1ZlYzJELmpzXCIpO1xuY29uc3QgZGVlcENvcHlfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYWluL3V0aWwvZGVlcENvcHkuanNcIik7XG5jb25zdCBtYWluX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vbWFpbi9tYWluLmpzXCIpO1xuY29uc3QgY29udHJvbGxlcm1lbnVfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9tZW51cy9jb250cm9sbGVybWVudS5qc1wiKTtcbmNvbnN0IGdhbWVwYWRJbmZvX2pzXzEgPSByZXF1aXJlKFwiLi9nYW1lcGFkSW5mby5qc1wiKTtcbmNvbnN0IGdhbWVwYWRfanNfMSA9IHJlcXVpcmUoXCIuL2dhbWVwYWQuanNcIik7XG5jb25zdCBjdXN0b21fanNfMSA9IHJlcXVpcmUoXCIuL2dhbWVwYWRzL2N1c3RvbS5qc1wiKTtcbmNvbnN0IGZpbmRHYW1lcGFkSW5mb19qc18xID0gcmVxdWlyZShcIi4vZmluZEdhbWVwYWRJbmZvLmpzXCIpO1xuY29uc3Qgc2Z4X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vbWFpbi9zZnguanNcIik7XG5jb25zdCBjYWxpYnJhdGlvbkluUHJvZ3Jlc3MgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuZnVuY3Rpb24gc2V0Q2FsaWJyYXRpb25JblByb2dyZXNzKGksIGJvb2xlYW5lYW4pIHtcbiAgICBjYWxpYnJhdGlvbkluUHJvZ3Jlc3NbaV0gPSBib29sZWFuZWFuO1xufVxuY29uc3QgbnVsbFNuYXBzaG90cyA9IHtcbiAgICBiMDogW10sIGJMOiBbXSwgYlI6IFtdLCBiVTogW10sXG4gICAgYTA6IFtdLCBhTDogW10sIGFSOiBbXSwgYVU6IFtdXG59O1xubGV0IGNsaWNrT2JqZWN0ID0gbnVsbDtcbmZ1bmN0aW9uIHNldENsaWNrT2JqZWN0KGNsaWNrKSB7XG4gICAgaWYgKGNsaWNrT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIGNsaWNrT2JqZWN0ID0gY2xpY2s7XG4gICAgfVxufVxubGV0IGNsaWNrT2JqZWN0TnVtYmVyID0gMDtcbmZ1bmN0aW9uIHNldENsaWNrT2JqZWN0TnVtYmVyKGspIHtcbiAgICBjbGlja09iamVjdE51bWJlciA9IGs7XG59XG5leHBvcnRzLmN1c3RvbUdhbWVwYWRJbmZvSXNVc2FibGUgPSBbdHJ1ZSwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG5sZXQgbGlzdGVuaW5nID0gZmFsc2U7XG5jb25zdCBpZHMgPSBbXCJhXCIsIFwiYlwiLCBcInhcIiwgXCJ5XCIsIFwic1wiLCBcInJcIiwgXCJsXCIsIFwielwiLCBcImRwYWRcIiwgXCJpY29uXCIsIFwibHNcIiwgXCJjc1wiXTtcbi8vIGFkZCBsaXN0ZW5lcnMgZm9yIGNsaWNrXG4vLyB0aGVzZSB0dXJuIG9mZiB3aGVuIHRoZSBTVkcgaXMgbm90IGRpc3BsYXllZCwgc28gc2hvdWxkbid0IGltcGFjdCBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gbGlzdGVuKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gJEZsb3dGaXhNZSBpZ25vcmUgdGhlIGZvbGxvd2luZyB0eXBlIGVycm9yXG4gICAgY29uc3Qgc3ZnRG9jID0gKF9hID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lcGFkU1ZHQ2FsaWJyYXRpb25cIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRzW2ldO1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IFwiaWQgaXMgbnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgKF9iID0gc3ZnRG9jID09PSBudWxsIHx8IHN2Z0RvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ZnRG9jLmdldEVsZW1lbnRCeUlkKGlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgY2xpY2tPYmplY3QgPSBpZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlbmluZyA9IHRydWU7XG59XG5jb25zdCBkZWZhdWx0VGV4dHMgPSBbXCJDbGljayBidXR0b24sIHRyaWdnZXIgb3IgYW5hbG9nIHN0aWNrIHRvIHJlYmluZC5cIl07XG5jb25zdCBlcnJvclRleHQgPSBbXCJFcnJvcjogbm8gY29udHJvbGxlciBkZXRlY3RlZFwiXTtcbi8vIGZpZ3VyZSBvdXQgd2hpY2ggY3VzdG9tIGdhbWVwYWQgaW5mb3MgYXJlIHVzYWJsZSBieSB0aGUgY3VycmVudCBjb250cm9sbGVyXG4vLyBzZXRzIHRoZSB2YWx1ZSBmb3IgY3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZVxuZnVuY3Rpb24gc2V0Q3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZShqKSB7XG4gICAgY29uc3QgY3VycmVudEdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgIGlmIChjdXJyZW50R2FtZXBhZCkge1xuICAgICAgICBjb25zdCBjdXJyZW50R2FtZXBhZElkID0gY3VycmVudEdhbWVwYWQuaWQ7XG4gICAgICAgIGlmICgoMCwgZmluZEdhbWVwYWRJbmZvX2pzXzEuZ2V0R2FtZXBhZE5hbWVBbmRJbmZvKShjdXJyZW50R2FtZXBhZElkKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZXhwb3J0cy5jdXN0b21HYW1lcGFkSW5mb0lzVXNhYmxlWzBdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMuY3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZVswXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCA4OyBrKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlQ3VzdG9tR2FtZXBhZEluZm8gPSAoMCwgY3VzdG9tX2pzXzEuZ2V0Q3VzdG9tR2FtZXBhZEluZm8pKGspO1xuICAgICAgICAgICAgaWYgKG1heWJlQ3VzdG9tR2FtZXBhZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmN1c3RvbUdhbWVwYWRJbmZvSXNVc2FibGVba10gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHYW1lcGFkSWQgPT09IG1heWJlQ3VzdG9tR2FtZXBhZEluZm8uZnVsbElEKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuY3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZVtrXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmN1c3RvbUdhbWVwYWRJbmZvSXNVc2FibGVba10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cG9ydHMuY3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZVswXSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcnVuQ2FsaWJyYXRpb24oaSkge1xuICAgIGlmICghY2FsaWJyYXRpb25JblByb2dyZXNzW2ldKSB7XG4gICAgICAgIHNldENhbGlicmF0aW9uSW5Qcm9ncmVzcyhpLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSAyMDAwO1xuICAgICAgICBjb25zdCBqID0gbWFpbl9qc18xLmN1cnJlbnRQbGF5ZXJzW2ldO1xuICAgICAgICBjb25zdCBwcmV2R2FtZXBhZEluZm8gPSBtYWluX2pzXzEubVR5cGVbaV0gPT09IG51bGwgfHwgbWFpbl9qc18xLm1UeXBlW2ldID09PSBcImtleWJvYXJkXCIgPyBnYW1lcGFkSW5mb19qc18xLm51bGxHYW1lcGFkSW5mbyA6IG1haW5fanNfMS5tVHlwZVtpXTtcbiAgICAgICAgY29uc3QgZ2FtZXBhZEluZm8gPSAoMCwgZGVlcENvcHlfanNfMS5kZWVwQ29weU9iamVjdCkodHJ1ZSwgcHJldkdhbWVwYWRJbmZvKTtcbiAgICAgICAgc2V0Q3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZShqKTtcbiAgICAgICAgY2xpY2tPYmplY3QgPSBudWxsO1xuICAgICAgICBpZiAobGlzdGVuaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbGlzdGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbXCJNb3VzZS1jbGljayB0aGUgc3RhcnQgYnV0dG9uIHRvIGJlZ2luIGNhbGlicmF0aW9uLlwiXSwgMCk7XG4gICAgICAgIHByZUNhbGlicmF0aW9uTG9vcChpLCBqLCBnYW1lcGFkSW5mbywgaW50ZXJ2YWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc2V0R2FtZXBhZEluZm8oaikge1xuICAgIGNvbnN0IGdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgIGxldCBiYXNlR2FtZXBhZEluZm8gPSBnYW1lcGFkSW5mb19qc18xLm51bGxHYW1lcGFkSW5mbztcbiAgICBpZiAoZ2FtZXBhZCAhPT0gdW5kZWZpbmVkICYmIGdhbWVwYWQgIT09IG51bGwgJiYgZ2FtZXBhZC5pZCAhPT0gdW5kZWZpbmVkICYmIGdhbWVwYWQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbWF5YmVOYW1lQW5kSW5mbyA9ICgwLCBmaW5kR2FtZXBhZEluZm9fanNfMS5nZXRHYW1lcGFkTmFtZUFuZEluZm8pKGdhbWVwYWQuaWQpO1xuICAgICAgICBpZiAobWF5YmVOYW1lQW5kSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmFzZUdhbWVwYWRJbmZvID0gKDAsIGRlZXBDb3B5X2pzXzEuZGVlcENvcHlPYmplY3QpKHRydWUsIG1heWJlTmFtZUFuZEluZm9bMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlR2FtZXBhZEluZm87XG59XG5mdW5jdGlvbiBzYXZlU291bmQoKSB7XG4gICAgc2Z4X2pzXzEuc291bmRzLnN0YXIucGxheSgpO1xufVxuZnVuY3Rpb24gcHJlQ2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBpbnRlcnZhbCkge1xuICAgIGlmIChjbGlja09iamVjdCA9PT0gXCJzXCIpIHtcbiAgICAgICAgc2Z4X2pzXzEuc291bmRzLmJsdW50aGl0LnBsYXkoKTtcbiAgICAgICAgKDAsIGN1c3RvbV9qc18xLnNldEN1c3RvbUdhbWVwYWRJbmZvKShqLCBnYW1lcGFkSW5mbyk7XG4gICAgICAgICgwLCBtYWluX2pzXzEuc2V0VXNpbmdDdXN0b21Db250cm9scykoaSwgdHJ1ZSk7XG4gICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgW1wiRmluZGluZyBjb250cm9sbGVyIG5ldXRyYWwgcG9pbnQuXCIsIFwiRG8gbm90IHByZXNzIGFueXRoaW5nLlwiXSwgaW50ZXJ2YWwpO1xuICAgICAgICAvLyB0YWtlIG51bGwgc25hcHNob3RcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAoMCwgbWFpbl9qc18xLnNldENvbnRyb2xsZXJSZXNldCkoaSk7XG4gICAgICAgICAgICBzYXZlU291bmQoKTtcbiAgICAgICAgICAgIGNvbnN0IGdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgICAgICAgICAgaWYgKGdhbWVwYWQgIT09IHVuZGVmaW5lZCAmJiBnYW1lcGFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3RzID0gbnVsbFNuYXBzaG90cztcbiAgICAgICAgICAgICAgICBzbmFwc2hvdHMuYjAgPSAoMCwgZGVlcENvcHlfanNfMS5kZWVwQ29weUFycmF5KSh0cnVlLCBnYW1lcGFkLmJ1dHRvbnMpO1xuICAgICAgICAgICAgICAgIHNuYXBzaG90cy5hMCA9ICgwLCBkZWVwQ29weV9qc18xLmRlZXBDb3B5QXJyYXkpKHRydWUsIGdhbWVwYWQuYXhlcyk7XG4gICAgICAgICAgICAgICAgY2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBzbmFwc2hvdHMsIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS51cGRhdGVDb250cm9sbGVyTWVudSkoZmFsc2UsIGRlZmF1bHRUZXh0cywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS51cGRhdGVDb250cm9sbGVyTWVudSkoZmFsc2UsIGVycm9yVGV4dCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGludGVydmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xpY2tPYmplY3QgPT09IFwiZXhpdFwiKSB7XG4gICAgICAgIHNmeF9qc18xLnNvdW5kcy5tZW51QmFjay5wbGF5KCk7XG4gICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KSh0cnVlLCBbXCJRdWl0dGluZyBjYWxpYnJhdGlvbiBtZW51LlwiXSwgaW50ZXJ2YWwpO1xuICAgICAgICBzZXRDYWxpYnJhdGlvbkluUHJvZ3Jlc3MoaSwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbGlja09iamVjdCA9PT0gXCJyZXNldFwiKSB7XG4gICAgICAgIHNmeF9qc18xLnNvdW5kcy5sb3VkZWxlY3RyaWNmaXp6LnBsYXkoKTtcbiAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEuc2V0Q3VzdG9tSW5Vc2UpKDApO1xuICAgICAgICBjb25zdCBiYXNlR2FtZXBhZEluZm8gPSByZXNldEdhbWVwYWRJbmZvKGopO1xuICAgICAgICAoMCwgbWFpbl9qc18xLnNldFVzaW5nQ3VzdG9tQ29udHJvbHMpKGksIGZhbHNlLCBiYXNlR2FtZXBhZEluZm8pO1xuICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS51cGRhdGVDb250cm9sbGVyTWVudSkoZmFsc2UsIFtcIkNvbnRyb2xsZXIgYmluZGluZ3MgaGF2ZSBiZWVuIHJlc2V0LlwiLCBcIkNsaWNrIHRoZSBzdGFydCBidXR0b24gdG8gYmVnaW4gY2FsaWJyYXRpb24uXCJdLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcmVDYWxpYnJhdGlvbkxvb3AoaSwgaiwgYmFzZUdhbWVwYWRJbmZvLCBpbnRlcnZhbCksIDE2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xpY2tPYmplY3QgPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgc2F2ZVNvdW5kKCk7XG4gICAgICAgICgwLCBtYWluX2pzXzEuc2V0Q29udHJvbGxlclJlc2V0KShpKTtcbiAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbXCJDb250cm9sbGVyIGhhcyBiZWVuIHJlLWNlbnRlcmVkLlwiLCBcIkNsaWNrIHRoZSBzdGFydCBidXR0b24gdG8gYmVnaW4gY2FsaWJyYXRpb24uXCJdLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcmVDYWxpYnJhdGlvbkxvb3AoaSwgaiwgZ2FtZXBhZEluZm8sIGludGVydmFsKSwgMTYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbGlja09iamVjdCA9PT0gXCJsb2FkQ3VzdG9tXCIpIHtcbiAgICAgICAgaWYgKGNsaWNrT2JqZWN0TnVtYmVyID09PSAwKSB7XG4gICAgICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS5zZXRDdXN0b21JblVzZSkoMCk7XG4gICAgICAgICAgICBjb25zdCBiYXNlR2FtZXBhZEluZm8gPSByZXNldEdhbWVwYWRJbmZvKGopO1xuICAgICAgICAgICAgKDAsIG1haW5fanNfMS5zZXRVc2luZ0N1c3RvbUNvbnRyb2xzKShpLCBmYWxzZSwgYmFzZUdhbWVwYWRJbmZvKTtcbiAgICAgICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgW1wiTm93IHVzaW5nIGRlZmF1bHQgY29udHJvbGxlciBiaW5kaW5ncy5cIiwgXCJDbGljayB0aGUgc3RhcnQgYnV0dG9uIHRvIGJlZ2luIGNhbGlicmF0aW9uLlwiXSwgMCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHByZUNhbGlicmF0aW9uTG9vcChpLCBqLCBiYXNlR2FtZXBhZEluZm8sIGludGVydmFsKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3Q3VzdG9tR2FtZXBhZEluZm8gPSAoMCwgY3VzdG9tX2pzXzEuZ2V0Q3VzdG9tR2FtZXBhZEluZm8pKGNsaWNrT2JqZWN0TnVtYmVyKTtcbiAgICAgICAgICAgIGlmIChuZXdDdXN0b21HYW1lcGFkSW5mbyA9PT0gbnVsbCB8fCBleHBvcnRzLmN1c3RvbUdhbWVwYWRJbmZvSXNVc2FibGVbY2xpY2tPYmplY3ROdW1iZXJdICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2Z4X2pzXzEuc291bmRzLmRlbnkucGxheSgpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJlQ2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBpbnRlcnZhbCksIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0dhbWVwYWRJbmZvID0gbmV3Q3VzdG9tR2FtZXBhZEluZm8uZ2FtZXBhZEluZm87XG4gICAgICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEuc2V0Q3VzdG9tSW5Vc2UpKGNsaWNrT2JqZWN0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAoMCwgY3VzdG9tX2pzXzEuc2V0Q3VzdG9tR2FtZXBhZEluZm8pKGosIG5ld0dhbWVwYWRJbmZvKTtcbiAgICAgICAgICAgICAgICAoMCwgbWFpbl9qc18xLnNldFVzaW5nQ3VzdG9tQ29udHJvbHMpKGksIHRydWUpO1xuICAgICAgICAgICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgW1wiTm93IHVzaW5nIGN1c3RvbSBiaW5kaW5ncyAjXCIgKyBjbGlja09iamVjdE51bWJlciArIFwiLlwiLCBcIkNsaWNrIHRoZSBzdGFydCBidXR0b24gdG8gYmVnaW4gY2FsaWJyYXRpb24uXCJdLCAwKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHByZUNhbGlicmF0aW9uTG9vcChpLCBqLCBuZXdHYW1lcGFkSW5mbywgaW50ZXJ2YWwpLCAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2xpY2tPYmplY3QgPT09IFwic2F2ZUN1c3RvbVwiKSB7XG4gICAgICAgIGlmIChjbGlja09iamVjdE51bWJlciA8IDEpIHtcbiAgICAgICAgICAgIHNmeF9qc18xLnNvdW5kcy5kZW55LnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMuY3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZVtjbGlja09iamVjdE51bWJlcl0gPSB0cnVlO1xuICAgICAgICAgICAgKDAsIGN1c3RvbV9qc18xLnN0b3JlQ3VzdG9tR2FtZXBhZEluZm8pKGdhbWVwYWRJbmZvLCAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopLmlkLCAoXCJjdXN0b21cIiArIGNsaWNrT2JqZWN0TnVtYmVyKSwgY2xpY2tPYmplY3ROdW1iZXIpO1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEuc2V0Q3VzdG9tSW5Vc2UpKGNsaWNrT2JqZWN0TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHByZUNhbGlicmF0aW9uTG9vcChpLCBqLCBnYW1lcGFkSW5mbywgaW50ZXJ2YWwpLCAxNik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2xpY2tPYmplY3QgPT09IFwiaWNvblwiKSB7XG4gICAgICAgICAgICBzZnhfanNfMS5zb3VuZHMuc2hvdXQ4LnBsYXkoKTtcbiAgICAgICAgICAgIHNmeF9qc18xLnNvdW5kcy5zd29yZDMucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJlQ2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBpbnRlcnZhbCksIDE2KTtcbiAgICB9XG4gICAgY2xpY2tPYmplY3QgPSBudWxsO1xufVxuO1xuZnVuY3Rpb24gY2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBzbmFwc2hvdHMsIGludGVydmFsKSB7XG4gICAgaWYgKGNsaWNrT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBzbmFwc2hvdHMsIGludGVydmFsKTtcbiAgICAgICAgfSwgMTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FsaWJyYXRlT2JqZWN0KGksIGosIGdhbWVwYWRJbmZvLCBzbmFwc2hvdHMsIGludGVydmFsKTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBjYWxpYnJhdGVPYmplY3QoaSwgaiwgZ2FtZXBhZEluZm8sIHNuYXBzaG90cywgaW50ZXJ2YWwpIHtcbiAgICBsZXQgdGV4dHM7XG4gICAgbGV0IGdhbWVwYWQ7XG4gICAgbGV0IHRvdGFsSW50ZXJ2YWwgPSBpbnRlcnZhbCArIDE2O1xuICAgIGlmIChjbGlja09iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImVycm9yIGluIGZ1bmN0aW9uICdjYWxpYnJhdGVPYmplY3QnOiBjYWxpYnJhdGlvbiBjYWxsZWQgb24gbnVsbCBvYmplY3RcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNsaWNrT2JqZWN0ID09PSBcImljb25cIikge1xuICAgICAgICBzZnhfanNfMS5zb3VuZHMuc2hvdXQ4LnBsYXkoKTtcbiAgICAgICAgc2Z4X2pzXzEuc291bmRzLnN3b3JkMy5wbGF5KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNsaWNrT2JqZWN0ID09PSBcImV4aXRcIikge1xuICAgICAgICBzZnhfanNfMS5zb3VuZHMubWVudUJhY2sucGxheSgpO1xuICAgICAgICBzZXRDYWxpYnJhdGlvbkluUHJvZ3Jlc3MoaSwgZmFsc2UpO1xuICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS51cGRhdGVDb250cm9sbGVyTWVudSkodHJ1ZSwgW1wiUXVpdHRpbmcgY2FsaWJyYXRpb24gbWVudS5cIl0sIGludGVydmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xpY2tPYmplY3QgPT09IFwicmVzZXRcIikge1xuICAgICAgICBzZnhfanNfMS5zb3VuZHMubG91ZGVsZWN0cmljZml6ei5wbGF5KCk7XG4gICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnNldEN1c3RvbUluVXNlKSgwKTtcbiAgICAgICAgY29uc3QgYmFzZUdhbWVwYWRJbmZvID0gcmVzZXRHYW1lcGFkSW5mbyhqKTtcbiAgICAgICAgKDAsIGN1c3RvbV9qc18xLnNldEN1c3RvbUdhbWVwYWRJbmZvKShqLCBiYXNlR2FtZXBhZEluZm8pO1xuICAgICAgICAoMCwgbWFpbl9qc18xLnNldFVzaW5nQ3VzdG9tQ29udHJvbHMpKGksIGZhbHNlLCBiYXNlR2FtZXBhZEluZm8pO1xuICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS51cGRhdGVDb250cm9sbGVyTWVudSkoZmFsc2UsIFtcIkNvbnRyb2xsZXIgYmluZGluZ3MgaGF2ZSBiZWVuIHJlc2V0LlwiLCBcIkNsaWNrIHRoZSBzdGFydCBidXR0b24gdG8gYmVnaW4gY2FsaWJyYXRpb24uXCJdLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcmVDYWxpYnJhdGlvbkxvb3AoaSwgaiwgYmFzZUdhbWVwYWRJbmZvLCBpbnRlcnZhbCksIDE2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2xpY2tPYmplY3QgPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgc2F2ZVNvdW5kKCk7XG4gICAgICAgICgwLCBtYWluX2pzXzEuc2V0Q29udHJvbGxlclJlc2V0KShpKTtcbiAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbXCJDb250cm9sbGVyIGhhcyBiZWVuIHJlLWNlbnRlcmVkLlwiLCBcIkNsaWNrIHRoZSBzdGFydCBidXR0b24gdG8gY29udGludWUgY2FsaWJyYXRpb24uXCJdLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcmVDYWxpYnJhdGlvbkxvb3AoaSwgaiwgZ2FtZXBhZEluZm8sIGludGVydmFsKSwgMTYpO1xuICAgICAgICB0b3RhbEludGVydmFsID0gMTY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNsaWNrT2JqZWN0ID09PSBcImxvYWRDdXN0b21cIikge1xuICAgICAgICBpZiAoY2xpY2tPYmplY3ROdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnNldEN1c3RvbUluVXNlKSgwKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VHYW1lcGFkSW5mbyA9IHJlc2V0R2FtZXBhZEluZm8oaik7XG4gICAgICAgICAgICAoMCwgbWFpbl9qc18xLnNldFVzaW5nQ3VzdG9tQ29udHJvbHMpKGksIGZhbHNlLCBiYXNlR2FtZXBhZEluZm8pO1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbXCJOb3cgdXNpbmcgZGVmYXVsdCBjb250cm9sbGVyIGJpbmRpbmdzLlwiLCBcIkNsaWNrIHRoZSBzdGFydCBidXR0b24gdG8gYmVnaW4gY2FsaWJyYXRpb24uXCJdLCAwKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJlQ2FsaWJyYXRpb25Mb29wKGksIGosIGJhc2VHYW1lcGFkSW5mbywgaW50ZXJ2YWwpLCAxNik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDdXN0b21HYW1lcGFkSW5mbyA9ICgwLCBjdXN0b21fanNfMS5nZXRDdXN0b21HYW1lcGFkSW5mbykoY2xpY2tPYmplY3ROdW1iZXIpO1xuICAgICAgICAgICAgaWYgKG5ld0N1c3RvbUdhbWVwYWRJbmZvID09PSBudWxsIHx8IGV4cG9ydHMuY3VzdG9tR2FtZXBhZEluZm9Jc1VzYWJsZVtjbGlja09iamVjdE51bWJlcl0gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZnhfanNfMS5zb3VuZHMuZGVueS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBwcmVDYWxpYnJhdGlvbkxvb3AoaSwgaiwgZ2FtZXBhZEluZm8sIGludGVydmFsKSwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3R2FtZXBhZEluZm8gPSBuZXdDdXN0b21HYW1lcGFkSW5mby5nYW1lcGFkSW5mbztcbiAgICAgICAgICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS5zZXRDdXN0b21JblVzZSkoY2xpY2tPYmplY3ROdW1iZXIpO1xuICAgICAgICAgICAgICAgICgwLCBjdXN0b21fanNfMS5zZXRDdXN0b21HYW1lcGFkSW5mbykoaiwgbmV3R2FtZXBhZEluZm8pO1xuICAgICAgICAgICAgICAgICgwLCBtYWluX2pzXzEuc2V0VXNpbmdDdXN0b21Db250cm9scykoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbXCJOb3cgdXNpbmcgY3VzdG9tIGJpbmRpbmdzICNcIiArIGNsaWNrT2JqZWN0TnVtYmVyICsgXCIuXCIsIFwiQ2xpY2sgdGhlIHN0YXJ0IGJ1dHRvbiB0byBiZWdpbiBjYWxpYnJhdGlvbi5cIl0sIDApO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcHJlQ2FsaWJyYXRpb25Mb29wKGksIGosIG5ld0dhbWVwYWRJbmZvLCBpbnRlcnZhbCksIDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjbGlja09iamVjdCA9PT0gXCJzYXZlQ3VzdG9tXCIpIHtcbiAgICAgICAgaWYgKGNsaWNrT2JqZWN0TnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgc2Z4X2pzXzEuc291bmRzLmRlbnkucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwb3J0cy5jdXN0b21HYW1lcGFkSW5mb0lzVXNhYmxlW2NsaWNrT2JqZWN0TnVtYmVyXSA9IHRydWU7XG4gICAgICAgICAgICAoMCwgY3VzdG9tX2pzXzEuc3RvcmVDdXN0b21HYW1lcGFkSW5mbykoZ2FtZXBhZEluZm8sICgwLCBnYW1lcGFkX2pzXzEuZ2V0R2FtZXBhZCkoaikuaWQsIChcImN1c3RvbVwiICsgY2xpY2tPYmplY3ROdW1iZXIpLCBjbGlja09iamVjdE51bWJlcik7XG4gICAgICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS5zZXRDdXN0b21JblVzZSkoY2xpY2tPYmplY3ROdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNsaWNrT2JqZWN0ID09PSBcImxcIiB8fCBjbGlja09iamVjdCA9PT0gXCJyXCIpIHtcbiAgICAgICAgdGV4dHMgPSBbXCJGdWxseSBkZXByZXNzIFwiICsgY2xpY2tPYmplY3QudG9VcHBlckNhc2UoKSArIFwiIHRyaWdnZXIuXCIsIFwiS2VlcCBob2xkaW5nIGRvd24gdGhlIHRyaWdnZXIuXCJdO1xuICAgICAgICBjb25zdCB0ID0gY2xpY2tPYmplY3Q7IC8vIHBhc3NlZCBhcy1pcyBpbiB0aGUgY2xvc3VyZVxuICAgICAgICBjb25zdCB0QSA9IGNsaWNrT2JqZWN0ICsgXCJBXCI7XG4gICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgdGV4dHMsIGludGVydmFsKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzYXZlU291bmQoKTtcbiAgICAgICAgICAgIGdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgICAgICAgICAgZ2FtZXBhZEluZm9bdF0gPSBzY2FuRm9yQnV0dG9uKHNuYXBzaG90cy5iMCwgZ2FtZXBhZC5idXR0b25zLCBzbmFwc2hvdHMuYTAsIGdhbWVwYWQuYXhlcywgdHJ1ZSk7XG4gICAgICAgICAgICBnYW1lcGFkSW5mb1t0QV0gPSBzY2FuRm9yVHJpZ2dlcihzbmFwc2hvdHMuYjAsIGdhbWVwYWQuYnV0dG9ucywgc25hcHNob3RzLmEwLCBnYW1lcGFkLmF4ZXMpO1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBkZWZhdWx0VGV4dHMsIDApO1xuICAgICAgICAgICAgaWYgKHQgPT09IFwibFwiICYmIGdhbWVwYWRJbmZvLmxBICE9PSBudWxsICYmIChnYW1lcGFkSW5mby5sQS5raW5kID09PSBcInZhbHVlXCIgfHwgZ2FtZXBhZEluZm8ubEEua2luZCA9PT0gXCJheGlzXCIpKSB7XG4gICAgICAgICAgICAgICAgZ2FtZXBhZEluZm8uaXNHQyA9IE1hdGguYWJzKGdhbWVwYWRJbmZvLmxBLm1pbiArIDAuODY2KSA8IDAuMDEgPyB0cnVlIDogZmFsc2U7IC8vIGhhY2t5IGJ1dCBoZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbGlja09iamVjdCA9PT0gXCJsc1wiIHx8IGNsaWNrT2JqZWN0ID09PSBcImNzXCIgfHwgY2xpY2tPYmplY3QgPT09IFwiZHBhZFwiKSB7XG4gICAgICAgIGxldCBzZXAgPSBcIixcIjtcbiAgICAgICAgaWYgKGNsaWNrT2JqZWN0ID09PSBcImxzXCIpIHtcbiAgICAgICAgICAgIHRleHRzID0gW1wiTW92ZSBsZWZ0IGFuYWxvZyBzdGljayBhbGwgdGhlIHdheSBcIiwgXCJhbmQga2VlcCBpdCB0aGVyZS5cIl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xpY2tPYmplY3QgPT09IFwiY3NcIikge1xuICAgICAgICAgICAgdGV4dHMgPSBbXCJNb3ZlIGMtc3RpY2sgYWxsIHRoZSB3YXkgXCIsIFwiYW5kIGtlZXAgaXQgdGhlcmUuXCJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VwID0gXCIuXCI7XG4gICAgICAgICAgICB0ZXh0cyA9IFtcIlByZXNzIGFuZCBob2xkIGQtcGFkIFwiXTtcbiAgICAgICAgfVxuICAgICAgICB0b3RhbEludGVydmFsICs9IDUgKiBpbnRlcnZhbDtcbiAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbdGV4dHNbMF0gKyBcImxlZnRcIiArIHNlcCwgdGV4dHNbMV1dLCAxLjUgKiBpbnRlcnZhbCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2F2ZVNvdW5kKCk7XG4gICAgICAgICAgICBnYW1lcGFkID0gKDAsIGdhbWVwYWRfanNfMS5nZXRHYW1lcGFkKShqKTtcbiAgICAgICAgICAgIHNuYXBzaG90cy5iTCA9ICgwLCBkZWVwQ29weV9qc18xLmRlZXBDb3B5QXJyYXkpKHRydWUsIGdhbWVwYWQuYnV0dG9ucyk7XG4gICAgICAgICAgICBzbmFwc2hvdHMuYUwgPSAoMCwgZGVlcENvcHlfanNfMS5kZWVwQ29weUFycmF5KSh0cnVlLCBnYW1lcGFkLmF4ZXMpO1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbdGV4dHNbMF0gKyBcInJpZ2h0XCIgKyBzZXAsIHRleHRzWzFdXSwgMS41ICogaW50ZXJ2YWwpO1xuICAgICAgICB9LCAxLjUgKiBpbnRlcnZhbCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2F2ZVNvdW5kKCk7XG4gICAgICAgICAgICBnYW1lcGFkID0gKDAsIGdhbWVwYWRfanNfMS5nZXRHYW1lcGFkKShqKTtcbiAgICAgICAgICAgIHNuYXBzaG90cy5iUiA9ICgwLCBkZWVwQ29weV9qc18xLmRlZXBDb3B5QXJyYXkpKHRydWUsIGdhbWVwYWQuYnV0dG9ucyk7XG4gICAgICAgICAgICBzbmFwc2hvdHMuYVIgPSAoMCwgZGVlcENvcHlfanNfMS5kZWVwQ29weUFycmF5KSh0cnVlLCBnYW1lcGFkLmF4ZXMpO1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBbdGV4dHNbMF0gKyBcInVwXCIgKyBzZXAsIHRleHRzWzFdXSwgMS41ICogaW50ZXJ2YWwpO1xuICAgICAgICB9LCAzICogaW50ZXJ2YWwpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNhdmVTb3VuZCgpO1xuICAgICAgICAgICAgZ2FtZXBhZCA9ICgwLCBnYW1lcGFkX2pzXzEuZ2V0R2FtZXBhZCkoaik7XG4gICAgICAgICAgICBzbmFwc2hvdHMuYlUgPSAoMCwgZGVlcENvcHlfanNfMS5kZWVwQ29weUFycmF5KSh0cnVlLCBnYW1lcGFkLmJ1dHRvbnMpO1xuICAgICAgICAgICAgc25hcHNob3RzLmFVID0gKDAsIGRlZXBDb3B5X2pzXzEuZGVlcENvcHlBcnJheSkodHJ1ZSwgZ2FtZXBhZC5heGVzKTtcbiAgICAgICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgW3RleHRzWzBdICsgXCJkb3duXCIgKyBzZXAsIHRleHRzWzFdXSwgMS41ICogaW50ZXJ2YWwpO1xuICAgICAgICB9LCA0LjUgKiBpbnRlcnZhbCk7XG4gICAgICAgIGlmIChjbGlja09iamVjdCA9PT0gXCJkcGFkXCIpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNhdmVTb3VuZCgpO1xuICAgICAgICAgICAgICAgIGdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgICAgICAgICAgICAgIGdhbWVwYWRJbmZvLmRwYWQgPSBzY2FuRm9yRFBhZChzbmFwc2hvdHMuYjAsIHNuYXBzaG90cy5iTCwgc25hcHNob3RzLmJSLCBzbmFwc2hvdHMuYlUsIGdhbWVwYWQuYnV0dG9ucywgc25hcHNob3RzLmEwLCBzbmFwc2hvdHMuYUwsIHNuYXBzaG90cy5hUiwgc25hcHNob3RzLmFVLCBnYW1lcGFkLmF4ZXMpO1xuICAgICAgICAgICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgZGVmYXVsdFRleHRzLCAwKTtcbiAgICAgICAgICAgIH0sIDYgKiBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbGlja05vdyA9IGNsaWNrT2JqZWN0OyAvLyBwYXNzZWQgYXMtaXMgaW4gdGhlIGNsb3N1cmVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNhdmVTb3VuZCgpO1xuICAgICAgICAgICAgICAgIGdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgICAgICAgICAgICAgIGdhbWVwYWRJbmZvW2NsaWNrTm93XSA9IHNjYW5Gb3JTdGljayhzbmFwc2hvdHMuYjAsIHNuYXBzaG90cy5iTCwgc25hcHNob3RzLmJSLCBzbmFwc2hvdHMuYlUsIGdhbWVwYWQuYnV0dG9ucywgc25hcHNob3RzLmEwLCBzbmFwc2hvdHMuYUwsIHNuYXBzaG90cy5hUiwgc25hcHNob3RzLmFVLCBnYW1lcGFkLmF4ZXMpO1xuICAgICAgICAgICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgZGVmYXVsdFRleHRzLCAwKTtcbiAgICAgICAgICAgIH0sIDYgKiBpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7IC8vIG9ubHkgcGxhaW4gYnV0dG9ucyBsZWZ0IG5vd1xuICAgICAgICBjb25zdCBidXR0b25OYW1lID0gY2xpY2tPYmplY3QgPT09IFwic1wiID8gXCJzdGFydFwiIDogY2xpY2tPYmplY3QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdGV4dHMgPSBbXCJQcmVzcyBhbmQgaG9sZCBcIiArIGJ1dHRvbk5hbWUgKyBcIi5cIl07XG4gICAgICAgIGNvbnN0IGNsaWNrTm93ID0gY2xpY2tPYmplY3Q7XG4gICAgICAgICgwLCBjb250cm9sbGVybWVudV9qc18xLnVwZGF0ZUNvbnRyb2xsZXJNZW51KShmYWxzZSwgdGV4dHMsIGludGVydmFsKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzYXZlU291bmQoKTtcbiAgICAgICAgICAgIGdhbWVwYWQgPSAoMCwgZ2FtZXBhZF9qc18xLmdldEdhbWVwYWQpKGopO1xuICAgICAgICAgICAgZ2FtZXBhZEluZm9bY2xpY2tOb3ddID0gc2NhbkZvckJ1dHRvbihzbmFwc2hvdHMuYjAsIGdhbWVwYWQuYnV0dG9ucywgc25hcHNob3RzLmEwLCBnYW1lcGFkLmF4ZXMpO1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51X2pzXzEudXBkYXRlQ29udHJvbGxlck1lbnUpKGZhbHNlLCBkZWZhdWx0VGV4dHMsIDApO1xuICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgfVxuICAgIGlmIChjbGlja09iamVjdCAhPT0gXCJleGl0XCIgJiYgY2xpY2tPYmplY3QgIT09IFwicmVzZXRcIiAmJiBjbGlja09iamVjdCAhPT0gXCJjZW50ZXJcIiAmJiBjbGlja09iamVjdCAhPT0gXCJsb2FkQ3VzdG9tXCIpIHtcbiAgICAgICAgaWYgKGNsaWNrT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZnhfanNfMS5zb3VuZHMuYmx1bnRoaXQucGxheSgpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGN1c3RvbV9qc18xLnNldEN1c3RvbUdhbWVwYWRJbmZvKShqLCBnYW1lcGFkSW5mbyk7XG4gICAgICAgICAgICAgICAgY2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBzbmFwc2hvdHMsIGludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRvdGFsSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsaWJyYXRpb25Mb29wKGksIGosIGdhbWVwYWRJbmZvLCBzbmFwc2hvdHMsIGludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRvdGFsSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGlja09iamVjdCAhPT0gbnVsbCAmJiBjbGlja09iamVjdCAhPT0gXCJzYXZlQ3VzdG9tXCIgJiYgY2xpY2tPYmplY3QgIT09IFwibG9hZEN1c3RvbVwiXG4gICAgICAgICYmIGNsaWNrT2JqZWN0ICE9PSBcImNlbnRlclwiICYmIGNsaWNrT2JqZWN0ICE9PSBcImljb25cIiAmJiBjbGlja09iamVjdCAhPT0gXCJleGl0XCIgJiYgY2xpY2tPYmplY3QgIT09IFwicmVzZXRcIikge1xuICAgICAgICAoMCwgY29udHJvbGxlcm1lbnVfanNfMS5zZXRDdXN0b21JblVzZSkobnVsbCk7XG4gICAgfVxuICAgIGlmIChjbGlja09iamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBjbGlja09iamVjdCA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbkZvckJ1dHRvbihidXR0b25zMCwgYnV0dG9uczEsIGF4ZXMwLCBheGVzMSwgb25seVByZXNzZWQgPSBmYWxzZSkge1xuICAgIGxldCBidXR0b25JbmZvID0gbnVsbDtcbiAgICBjb25zdCBiTGcgPSBidXR0b25zMS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiTGc7IGkrKykge1xuICAgICAgICBpZiAoZGV0ZWN0ZWRCdXR0b25QcmVzc2VkKGJ1dHRvbnMwW2ldLnByZXNzZWQsIGJ1dHRvbnMxW2ldLnByZXNzZWQpKSB7XG4gICAgICAgICAgICBidXR0b25JbmZvID0geyBraW5kOiBcInByZXNzZWRcIiwgaW5kZXg6IGkgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvbmx5UHJlc3NlZCAmJiBkZXRlY3RlZEJ1dHRvblZhbHVlKGJ1dHRvbnMwW2ldLnZhbHVlLCBidXR0b25zMVtpXS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbkluZm8gPSB7IGtpbmQ6IFwidmFsdWVcIiwgaW5kZXg6IGksIHRocmVzaG9sZDogMC43NSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvbmx5UHJlc3NlZCAmJiBidXR0b25JbmZvID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGFMZyA9IGF4ZXMxLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhTGc7IGorKykge1xuICAgICAgICAgICAgaWYgKGRldGVjdGVkQnV0dG9uVmFsdWUoYXhlczBbal0sIGF4ZXMxW2pdKSkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkluZm8gPSB7IGtpbmQ6IFwiYXhpc1wiLCBpbmRleDogaiwgdGhyZXNob2xkOiAwLjc1IH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1dHRvbkluZm87XG59XG47XG5mdW5jdGlvbiBkZXRlY3RlZEJ1dHRvblByZXNzZWQocHJlc3NlZDAsIHByZXNzZWQxKSB7XG4gICAgcmV0dXJuIHByZXNzZWQxICYmICFwcmVzc2VkMDtcbn1cbjtcbmZ1bmN0aW9uIGRldGVjdGVkQnV0dG9uVmFsdWUodmFsdWUwLCB2YWx1ZTEpIHtcbiAgICByZXR1cm4gKHZhbHVlMCA8IDAuMjUgJiYgdmFsdWUxID4gMC43NSk7XG59XG47XG5mdW5jdGlvbiBzY2FuRm9yVHJpZ2dlcihidXR0b25zMCwgYnV0dG9uczEsIGF4ZXMwLCBheGVzMSkge1xuICAgIGxldCBtaW5NYXg7XG4gICAgbGV0IHRyaWdnZXJJbmZvID0gbnVsbDtcbiAgICBjb25zdCBhTGcgPSBheGVzMS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhTGcgJiYgdHJpZ2dlckluZm8gPT09IG51bGw7IGkrKykge1xuICAgICAgICBtaW5NYXggPSBkZXRlY3RlZFRyaWdnZXIoYXhlczBbaV0sIGF4ZXMxW2ldKTtcbiAgICAgICAgaWYgKG1pbk1heCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJpZ2dlckluZm8gPSB7IGtpbmQ6IFwiYXhpc1wiLCBpbmRleDogaSwgbWluOiBtaW5NYXhbMF0sIG1heDogbWluTWF4WzFdIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHJpZ2dlckluZm8gPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgYkxnID0gYnV0dG9uczEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJMZyAmJiB0cmlnZ2VySW5mbyA9PT0gbnVsbDsgaisrKSB7XG4gICAgICAgICAgICBtaW5NYXggPSBkZXRlY3RlZFRyaWdnZXIoYnV0dG9uczBbal0udmFsdWUsIGJ1dHRvbnMxW2pdLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtaW5NYXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VySW5mbyA9IHsga2luZDogXCJ2YWx1ZVwiLCBpbmRleDogaiwgbWluOiBtaW5NYXhbMF0sIG1heDogbWluTWF4WzFdIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyaWdnZXJJbmZvO1xufVxuZnVuY3Rpb24gZGV0ZWN0ZWRUcmlnZ2VyKGF4aXMwLCBheGlzMSkge1xuICAgIGlmIChNYXRoLmFicyhheGlzMSAtIGF4aXMwKSA8IDAuNSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRNaW5BbmRNYXgoYXhpczAsIGF4aXMxKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNaW5BbmRNYXgoYXhpczAsIGF4aXMxKSB7XG4gICAgY29uc3QgbWluID0gYXhpczAgPCAtMC44NyA/IC0xIDogYXhpczAgPCAtMC41ID8gLTAuODY2IDogYXhpczAgPiAwLjg3ID8gMSA6IGF4aXMwID4gMC41ID8gMC44NjY3IDogMDtcbiAgICBjb25zdCBtYXggPSBtaW4gPT09IDAgPyBNYXRoLnNpZ24oYXhpczEpIDogLW1pbjtcbiAgICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbmZ1bmN0aW9uIHNjYW5Gb3JTdGljayhidXR0b25zMCwgYnV0dG9uc0wsIGJ1dHRvbnNSLCBidXR0b25zVSwgYnV0dG9uc0QsIGF4ZXMwLCBheGVzTCwgYXhlc1IsIGF4ZXNVLCBheGVzRCkge1xuICAgIGxldCBzdGlja0luZm8gPSBudWxsO1xuICAgIGxldCB4RGlmZiA9IDA7XG4gICAgbGV0IHlEaWZmID0gMDtcbiAgICBsZXQgbmV3WERpZmYgPSAwO1xuICAgIGxldCBuZXdZRGlmZiA9IDA7XG4gICAgbGV0IHhJbmRleDtcbiAgICBsZXQgeUluZGV4O1xuICAgIGxldCBraW5kO1xuICAgIGxldCBjYXJkaW5hbHMgPSBudWxsO1xuICAgIGNvbnN0IGFMZyA9IGF4ZXMwLmxlbmd0aDtcbiAgICBraW5kID0gXCJheGVzXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhTGc7IGkrKykge1xuICAgICAgICBuZXdYRGlmZiA9IGF4ZXNSW2ldIC0gYXhlc0xbaV07XG4gICAgICAgIGlmIChNYXRoLmFicyhuZXdYRGlmZikgPiBNYXRoLmFicyh4RGlmZikpIHtcbiAgICAgICAgICAgIHhEaWZmID0gbmV3WERpZmY7XG4gICAgICAgICAgICB4SW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIG5ld1lEaWZmID0gYXhlc1VbaV0gLSBheGVzRFtpXTtcbiAgICAgICAgaWYgKE1hdGguYWJzKG5ld1lEaWZmKSA+IE1hdGguYWJzKHlEaWZmKSkge1xuICAgICAgICAgICAgeURpZmYgPSBuZXdZRGlmZjtcbiAgICAgICAgICAgIHlJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHhJbmRleCAhPT0gdW5kZWZpbmVkICYmIHlJbmRleCAhPT0gdW5kZWZpbmVkICYmIE1hdGguYWJzKHhEaWZmKSA+IDAuNSAmJiBNYXRoLmFicyh5RGlmZikgPiAwLjUpIHtcbiAgICAgICAgY2FyZGluYWxzID0ge1xuICAgICAgICAgICAgY2VudGVyOiBuZXcgVmVjMkRfanNfMS5WZWMyRChheGVzMFt4SW5kZXhdLCBheGVzMFt5SW5kZXhdKSxcbiAgICAgICAgICAgIGxlZnQ6IGF4ZXNMW3hJbmRleF0sXG4gICAgICAgICAgICByaWdodDogYXhlc1JbeEluZGV4XSxcbiAgICAgICAgICAgIHVwOiBheGVzVVt5SW5kZXhdLFxuICAgICAgICAgICAgZG93bjogYXhlc0RbeUluZGV4XVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoeERpZmYpIDwgMC41IHx8IE1hdGguYWJzKHlEaWZmKSA8IDAuNSkge1xuICAgICAgICBjb25zdCBiTGcgPSBidXR0b25zMC5sZW5ndGg7XG4gICAgICAgIGtpbmQgPSBcInZhbHVlXCI7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYkxnOyBqKyspIHtcbiAgICAgICAgICAgIG5ld1hEaWZmID0gYnV0dG9uc1Jbal0udmFsdWUgLSBidXR0b25zTFtqXS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdYRGlmZikgPiBNYXRoLmFicyh4RGlmZikpIHtcbiAgICAgICAgICAgICAgICB4RGlmZiA9IG5ld1hEaWZmO1xuICAgICAgICAgICAgICAgIHhJbmRleCA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdZRGlmZiA9IGJ1dHRvbnNVW2pdLnZhbHVlIC0gYnV0dG9uc0Rbal0udmFsdWU7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3WURpZmYpID4gTWF0aC5hYnMoeURpZmYpKSB7XG4gICAgICAgICAgICAgICAgeURpZmYgPSBuZXdZRGlmZjtcbiAgICAgICAgICAgICAgICB5SW5kZXggPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4SW5kZXggIT09IHVuZGVmaW5lZCAmJiB5SW5kZXggIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyh4RGlmZikgPiAwLjUgJiYgTWF0aC5hYnMoeURpZmYpID4gMC41KSB7XG4gICAgICAgICAgICBjYXJkaW5hbHMgPSB7XG4gICAgICAgICAgICAgICAgY2VudGVyOiBuZXcgVmVjMkRfanNfMS5WZWMyRChidXR0b25zMFt4SW5kZXhdLnZhbHVlLCBidXR0b25zMFt5SW5kZXhdLnZhbHVlKSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBidXR0b25zTFt4SW5kZXhdLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBidXR0b25zUlt4SW5kZXhdLnZhbHVlLFxuICAgICAgICAgICAgICAgIHVwOiBidXR0b25zVVt5SW5kZXhdLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvd246IGJ1dHRvbnNEW3lJbmRleF0udmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHhJbmRleCAhPT0gdW5kZWZpbmVkICYmIHlJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChraW5kID09PSBcImF4ZXNcIikge1xuICAgICAgICAgICAgc3RpY2tJbmZvID0geyBraW5kOiBcImF4ZXNcIiwgeEluZGV4OiB4SW5kZXgsIHlJbmRleDogeUluZGV4LCBjYXJkaW5hbHM6IGNhcmRpbmFscyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RpY2tJbmZvID0geyBraW5kOiBcInZhbHVlXCIsIHhJbmRleDogeEluZGV4LCB5SW5kZXg6IHlJbmRleCwgY2FyZGluYWxzOiBjYXJkaW5hbHMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RpY2tJbmZvO1xufVxuZnVuY3Rpb24gc2NhbkZvckRQYWQoYnV0dG9uczAsIGJ1dHRvbnNMLCBidXR0b25zUiwgYnV0dG9uc1UsIGJ1dHRvbnNELCBheGVzMCwgYXhlc0wsIGF4ZXNSLCBheGVzVSwgYXhlc0QpIHtcbiAgICBsZXQgZFBhZEluZm8gPSBudWxsO1xuICAgIGNvbnN0IGJMZyA9IGJ1dHRvbnMwLmxlbmd0aDtcbiAgICBsZXQgbEluZGV4O1xuICAgIGxldCBySW5kZXg7XG4gICAgbGV0IHVJbmRleDtcbiAgICBsZXQgZEluZGV4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYkxnOyBpKyspIHtcbiAgICAgICAgaWYgKGxJbmRleCA9PT0gdW5kZWZpbmVkICYmIGRldGVjdGVkQnV0dG9uUHJlc3NlZChidXR0b25zMFtpXS5wcmVzc2VkLCBidXR0b25zTFtpXS5wcmVzc2VkKSkge1xuICAgICAgICAgICAgbEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAockluZGV4ID09PSB1bmRlZmluZWQgJiYgZGV0ZWN0ZWRCdXR0b25QcmVzc2VkKGJ1dHRvbnMwW2ldLnByZXNzZWQsIGJ1dHRvbnNSW2ldLnByZXNzZWQpKSB7XG4gICAgICAgICAgICBySW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1SW5kZXggPT09IHVuZGVmaW5lZCAmJiBkZXRlY3RlZEJ1dHRvblByZXNzZWQoYnV0dG9uczBbaV0ucHJlc3NlZCwgYnV0dG9uc1VbaV0ucHJlc3NlZCkpIHtcbiAgICAgICAgICAgIHVJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRJbmRleCA9PT0gdW5kZWZpbmVkICYmIGRldGVjdGVkQnV0dG9uUHJlc3NlZChidXR0b25zMFtpXS5wcmVzc2VkLCBidXR0b25zRFtpXS5wcmVzc2VkKSkge1xuICAgICAgICAgICAgZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobEluZGV4ICE9PSB1bmRlZmluZWQgJiYgckluZGV4ICE9PSB1bmRlZmluZWQgJiYgdUluZGV4ICE9PSB1bmRlZmluZWQgJiYgZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZFBhZEluZm8gPSB7XG4gICAgICAgICAgICBraW5kOiBcImJ1dHRvbnNcIixcbiAgICAgICAgICAgIHVwSW5kZXg6IHVJbmRleCwgZG93bkluZGV4OiBkSW5kZXgsXG4gICAgICAgICAgICBsZWZ0SW5kZXg6IGxJbmRleCwgcmlnaHRJbmRleDogckluZGV4XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeERpZmYgPSAwO1xuICAgICAgICBsZXQgeURpZmYgPSAwO1xuICAgICAgICBsZXQgbmV3WERpZmYgPSAwO1xuICAgICAgICBsZXQgbmV3WURpZmYgPSAwO1xuICAgICAgICBsZXQgeEluZGV4O1xuICAgICAgICBsZXQgeUluZGV4O1xuICAgICAgICBjb25zdCBhTGcgPSBheGVzMC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxnOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1hEaWZmID0gYXhlc1JbaV0gLSBheGVzTFtpXTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdYRGlmZikgPiBNYXRoLmFicyh4RGlmZikpIHtcbiAgICAgICAgICAgICAgICB4RGlmZiA9IG5ld1hEaWZmO1xuICAgICAgICAgICAgICAgIHhJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdZRGlmZiA9IGF4ZXNVW2ldIC0gYXhlc0RbaV07XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobmV3WURpZmYpID4gTWF0aC5hYnMoeURpZmYpKSB7XG4gICAgICAgICAgICAgICAgeURpZmYgPSBuZXdZRGlmZjtcbiAgICAgICAgICAgICAgICB5SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh4SW5kZXggIT09IHVuZGVmaW5lZCAmJiB5SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHhEaWZmKSA+IDAuNSAmJiBNYXRoLmFicyh5RGlmZikgPiAwLjUgJiYgeEluZGV4ICE9PSB5SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkUGFkSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogXCIyYXhlc1wiLFxuICAgICAgICAgICAgICAgICAgICB4SW5kZXg6IHhJbmRleCwgeUluZGV4OiB5SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHhGbGlwOiAoeERpZmYgPCAwKSwgeUZsaXA6ICh5RGlmZiA8IDApXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBsb2xcbiAgICAgICAgICAgICAgICBkUGFkSW5mbyA9IHsga2luZDogXCJheGlzXCIsIGluZGV4OiB4SW5kZXggfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZFBhZEluZm87XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/input/gamepad/gamepadCalibration.ts\n");

/***/ }),

/***/ "./src/input/input.ts":
/*!****************************!*\
  !*** ./src/input/input.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*eslint indent:0*/\n// @flow\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keyboardMap = exports.aiInputBank = exports.aiPlayer4 = exports.aiPlayer3 = exports.aiPlayer2 = exports.aiPlayer1 = exports.nullInputs = exports.nullInput = void 0;\nexports.inputData = inputData;\nexports.pollInputs = pollInputs;\nexports.showButton = showButton;\nexports.setCustomCenters = setCustomCenters;\nconst Vec2D_1 = __webpack_require__(/*! ../main/util/Vec2D */ \"./src/main/util/Vec2D.ts\");\nconst settings_1 = __webpack_require__(/*! ../settings */ \"./src/settings.ts\");\nconst main_1 = __webpack_require__(/*! ../main/main */ \"./src/main/main.ts\");\nconst retrieveGamepadInputs_1 = __webpack_require__(/*! ./gamepad/retrieveGamepadInputs */ \"./src/input/gamepad/retrieveGamepadInputs.ts\");\nconst meleeInputs_1 = __webpack_require__(/*! ./meleeInputs */ \"./src/input/meleeInputs.ts\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"));\nconst replay_1 = __webpack_require__(/*! ../main/replay */ \"./src/main/replay.ts\");\nconst streamclient_1 = __webpack_require__(/*! ../main/multiplayer/streamclient */ \"./src/main/multiplayer/streamclient.js\");\nfunction inputData(list = [false, false, false, false, false, false, false, false, false, false, false, false, 0, 0, 0, 0, 0, 0]) {\n    return {\n        a: list[0],\n        b: list[1],\n        x: list[2],\n        y: list[3],\n        z: list[4],\n        r: list[5],\n        l: list[6],\n        s: list[7],\n        du: list[8],\n        dr: list[9],\n        dd: list[10],\n        dl: list[11],\n        lsX: (0, meleeInputs_1.deaden)(list[12]),\n        lsY: (0, meleeInputs_1.deaden)(list[13]),\n        csX: (0, meleeInputs_1.deaden)(list[14]),\n        csY: (0, meleeInputs_1.deaden)(list[15]),\n        lA: list[16],\n        rA: list[17],\n        rawX: list[12],\n        rawY: list[13],\n        rawcsX: list[14],\n        rawcsY: list[15]\n    };\n}\n;\nconst nullInput = () => inputData();\nexports.nullInput = nullInput;\nconst nullInputs = () => [inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData()\n];\nexports.nullInputs = nullInputs;\nexports.aiPlayer1 = [inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData()\n];\nexports.aiPlayer2 = [inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData()\n];\nexports.aiPlayer3 = [inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData()\n];\nexports.aiPlayer4 = [inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData(),\n    inputData()\n];\nexports.aiInputBank = [exports.aiPlayer1, exports.aiPlayer2, exports.aiPlayer3, exports.aiPlayer4];\n// should be able to move out the \"frameByFrame\" aspect of the following function\n// it is only used to make z button mean \"left trigger value = 0.35\" + \"A = true\".\nfunction pollInputs(gameMode, frameByFrame, controllerInfo, playerSlot, controllerIndex, keys, playertype) {\n    // input is the input for player i in the current frame\n    let input = (0, exports.nullInput)(); // initialise with default values\n    if (replay_1.replayActive) {\n        input = pollReplayInputs(gameMode, controllerInfo, playerSlot, controllerIndex, frameByFrame);\n    }\n    else if (playertype === 1 && gameMode === 3) {\n        return exports.aiInputBank[playerSlot][0];\n    }\n    else if (controllerInfo === \"keyboard\") { // keyboard controls\n        input = pollKeyboardInputs(gameMode, frameByFrame, keys);\n        // } else if (playertype === 2 || controllerInfo === 99) { // np: online play?\n        //   input = pollNetworkInputs(gameMode, controllerInfo, playerSlot, controllerIndex, frameByFrame);\n    }\n    else if (playertype === 0) {\n        input = pollGamepadInputs(gameMode, controllerInfo, playerSlot, controllerIndex, frameByFrame);\n    }\n    return input;\n}\nfunction pollNetworkInputs(gameMode, controllerType, playerSlot, controllerIndex, frameByFrame) {\n    return (0, streamclient_1.retrieveNetworkInputs)(playerSlot, controllerIndex);\n}\nfunction pollReplayInputs(gameMode, controllerType, playerSlot, controllerIndex, frameByFrame) {\n    return (0, replay_1.retrieveReplayInputs)(playerSlot, controllerIndex);\n}\nfunction pollKeyboardInputs(gameMode, frameByFrame, keys) {\n    const input = (0, exports.nullInput)(); // initialise with default values\n    let stickR = 1;\n    let stickL = 1;\n    let stickU = 1;\n    let stickD = 1;\n    if (gameMode === 3 || gameMode === 5) {\n        stickR = settings_1.keyMap.lstick.ranges[1];\n        stickL = settings_1.keyMap.lstick.ranges[2];\n        stickU = settings_1.keyMap.lstick.ranges[0];\n        stickD = settings_1.keyMap.lstick.ranges[3];\n    }\n    let lstickX = (keys[settings_1.keyMap.lstick.right[0]] || keys[settings_1.keyMap.lstick.right[1]]) ? ((keys[settings_1.keyMap.lstick.left[0]] ||\n        keys[settings_1.keyMap.lstick.left[1]]) ? 0 : stickR) : ((keys[settings_1.keyMap.lstick.left[0]] || keys[settings_1.keyMap.lstick.left[1]]) ?\n        -stickL : 0);\n    let lstickY = (keys[settings_1.keyMap.lstick.up[0]] || keys[settings_1.keyMap.lstick.up[1]]) ? ((keys[settings_1.keyMap.lstick.down[0]] || keys[settings_1.keyMap.lstick.down[1]]) ? 0 : stickU) : ((keys[settings_1.keyMap.lstick.down[0]] || keys[settings_1.keyMap.lstick.down[1]]) ? -stickD : 0);\n    let lAnalog = (keys[settings_1.keyMap.shoulders.lAnalog[0]] || keys[settings_1.keyMap.shoulders.lAnalog[1]]) ? settings_1.keyMap.shoulders.ranges[0] : 0;\n    let rAnalog = (keys[settings_1.keyMap.shoulders.rAnalog[0]] || keys[settings_1.keyMap.shoulders.rAnalog[1]]) ? settings_1.keyMap.shoulders.ranges[1] : 0;\n    if (gameMode === 3 || gameMode === 5) {\n        for (let j = 0; j < 5; j++) {\n            if (keys[settings_1.keyMap.lstick.modifiers[j][0]]) {\n                lstickX *= settings_1.keyMap.lstick.modifiers[j][1];\n                lstickY *= settings_1.keyMap.lstick.modifiers[j][2];\n            }\n            if (keys[settings_1.keyMap.shoulders.modifiers[j][0]]) {\n                lAnalog *= settings_1.keyMap.shoulders.modifiers[j][1];\n                rAnalog *= settings_1.keyMap.shoulders.modifiers[j][2];\n            }\n        }\n    }\n    lstickX = Math.sign(lstickX) * Math.min(1, Math.abs(lstickX));\n    lstickY = Math.sign(lstickY) * Math.min(1, Math.abs(lstickY));\n    lAnalog = Math.min(1, Math.abs(lAnalog));\n    rAnalog = Math.min(1, Math.abs(rAnalog));\n    const cstickX = (keys[settings_1.keyMap.cstick.right[0]] || keys[settings_1.keyMap.cstick.right[1]]) ? ((keys[settings_1.keyMap.cstick.left[0]] ||\n        keys[settings_1.keyMap.cstick.left[1]]) ? 0 : 1) : ((keys[settings_1.keyMap.cstick.left[0]] || keys[settings_1.keyMap.cstick.left[1]]) ? -1 :\n        0);\n    const cstickY = (keys[settings_1.keyMap.cstick.up[0]] || keys[settings_1.keyMap.cstick.up[1]]) ? ((keys[settings_1.keyMap.cstick.down[0]] || keys[settings_1.keyMap.cstick.down[1]]) ? 0 : 1) : ((keys[settings_1.keyMap.cstick.down[0]] || keys[settings_1.keyMap.cstick.down[1]]) ? -1 : 0);\n    const rescaledLStick = (0, meleeInputs_1.tasRescale)(lstickX, lstickY, true);\n    input.lsX = (0, meleeInputs_1.deaden)(rescaledLStick[0]);\n    input.lsY = (0, meleeInputs_1.deaden)(rescaledLStick[1]);\n    input.rawX = rescaledLStick[0];\n    input.rawY = rescaledLStick[1];\n    const rescaledCStick = (0, meleeInputs_1.tasRescale)(cstickX, cstickY, true);\n    input.csX = (0, meleeInputs_1.deaden)(rescaledCStick[0]);\n    input.csY = (0, meleeInputs_1.deaden)(rescaledCStick[1]);\n    input.rawcsX = rescaledCStick[0];\n    input.rawcsY = rescaledCStick[1];\n    input.lA = lAnalog;\n    input.rA = rAnalog;\n    input.s = keys[settings_1.keyMap.s[0]] || keys[settings_1.keyMap.s[1]];\n    input.x = keys[settings_1.keyMap.x[0]] || keys[settings_1.keyMap.x[1]];\n    input.a = keys[settings_1.keyMap.a[0]] || keys[settings_1.keyMap.a[1]];\n    input.b = keys[settings_1.keyMap.b[0]] || keys[settings_1.keyMap.b[1]];\n    input.y = keys[settings_1.keyMap.y[0]] || keys[settings_1.keyMap.y[1]];\n    input.r = keys[settings_1.keyMap.r[0]] || keys[settings_1.keyMap.r[1]];\n    input.l = keys[settings_1.keyMap.l[0]] || keys[settings_1.keyMap.l[1]];\n    input.z = keys[settings_1.keyMap.z[0]] || keys[settings_1.keyMap.z[1]];\n    input.dl = keys[settings_1.keyMap.dl[0]];\n    input.dd = keys[settings_1.keyMap.dd[0]];\n    input.dr = keys[settings_1.keyMap.dr[0]];\n    input.du = keys[settings_1.keyMap.du[0]];\n    if (!frameByFrame && gameMode !== 4 && gameMode !== 14) { // not in target builder, calibration screen, or frame by frame mode\n        if (input.z) {\n            if (input.lA < 0.35) {\n                input.lA = 0.35;\n            }\n            input.a = true;\n        }\n    }\n    if (input.l) {\n        input.lA = 1;\n    }\n    if (input.r) {\n        input.rA = 1;\n    }\n    return input;\n}\nfunction pollGamepadInputs(gameMode, gamepadInfo, playerSlot, controllerIndex, frameByFrame) {\n    const input = (0, exports.nullInput)();\n    if (navigator.getGamepads === undefined) {\n        return input;\n    }\n    const gamepads = navigator.getGamepads();\n    const gamepad = gamepads[controllerIndex];\n    if (gamepad === null || gamepad === undefined) {\n        return input;\n    }\n    // -------------------------------------------------------\n    // analog sticks\n    const fixedGamepad = gamepad;\n    // {\n    //   buttons: gamepad.buttons as GamepadButton[],\n    //   axes: gamepad.axes as number[],\n    //   id: gamepad.id\n    // };\n    const lsVec = (0, retrieveGamepadInputs_1.stickValue)(fixedGamepad, gamepadInfo, \"ls\");\n    const csVec = (0, retrieveGamepadInputs_1.stickValue)(fixedGamepad, gamepadInfo, \"cs\");\n    const isGC = gamepadInfo.isGC;\n    let lsCardinals = null;\n    if (gamepadInfo.ls !== null) {\n        lsCardinals = gamepadInfo.ls.cardinals;\n    }\n    let csCardinals = null;\n    if (gamepadInfo.cs !== null) {\n        csCardinals = gamepadInfo.cs.cardinals;\n    }\n    const lsticks = (0, meleeInputs_1.scaleToMeleeAxes)(lsVec.x // x-axis data\n    , lsVec.y // y-axis data\n    , isGC, lsCardinals, custcent[playerSlot].ls.x // x-axis \"custom center\" offset\n    , custcent[playerSlot].ls.y // y-axis \"custom center\" offset\n    );\n    const csticks = (0, meleeInputs_1.scaleToMeleeAxes)(csVec.x, csVec.y, isGC, csCardinals, custcent[playerSlot].cs.x, custcent[playerSlot].cs.y);\n    input.lsX = (0, meleeInputs_1.deaden)(lsticks[0]);\n    input.lsY = (0, meleeInputs_1.deaden)(lsticks[1]);\n    input.csX = (0, meleeInputs_1.deaden)(csticks[0]);\n    input.csY = (0, meleeInputs_1.deaden)(csticks[1]);\n    input.rawX = lsticks[0];\n    input.rawY = lsticks[1];\n    input.rawcsX = csticks[0];\n    input.rawcsY = csticks[1];\n    // -------------------------------------------------------\n    // buttons\n    input.s = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"s\");\n    input.x = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"x\");\n    input.a = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"a\");\n    input.b = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"b\");\n    input.y = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"y\");\n    input.z = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"z\");\n    // -------------------------------------------------------\n    // triggers\n    input.l = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"l\");\n    input.r = (0, retrieveGamepadInputs_1.buttonState)(fixedGamepad, gamepadInfo, \"r\");\n    if (gamepadInfo.lA !== null) {\n        const lA = gamepadInfo.lA;\n        if (lA.kind === \"light\") {\n            input.lA = (0, retrieveGamepadInputs_1.triggerValue)(fixedGamepad, gamepadInfo, \"lA\");\n        }\n        else {\n            input.lA = (0, meleeInputs_1.scaleToGCTrigger)((0, retrieveGamepadInputs_1.triggerValue)(fixedGamepad, gamepadInfo, \"lA\") // raw trigger value\n            , -lA.min - custcent[playerSlot].l // offset\n            , lA.max - lA.min // scaling\n            );\n        }\n    }\n    if (gamepadInfo.rA !== null) {\n        const rA = gamepadInfo.rA;\n        if (rA.kind === \"light\") {\n            input.rA = (0, retrieveGamepadInputs_1.triggerValue)(fixedGamepad, gamepadInfo, \"rA\");\n        }\n        else {\n            input.rA = (0, meleeInputs_1.scaleToGCTrigger)((0, retrieveGamepadInputs_1.triggerValue)(fixedGamepad, gamepadInfo, \"rA\") // raw trigger value\n            , -rA.min - custcent[playerSlot].r // offset\n            , rA.max - rA.min // scaling\n            );\n        }\n    }\n    if (main_1.controllerResetCountdowns[playerSlot] === 0) {\n        setCustomCenters(playerSlot, lsVec, csVec, input.lA, input.rA);\n    }\n    if (!frameByFrame && gameMode !== 4 && gameMode !== 14) { // not in target builder or calibration screen\n        if (input.z) {\n            if (input.lA < 0.35) {\n                input.lA = 0.35;\n            }\n            input.a = true;\n        }\n    }\n    if (gameMode !== 14) {\n        if (input.l) {\n            input.lA = 1;\n        }\n        if (input.r) {\n            input.rA = 1;\n        }\n        if (input.lA > 0.95) {\n            input.l = true;\n        }\n        if (input.rA > 0.95) {\n            input.r = true;\n        }\n    }\n    // -------------------------------------------------------\n    // d-pad\n    const dPadData = (0, retrieveGamepadInputs_1.dPadState)(fixedGamepad, gamepadInfo);\n    input.dl = dPadData.left;\n    input.dd = dPadData.down;\n    input.dr = dPadData.right;\n    input.du = dPadData.up;\n    return input;\n}\n;\nfunction showButton(i, but, booleanean) {\n    if (boolean) {\n        (0, jquery_1.default)(\"#\" + i + \"button\" + but).show();\n    }\n    else {\n        (0, jquery_1.default)(\"#\" + i + \"button\" + but).hide();\n    }\n}\n;\nexports.keyboardMap = [\n    [102, 186],\n    [101, 76],\n    [100, 75],\n    [104, 79],\n    [103, 73],\n    [105, 80],\n    [107, 192, 222],\n    [109, 219], 71, 78, 66, 86\n];\nconst customCenters = function () {\n    this.ls = new Vec2D_1.Vec2D(0, 0);\n    this.cs = new Vec2D_1.Vec2D(0, 0);\n    this.l = 0;\n    this.r = 0;\n};\nconst custcent = [new customCenters, new customCenters, new customCenters, new customCenters];\nfunction setCustomCenters(i, ls0, cs0, l0, r0) {\n    custcent[i].ls = ls0;\n    custcent[i].cs = cs0;\n    custcent[i].l = l0;\n    custcent[i].r = r0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5wdXQvaW5wdXQudHMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCO0FBQ2xLLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4QixnQkFBZ0IsbUJBQU8sQ0FBQyxvREFBb0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsc0NBQWE7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHdDQUFjO0FBQ3JDLGdDQUFnQyxtQkFBTyxDQUFDLHFGQUFpQztBQUN6RSxzQkFBc0IsbUJBQU8sQ0FBQyxpREFBZTtBQUM3QyxpQ0FBaUMsbUJBQU8sQ0FBQyxvREFBUTtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyw0Q0FBZ0I7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQWtDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWxlZWxpZ2h0Ly4vc3JjL2lucHV0L2lucHV0LnRzPzhhOWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKmVzbGludCBpbmRlbnQ6MCovXG4vLyBAZmxvd1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5rZXlib2FyZE1hcCA9IGV4cG9ydHMuYWlJbnB1dEJhbmsgPSBleHBvcnRzLmFpUGxheWVyNCA9IGV4cG9ydHMuYWlQbGF5ZXIzID0gZXhwb3J0cy5haVBsYXllcjIgPSBleHBvcnRzLmFpUGxheWVyMSA9IGV4cG9ydHMubnVsbElucHV0cyA9IGV4cG9ydHMubnVsbElucHV0ID0gdm9pZCAwO1xuZXhwb3J0cy5pbnB1dERhdGEgPSBpbnB1dERhdGE7XG5leHBvcnRzLnBvbGxJbnB1dHMgPSBwb2xsSW5wdXRzO1xuZXhwb3J0cy5zaG93QnV0dG9uID0gc2hvd0J1dHRvbjtcbmV4cG9ydHMuc2V0Q3VzdG9tQ2VudGVycyA9IHNldEN1c3RvbUNlbnRlcnM7XG5jb25zdCBWZWMyRF8xID0gcmVxdWlyZShcIi4uL21haW4vdXRpbC9WZWMyRFwiKTtcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vc2V0dGluZ3NcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi4vbWFpbi9tYWluXCIpO1xuY29uc3QgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEgPSByZXF1aXJlKFwiLi9nYW1lcGFkL3JldHJpZXZlR2FtZXBhZElucHV0c1wiKTtcbmNvbnN0IG1lbGVlSW5wdXRzXzEgPSByZXF1aXJlKFwiLi9tZWxlZUlucHV0c1wiKTtcbmNvbnN0IGpxdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuY29uc3QgcmVwbGF5XzEgPSByZXF1aXJlKFwiLi4vbWFpbi9yZXBsYXlcIik7XG5jb25zdCBzdHJlYW1jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi9tYWluL211bHRpcGxheWVyL3N0cmVhbWNsaWVudFwiKTtcbmZ1bmN0aW9uIGlucHV0RGF0YShsaXN0ID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIDAsIDAsIDAsIDAsIDBdKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYTogbGlzdFswXSxcbiAgICAgICAgYjogbGlzdFsxXSxcbiAgICAgICAgeDogbGlzdFsyXSxcbiAgICAgICAgeTogbGlzdFszXSxcbiAgICAgICAgejogbGlzdFs0XSxcbiAgICAgICAgcjogbGlzdFs1XSxcbiAgICAgICAgbDogbGlzdFs2XSxcbiAgICAgICAgczogbGlzdFs3XSxcbiAgICAgICAgZHU6IGxpc3RbOF0sXG4gICAgICAgIGRyOiBsaXN0WzldLFxuICAgICAgICBkZDogbGlzdFsxMF0sXG4gICAgICAgIGRsOiBsaXN0WzExXSxcbiAgICAgICAgbHNYOiAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKGxpc3RbMTJdKSxcbiAgICAgICAgbHNZOiAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKGxpc3RbMTNdKSxcbiAgICAgICAgY3NYOiAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKGxpc3RbMTRdKSxcbiAgICAgICAgY3NZOiAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKGxpc3RbMTVdKSxcbiAgICAgICAgbEE6IGxpc3RbMTZdLFxuICAgICAgICByQTogbGlzdFsxN10sXG4gICAgICAgIHJhd1g6IGxpc3RbMTJdLFxuICAgICAgICByYXdZOiBsaXN0WzEzXSxcbiAgICAgICAgcmF3Y3NYOiBsaXN0WzE0XSxcbiAgICAgICAgcmF3Y3NZOiBsaXN0WzE1XVxuICAgIH07XG59XG47XG5jb25zdCBudWxsSW5wdXQgPSAoKSA9PiBpbnB1dERhdGEoKTtcbmV4cG9ydHMubnVsbElucHV0ID0gbnVsbElucHV0O1xuY29uc3QgbnVsbElucHV0cyA9ICgpID0+IFtpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKVxuXTtcbmV4cG9ydHMubnVsbElucHV0cyA9IG51bGxJbnB1dHM7XG5leHBvcnRzLmFpUGxheWVyMSA9IFtpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKVxuXTtcbmV4cG9ydHMuYWlQbGF5ZXIyID0gW2lucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpLFxuICAgIGlucHV0RGF0YSgpXG5dO1xuZXhwb3J0cy5haVBsYXllcjMgPSBbaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKCksXG4gICAgaW5wdXREYXRhKClcbl07XG5leHBvcnRzLmFpUGxheWVyNCA9IFtpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKSxcbiAgICBpbnB1dERhdGEoKVxuXTtcbmV4cG9ydHMuYWlJbnB1dEJhbmsgPSBbZXhwb3J0cy5haVBsYXllcjEsIGV4cG9ydHMuYWlQbGF5ZXIyLCBleHBvcnRzLmFpUGxheWVyMywgZXhwb3J0cy5haVBsYXllcjRdO1xuLy8gc2hvdWxkIGJlIGFibGUgdG8gbW92ZSBvdXQgdGhlIFwiZnJhbWVCeUZyYW1lXCIgYXNwZWN0IG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25cbi8vIGl0IGlzIG9ubHkgdXNlZCB0byBtYWtlIHogYnV0dG9uIG1lYW4gXCJsZWZ0IHRyaWdnZXIgdmFsdWUgPSAwLjM1XCIgKyBcIkEgPSB0cnVlXCIuXG5mdW5jdGlvbiBwb2xsSW5wdXRzKGdhbWVNb2RlLCBmcmFtZUJ5RnJhbWUsIGNvbnRyb2xsZXJJbmZvLCBwbGF5ZXJTbG90LCBjb250cm9sbGVySW5kZXgsIGtleXMsIHBsYXllcnR5cGUpIHtcbiAgICAvLyBpbnB1dCBpcyB0aGUgaW5wdXQgZm9yIHBsYXllciBpIGluIHRoZSBjdXJyZW50IGZyYW1lXG4gICAgbGV0IGlucHV0ID0gKDAsIGV4cG9ydHMubnVsbElucHV0KSgpOyAvLyBpbml0aWFsaXNlIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBpZiAocmVwbGF5XzEucmVwbGF5QWN0aXZlKSB7XG4gICAgICAgIGlucHV0ID0gcG9sbFJlcGxheUlucHV0cyhnYW1lTW9kZSwgY29udHJvbGxlckluZm8sIHBsYXllclNsb3QsIGNvbnRyb2xsZXJJbmRleCwgZnJhbWVCeUZyYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGxheWVydHlwZSA9PT0gMSAmJiBnYW1lTW9kZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5haUlucHV0QmFua1twbGF5ZXJTbG90XVswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlckluZm8gPT09IFwia2V5Ym9hcmRcIikgeyAvLyBrZXlib2FyZCBjb250cm9sc1xuICAgICAgICBpbnB1dCA9IHBvbGxLZXlib2FyZElucHV0cyhnYW1lTW9kZSwgZnJhbWVCeUZyYW1lLCBrZXlzKTtcbiAgICAgICAgLy8gfSBlbHNlIGlmIChwbGF5ZXJ0eXBlID09PSAyIHx8IGNvbnRyb2xsZXJJbmZvID09PSA5OSkgeyAvLyBucDogb25saW5lIHBsYXk/XG4gICAgICAgIC8vICAgaW5wdXQgPSBwb2xsTmV0d29ya0lucHV0cyhnYW1lTW9kZSwgY29udHJvbGxlckluZm8sIHBsYXllclNsb3QsIGNvbnRyb2xsZXJJbmRleCwgZnJhbWVCeUZyYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGxheWVydHlwZSA9PT0gMCkge1xuICAgICAgICBpbnB1dCA9IHBvbGxHYW1lcGFkSW5wdXRzKGdhbWVNb2RlLCBjb250cm9sbGVySW5mbywgcGxheWVyU2xvdCwgY29udHJvbGxlckluZGV4LCBmcmFtZUJ5RnJhbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59XG5mdW5jdGlvbiBwb2xsTmV0d29ya0lucHV0cyhnYW1lTW9kZSwgY29udHJvbGxlclR5cGUsIHBsYXllclNsb3QsIGNvbnRyb2xsZXJJbmRleCwgZnJhbWVCeUZyYW1lKSB7XG4gICAgcmV0dXJuICgwLCBzdHJlYW1jbGllbnRfMS5yZXRyaWV2ZU5ldHdvcmtJbnB1dHMpKHBsYXllclNsb3QsIGNvbnRyb2xsZXJJbmRleCk7XG59XG5mdW5jdGlvbiBwb2xsUmVwbGF5SW5wdXRzKGdhbWVNb2RlLCBjb250cm9sbGVyVHlwZSwgcGxheWVyU2xvdCwgY29udHJvbGxlckluZGV4LCBmcmFtZUJ5RnJhbWUpIHtcbiAgICByZXR1cm4gKDAsIHJlcGxheV8xLnJldHJpZXZlUmVwbGF5SW5wdXRzKShwbGF5ZXJTbG90LCBjb250cm9sbGVySW5kZXgpO1xufVxuZnVuY3Rpb24gcG9sbEtleWJvYXJkSW5wdXRzKGdhbWVNb2RlLCBmcmFtZUJ5RnJhbWUsIGtleXMpIHtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCBleHBvcnRzLm51bGxJbnB1dCkoKTsgLy8gaW5pdGlhbGlzZSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgbGV0IHN0aWNrUiA9IDE7XG4gICAgbGV0IHN0aWNrTCA9IDE7XG4gICAgbGV0IHN0aWNrVSA9IDE7XG4gICAgbGV0IHN0aWNrRCA9IDE7XG4gICAgaWYgKGdhbWVNb2RlID09PSAzIHx8IGdhbWVNb2RlID09PSA1KSB7XG4gICAgICAgIHN0aWNrUiA9IHNldHRpbmdzXzEua2V5TWFwLmxzdGljay5yYW5nZXNbMV07XG4gICAgICAgIHN0aWNrTCA9IHNldHRpbmdzXzEua2V5TWFwLmxzdGljay5yYW5nZXNbMl07XG4gICAgICAgIHN0aWNrVSA9IHNldHRpbmdzXzEua2V5TWFwLmxzdGljay5yYW5nZXNbMF07XG4gICAgICAgIHN0aWNrRCA9IHNldHRpbmdzXzEua2V5TWFwLmxzdGljay5yYW5nZXNbM107XG4gICAgfVxuICAgIGxldCBsc3RpY2tYID0gKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAubHN0aWNrLnJpZ2h0WzBdXSB8fCBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxzdGljay5yaWdodFsxXV0pID8gKChrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxzdGljay5sZWZ0WzBdXSB8fFxuICAgICAgICBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxzdGljay5sZWZ0WzFdXSkgPyAwIDogc3RpY2tSKSA6ICgoa2V5c1tzZXR0aW5nc18xLmtleU1hcC5sc3RpY2subGVmdFswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC5sc3RpY2subGVmdFsxXV0pID9cbiAgICAgICAgLXN0aWNrTCA6IDApO1xuICAgIGxldCBsc3RpY2tZID0gKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAubHN0aWNrLnVwWzBdXSB8fCBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxzdGljay51cFsxXV0pID8gKChrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxzdGljay5kb3duWzBdXSB8fCBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxzdGljay5kb3duWzFdXSkgPyAwIDogc3RpY2tVKSA6ICgoa2V5c1tzZXR0aW5nc18xLmtleU1hcC5sc3RpY2suZG93blswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC5sc3RpY2suZG93blsxXV0pID8gLXN0aWNrRCA6IDApO1xuICAgIGxldCBsQW5hbG9nID0gKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuc2hvdWxkZXJzLmxBbmFsb2dbMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuc2hvdWxkZXJzLmxBbmFsb2dbMV1dKSA/IHNldHRpbmdzXzEua2V5TWFwLnNob3VsZGVycy5yYW5nZXNbMF0gOiAwO1xuICAgIGxldCByQW5hbG9nID0gKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuc2hvdWxkZXJzLnJBbmFsb2dbMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuc2hvdWxkZXJzLnJBbmFsb2dbMV1dKSA/IHNldHRpbmdzXzEua2V5TWFwLnNob3VsZGVycy5yYW5nZXNbMV0gOiAwO1xuICAgIGlmIChnYW1lTW9kZSA9PT0gMyB8fCBnYW1lTW9kZSA9PT0gNSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDU7IGorKykge1xuICAgICAgICAgICAgaWYgKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAubHN0aWNrLm1vZGlmaWVyc1tqXVswXV0pIHtcbiAgICAgICAgICAgICAgICBsc3RpY2tYICo9IHNldHRpbmdzXzEua2V5TWFwLmxzdGljay5tb2RpZmllcnNbal1bMV07XG4gICAgICAgICAgICAgICAgbHN0aWNrWSAqPSBzZXR0aW5nc18xLmtleU1hcC5sc3RpY2subW9kaWZpZXJzW2pdWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuc2hvdWxkZXJzLm1vZGlmaWVyc1tqXVswXV0pIHtcbiAgICAgICAgICAgICAgICBsQW5hbG9nICo9IHNldHRpbmdzXzEua2V5TWFwLnNob3VsZGVycy5tb2RpZmllcnNbal1bMV07XG4gICAgICAgICAgICAgICAgckFuYWxvZyAqPSBzZXR0aW5nc18xLmtleU1hcC5zaG91bGRlcnMubW9kaWZpZXJzW2pdWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxzdGlja1ggPSBNYXRoLnNpZ24obHN0aWNrWCkgKiBNYXRoLm1pbigxLCBNYXRoLmFicyhsc3RpY2tYKSk7XG4gICAgbHN0aWNrWSA9IE1hdGguc2lnbihsc3RpY2tZKSAqIE1hdGgubWluKDEsIE1hdGguYWJzKGxzdGlja1kpKTtcbiAgICBsQW5hbG9nID0gTWF0aC5taW4oMSwgTWF0aC5hYnMobEFuYWxvZykpO1xuICAgIHJBbmFsb2cgPSBNYXRoLm1pbigxLCBNYXRoLmFicyhyQW5hbG9nKSk7XG4gICAgY29uc3QgY3N0aWNrWCA9IChrZXlzW3NldHRpbmdzXzEua2V5TWFwLmNzdGljay5yaWdodFswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC5jc3RpY2sucmlnaHRbMV1dKSA/ICgoa2V5c1tzZXR0aW5nc18xLmtleU1hcC5jc3RpY2subGVmdFswXV0gfHxcbiAgICAgICAga2V5c1tzZXR0aW5nc18xLmtleU1hcC5jc3RpY2subGVmdFsxXV0pID8gMCA6IDEpIDogKChrZXlzW3NldHRpbmdzXzEua2V5TWFwLmNzdGljay5sZWZ0WzBdXSB8fCBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmNzdGljay5sZWZ0WzFdXSkgPyAtMSA6XG4gICAgICAgIDApO1xuICAgIGNvbnN0IGNzdGlja1kgPSAoa2V5c1tzZXR0aW5nc18xLmtleU1hcC5jc3RpY2sudXBbMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuY3N0aWNrLnVwWzFdXSkgPyAoKGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuY3N0aWNrLmRvd25bMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuY3N0aWNrLmRvd25bMV1dKSA/IDAgOiAxKSA6ICgoa2V5c1tzZXR0aW5nc18xLmtleU1hcC5jc3RpY2suZG93blswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC5jc3RpY2suZG93blsxXV0pID8gLTEgOiAwKTtcbiAgICBjb25zdCByZXNjYWxlZExTdGljayA9ICgwLCBtZWxlZUlucHV0c18xLnRhc1Jlc2NhbGUpKGxzdGlja1gsIGxzdGlja1ksIHRydWUpO1xuICAgIGlucHV0LmxzWCA9ICgwLCBtZWxlZUlucHV0c18xLmRlYWRlbikocmVzY2FsZWRMU3RpY2tbMF0pO1xuICAgIGlucHV0LmxzWSA9ICgwLCBtZWxlZUlucHV0c18xLmRlYWRlbikocmVzY2FsZWRMU3RpY2tbMV0pO1xuICAgIGlucHV0LnJhd1ggPSByZXNjYWxlZExTdGlja1swXTtcbiAgICBpbnB1dC5yYXdZID0gcmVzY2FsZWRMU3RpY2tbMV07XG4gICAgY29uc3QgcmVzY2FsZWRDU3RpY2sgPSAoMCwgbWVsZWVJbnB1dHNfMS50YXNSZXNjYWxlKShjc3RpY2tYLCBjc3RpY2tZLCB0cnVlKTtcbiAgICBpbnB1dC5jc1ggPSAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKHJlc2NhbGVkQ1N0aWNrWzBdKTtcbiAgICBpbnB1dC5jc1kgPSAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKHJlc2NhbGVkQ1N0aWNrWzFdKTtcbiAgICBpbnB1dC5yYXdjc1ggPSByZXNjYWxlZENTdGlja1swXTtcbiAgICBpbnB1dC5yYXdjc1kgPSByZXNjYWxlZENTdGlja1sxXTtcbiAgICBpbnB1dC5sQSA9IGxBbmFsb2c7XG4gICAgaW5wdXQuckEgPSByQW5hbG9nO1xuICAgIGlucHV0LnMgPSBrZXlzW3NldHRpbmdzXzEua2V5TWFwLnNbMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuc1sxXV07XG4gICAgaW5wdXQueCA9IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAueFswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC54WzFdXTtcbiAgICBpbnB1dC5hID0ga2V5c1tzZXR0aW5nc18xLmtleU1hcC5hWzBdXSB8fCBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmFbMV1dO1xuICAgIGlucHV0LmIgPSBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmJbMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuYlsxXV07XG4gICAgaW5wdXQueSA9IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAueVswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC55WzFdXTtcbiAgICBpbnB1dC5yID0ga2V5c1tzZXR0aW5nc18xLmtleU1hcC5yWzBdXSB8fCBrZXlzW3NldHRpbmdzXzEua2V5TWFwLnJbMV1dO1xuICAgIGlucHV0LmwgPSBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmxbMF1dIHx8IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAubFsxXV07XG4gICAgaW5wdXQueiA9IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuelswXV0gfHwga2V5c1tzZXR0aW5nc18xLmtleU1hcC56WzFdXTtcbiAgICBpbnB1dC5kbCA9IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuZGxbMF1dO1xuICAgIGlucHV0LmRkID0ga2V5c1tzZXR0aW5nc18xLmtleU1hcC5kZFswXV07XG4gICAgaW5wdXQuZHIgPSBrZXlzW3NldHRpbmdzXzEua2V5TWFwLmRyWzBdXTtcbiAgICBpbnB1dC5kdSA9IGtleXNbc2V0dGluZ3NfMS5rZXlNYXAuZHVbMF1dO1xuICAgIGlmICghZnJhbWVCeUZyYW1lICYmIGdhbWVNb2RlICE9PSA0ICYmIGdhbWVNb2RlICE9PSAxNCkgeyAvLyBub3QgaW4gdGFyZ2V0IGJ1aWxkZXIsIGNhbGlicmF0aW9uIHNjcmVlbiwgb3IgZnJhbWUgYnkgZnJhbWUgbW9kZVxuICAgICAgICBpZiAoaW5wdXQueikge1xuICAgICAgICAgICAgaWYgKGlucHV0LmxBIDwgMC4zNSkge1xuICAgICAgICAgICAgICAgIGlucHV0LmxBID0gMC4zNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0LmEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dC5sKSB7XG4gICAgICAgIGlucHV0LmxBID0gMTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnIpIHtcbiAgICAgICAgaW5wdXQuckEgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59XG5mdW5jdGlvbiBwb2xsR2FtZXBhZElucHV0cyhnYW1lTW9kZSwgZ2FtZXBhZEluZm8sIHBsYXllclNsb3QsIGNvbnRyb2xsZXJJbmRleCwgZnJhbWVCeUZyYW1lKSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgZXhwb3J0cy5udWxsSW5wdXQpKCk7XG4gICAgaWYgKG5hdmlnYXRvci5nZXRHYW1lcGFkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgZ2FtZXBhZHMgPSBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTtcbiAgICBjb25zdCBnYW1lcGFkID0gZ2FtZXBhZHNbY29udHJvbGxlckluZGV4XTtcbiAgICBpZiAoZ2FtZXBhZCA9PT0gbnVsbCB8fCBnYW1lcGFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gYW5hbG9nIHN0aWNrc1xuICAgIGNvbnN0IGZpeGVkR2FtZXBhZCA9IGdhbWVwYWQ7XG4gICAgLy8ge1xuICAgIC8vICAgYnV0dG9uczogZ2FtZXBhZC5idXR0b25zIGFzIEdhbWVwYWRCdXR0b25bXSxcbiAgICAvLyAgIGF4ZXM6IGdhbWVwYWQuYXhlcyBhcyBudW1iZXJbXSxcbiAgICAvLyAgIGlkOiBnYW1lcGFkLmlkXG4gICAgLy8gfTtcbiAgICBjb25zdCBsc1ZlYyA9ICgwLCByZXRyaWV2ZUdhbWVwYWRJbnB1dHNfMS5zdGlja1ZhbHVlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcImxzXCIpO1xuICAgIGNvbnN0IGNzVmVjID0gKDAsIHJldHJpZXZlR2FtZXBhZElucHV0c18xLnN0aWNrVmFsdWUpKGZpeGVkR2FtZXBhZCwgZ2FtZXBhZEluZm8sIFwiY3NcIik7XG4gICAgY29uc3QgaXNHQyA9IGdhbWVwYWRJbmZvLmlzR0M7XG4gICAgbGV0IGxzQ2FyZGluYWxzID0gbnVsbDtcbiAgICBpZiAoZ2FtZXBhZEluZm8ubHMgIT09IG51bGwpIHtcbiAgICAgICAgbHNDYXJkaW5hbHMgPSBnYW1lcGFkSW5mby5scy5jYXJkaW5hbHM7XG4gICAgfVxuICAgIGxldCBjc0NhcmRpbmFscyA9IG51bGw7XG4gICAgaWYgKGdhbWVwYWRJbmZvLmNzICE9PSBudWxsKSB7XG4gICAgICAgIGNzQ2FyZGluYWxzID0gZ2FtZXBhZEluZm8uY3MuY2FyZGluYWxzO1xuICAgIH1cbiAgICBjb25zdCBsc3RpY2tzID0gKDAsIG1lbGVlSW5wdXRzXzEuc2NhbGVUb01lbGVlQXhlcykobHNWZWMueCAvLyB4LWF4aXMgZGF0YVxuICAgICwgbHNWZWMueSAvLyB5LWF4aXMgZGF0YVxuICAgICwgaXNHQywgbHNDYXJkaW5hbHMsIGN1c3RjZW50W3BsYXllclNsb3RdLmxzLnggLy8geC1heGlzIFwiY3VzdG9tIGNlbnRlclwiIG9mZnNldFxuICAgICwgY3VzdGNlbnRbcGxheWVyU2xvdF0ubHMueSAvLyB5LWF4aXMgXCJjdXN0b20gY2VudGVyXCIgb2Zmc2V0XG4gICAgKTtcbiAgICBjb25zdCBjc3RpY2tzID0gKDAsIG1lbGVlSW5wdXRzXzEuc2NhbGVUb01lbGVlQXhlcykoY3NWZWMueCwgY3NWZWMueSwgaXNHQywgY3NDYXJkaW5hbHMsIGN1c3RjZW50W3BsYXllclNsb3RdLmNzLngsIGN1c3RjZW50W3BsYXllclNsb3RdLmNzLnkpO1xuICAgIGlucHV0LmxzWCA9ICgwLCBtZWxlZUlucHV0c18xLmRlYWRlbikobHN0aWNrc1swXSk7XG4gICAgaW5wdXQubHNZID0gKDAsIG1lbGVlSW5wdXRzXzEuZGVhZGVuKShsc3RpY2tzWzFdKTtcbiAgICBpbnB1dC5jc1ggPSAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKGNzdGlja3NbMF0pO1xuICAgIGlucHV0LmNzWSA9ICgwLCBtZWxlZUlucHV0c18xLmRlYWRlbikoY3N0aWNrc1sxXSk7XG4gICAgaW5wdXQucmF3WCA9IGxzdGlja3NbMF07XG4gICAgaW5wdXQucmF3WSA9IGxzdGlja3NbMV07XG4gICAgaW5wdXQucmF3Y3NYID0gY3N0aWNrc1swXTtcbiAgICBpbnB1dC5yYXdjc1kgPSBjc3RpY2tzWzFdO1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBidXR0b25zXG4gICAgaW5wdXQucyA9ICgwLCByZXRyaWV2ZUdhbWVwYWRJbnB1dHNfMS5idXR0b25TdGF0ZSkoZml4ZWRHYW1lcGFkLCBnYW1lcGFkSW5mbywgXCJzXCIpO1xuICAgIGlucHV0LnggPSAoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEuYnV0dG9uU3RhdGUpKGZpeGVkR2FtZXBhZCwgZ2FtZXBhZEluZm8sIFwieFwiKTtcbiAgICBpbnB1dC5hID0gKDAsIHJldHJpZXZlR2FtZXBhZElucHV0c18xLmJ1dHRvblN0YXRlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcImFcIik7XG4gICAgaW5wdXQuYiA9ICgwLCByZXRyaWV2ZUdhbWVwYWRJbnB1dHNfMS5idXR0b25TdGF0ZSkoZml4ZWRHYW1lcGFkLCBnYW1lcGFkSW5mbywgXCJiXCIpO1xuICAgIGlucHV0LnkgPSAoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEuYnV0dG9uU3RhdGUpKGZpeGVkR2FtZXBhZCwgZ2FtZXBhZEluZm8sIFwieVwiKTtcbiAgICBpbnB1dC56ID0gKDAsIHJldHJpZXZlR2FtZXBhZElucHV0c18xLmJ1dHRvblN0YXRlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcInpcIik7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHRyaWdnZXJzXG4gICAgaW5wdXQubCA9ICgwLCByZXRyaWV2ZUdhbWVwYWRJbnB1dHNfMS5idXR0b25TdGF0ZSkoZml4ZWRHYW1lcGFkLCBnYW1lcGFkSW5mbywgXCJsXCIpO1xuICAgIGlucHV0LnIgPSAoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEuYnV0dG9uU3RhdGUpKGZpeGVkR2FtZXBhZCwgZ2FtZXBhZEluZm8sIFwiclwiKTtcbiAgICBpZiAoZ2FtZXBhZEluZm8ubEEgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbEEgPSBnYW1lcGFkSW5mby5sQTtcbiAgICAgICAgaWYgKGxBLmtpbmQgPT09IFwibGlnaHRcIikge1xuICAgICAgICAgICAgaW5wdXQubEEgPSAoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEudHJpZ2dlclZhbHVlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcImxBXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQubEEgPSAoMCwgbWVsZWVJbnB1dHNfMS5zY2FsZVRvR0NUcmlnZ2VyKSgoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEudHJpZ2dlclZhbHVlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcImxBXCIpIC8vIHJhdyB0cmlnZ2VyIHZhbHVlXG4gICAgICAgICAgICAsIC1sQS5taW4gLSBjdXN0Y2VudFtwbGF5ZXJTbG90XS5sIC8vIG9mZnNldFxuICAgICAgICAgICAgLCBsQS5tYXggLSBsQS5taW4gLy8gc2NhbGluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ2FtZXBhZEluZm8uckEgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgckEgPSBnYW1lcGFkSW5mby5yQTtcbiAgICAgICAgaWYgKHJBLmtpbmQgPT09IFwibGlnaHRcIikge1xuICAgICAgICAgICAgaW5wdXQuckEgPSAoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEudHJpZ2dlclZhbHVlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcInJBXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQuckEgPSAoMCwgbWVsZWVJbnB1dHNfMS5zY2FsZVRvR0NUcmlnZ2VyKSgoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEudHJpZ2dlclZhbHVlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvLCBcInJBXCIpIC8vIHJhdyB0cmlnZ2VyIHZhbHVlXG4gICAgICAgICAgICAsIC1yQS5taW4gLSBjdXN0Y2VudFtwbGF5ZXJTbG90XS5yIC8vIG9mZnNldFxuICAgICAgICAgICAgLCByQS5tYXggLSByQS5taW4gLy8gc2NhbGluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWFpbl8xLmNvbnRyb2xsZXJSZXNldENvdW50ZG93bnNbcGxheWVyU2xvdF0gPT09IDApIHtcbiAgICAgICAgc2V0Q3VzdG9tQ2VudGVycyhwbGF5ZXJTbG90LCBsc1ZlYywgY3NWZWMsIGlucHV0LmxBLCBpbnB1dC5yQSk7XG4gICAgfVxuICAgIGlmICghZnJhbWVCeUZyYW1lICYmIGdhbWVNb2RlICE9PSA0ICYmIGdhbWVNb2RlICE9PSAxNCkgeyAvLyBub3QgaW4gdGFyZ2V0IGJ1aWxkZXIgb3IgY2FsaWJyYXRpb24gc2NyZWVuXG4gICAgICAgIGlmIChpbnB1dC56KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQubEEgPCAwLjM1KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQubEEgPSAwLjM1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQuYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdhbWVNb2RlICE9PSAxNCkge1xuICAgICAgICBpZiAoaW5wdXQubCkge1xuICAgICAgICAgICAgaW5wdXQubEEgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5yKSB7XG4gICAgICAgICAgICBpbnB1dC5yQSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmxBID4gMC45NSkge1xuICAgICAgICAgICAgaW5wdXQubCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LnJBID4gMC45NSkge1xuICAgICAgICAgICAgaW5wdXQuciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGQtcGFkXG4gICAgY29uc3QgZFBhZERhdGEgPSAoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEuZFBhZFN0YXRlKShmaXhlZEdhbWVwYWQsIGdhbWVwYWRJbmZvKTtcbiAgICBpbnB1dC5kbCA9IGRQYWREYXRhLmxlZnQ7XG4gICAgaW5wdXQuZGQgPSBkUGFkRGF0YS5kb3duO1xuICAgIGlucHV0LmRyID0gZFBhZERhdGEucmlnaHQ7XG4gICAgaW5wdXQuZHUgPSBkUGFkRGF0YS51cDtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG47XG5mdW5jdGlvbiBzaG93QnV0dG9uKGksIGJ1dCwgYm9vbGVhbmVhbikge1xuICAgIGlmIChib29sZWFuKSB7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNcIiArIGkgKyBcImJ1dHRvblwiICsgYnV0KS5zaG93KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjXCIgKyBpICsgXCJidXR0b25cIiArIGJ1dCkuaGlkZSgpO1xuICAgIH1cbn1cbjtcbmV4cG9ydHMua2V5Ym9hcmRNYXAgPSBbXG4gICAgWzEwMiwgMTg2XSxcbiAgICBbMTAxLCA3Nl0sXG4gICAgWzEwMCwgNzVdLFxuICAgIFsxMDQsIDc5XSxcbiAgICBbMTAzLCA3M10sXG4gICAgWzEwNSwgODBdLFxuICAgIFsxMDcsIDE5MiwgMjIyXSxcbiAgICBbMTA5LCAyMTldLCA3MSwgNzgsIDY2LCA4NlxuXTtcbmNvbnN0IGN1c3RvbUNlbnRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5scyA9IG5ldyBWZWMyRF8xLlZlYzJEKDAsIDApO1xuICAgIHRoaXMuY3MgPSBuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKTtcbiAgICB0aGlzLmwgPSAwO1xuICAgIHRoaXMuciA9IDA7XG59O1xuY29uc3QgY3VzdGNlbnQgPSBbbmV3IGN1c3RvbUNlbnRlcnMsIG5ldyBjdXN0b21DZW50ZXJzLCBuZXcgY3VzdG9tQ2VudGVycywgbmV3IGN1c3RvbUNlbnRlcnNdO1xuZnVuY3Rpb24gc2V0Q3VzdG9tQ2VudGVycyhpLCBsczAsIGNzMCwgbDAsIHIwKSB7XG4gICAgY3VzdGNlbnRbaV0ubHMgPSBsczA7XG4gICAgY3VzdGNlbnRbaV0uY3MgPSBjczA7XG4gICAgY3VzdGNlbnRbaV0ubCA9IGwwO1xuICAgIGN1c3RjZW50W2ldLnIgPSByMDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/input/input.ts\n");

/***/ }),

/***/ "./src/main/main.ts":
/*!**************************!*\
  !*** ./src/main/main.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.blastzone = exports.stageSelect = exports.respawnPoints = exports.edgeOrientation = exports.edgeOffset = exports.edges = exports.wallsR = exports.wallsL = exports.platforms = exports.ground = exports.startingFace = exports.startingPoint = exports.frameAdvance = exports.pause = exports.colours = exports.costumeTimeout = exports.pPal = exports.tagText = exports.hasTag = exports.palettes = exports.randomTags = exports.versusMode = exports.gameMode = exports.showDebug = exports.findingPlayers = exports.frameByFrameRender = exports.wasFrameByFrame = exports.frameByFrame = exports.playing = exports.activePorts = exports.ports = exports.cpuDifficulty = exports.playerType = exports.playerAmount = exports.currentPlayers = exports.mType = exports.firstTimeDetected = exports.usingCustomControls = exports.controllerResetCountdowns = exports.gameEnd = exports.calibrationPlayer = exports.creditsPlayer = exports.shine = exports.characterSelections = exports.framerate = exports.gamelogicTime = exports.renderTime = exports.player = exports.snowCount = exports.holiday = void 0;\nexports.layerSwitches = exports.layers = exports.canvasMain = exports.c = exports.ui = exports.fg2 = exports.fg1 = exports.bg2 = exports.bg1 = exports.keyBinding = exports.keyBind = exports.keys = exports.usingLocalStorage = exports.matchTimer = exports.startTimer = exports.starting = void 0;\nexports.setControllerReset = setControllerReset;\nexports.setUsingCustomControls = setUsingCustomControls;\nexports.setMtype = setMtype;\nexports.setCurrentPlayer = setCurrentPlayer;\nexports.setTagText = setTagText;\nexports.setStageSelect = setStageSelect;\nexports.setStarting = setStarting;\nexports.setStartTimer = setStartTimer;\nexports.getStartTimer = getStartTimer;\nexports.addMatchTimer = addMatchTimer;\nexports.setMatchTimer = setMatchTimer;\nexports.getMatchTimer = getMatchTimer;\nexports.setCookie = setCookie;\nexports.setVersusMode = setVersusMode;\nexports.getCookie = getCookie;\nexports.setKeyBinding = setKeyBinding;\nexports.overrideKeyboardEvent = overrideKeyboardEvent;\nexports.disabledEventPropagation = disabledEventPropagation;\nexports.SVG = SVG;\nexports.matchTimerTick = matchTimerTick;\nexports.screenShake = screenShake;\nexports.percentShake = percentShake;\nexports.findPlayers = findPlayers;\nexports.setPlayerType = setPlayerType;\nexports.addPlayer = addPlayer;\nexports.togglePort = togglePort;\nexports.positionPlayersInCSS = positionPlayersInCSS;\nexports.changeGamemode = changeGamemode;\nexports.interpretInputs = interpretInputs;\nexports.renderToMain = renderToMain;\nexports.update = update;\nexports.gameTick = gameTick;\nexports.clearScreen = clearScreen;\nexports.renderTick = renderTick;\nexports.buildPlayerObject = buildPlayerObject;\nexports.initializePlayers = initializePlayers;\nexports.startGame = startGame;\nexports.endGame = endGame;\nexports.finishGame = finishGame;\nexports.start = start;\nexports.customDeadzone = customDeadzone;\nexports.addShine = addShine;\nexports.setShine = setShine;\nexports.setFindingPlayers = setFindingPlayers;\nexports.setPlaying = setPlaying;\nexports.setCreditsPlayer = setCreditsPlayer;\nexports.setCalibrationPlayer = setCalibrationPlayer;\nexports.cacheDom = cacheDom;\nexports.setCS = setCS;\n/* eslint-disable */\nconst css_1 = __webpack_require__(/*! ../menus/css */ \"./src/menus/css.ts\");\nconst player_1 = __webpack_require__(/*! ../main/player */ \"./src/main/player.ts\");\nconst settings_1 = __webpack_require__(/*! ../settings */ \"./src/settings.ts\");\nconst startup_1 = __webpack_require__(/*! ../menus/startup */ \"./src/menus/startup.ts\");\nconst menu_1 = __webpack_require__(/*! ../menus/menu */ \"./src/menus/menu.ts\");\nconst sfx_1 = __webpack_require__(/*! ../main/sfx */ \"./src/main/sfx.ts\");\nconst startscreen_1 = __webpack_require__(/*! ../menus/startscreen */ \"./src/menus/startscreen.ts\");\nconst stagerender_1 = __webpack_require__(/*! ../stages/stagerender */ \"./src/stages/stagerender.ts\");\nconst stageselect_1 = __webpack_require__(/*! ../menus/stageselect */ \"./src/menus/stageselect.ts\");\nconst audiomenu_1 = __webpack_require__(/*! ../menus/audiomenu */ \"./src/menus/audiomenu.ts\");\nconst gameplaymenu_1 = __webpack_require__(/*! ../menus/gameplaymenu */ \"./src/menus/gameplaymenu.ts\");\nconst keyboardmenu_1 = __webpack_require__(/*! ../menus/keyboardmenu */ \"./src/menus/keyboardmenu.ts\");\nconst controllermenu_1 = __webpack_require__(/*! ../menus/controllermenu */ \"./src/menus/controllermenu.ts\");\nconst credits_1 = __webpack_require__(/*! ../menus/credits */ \"./src/menus/credits.ts\");\nconst render_1 = __webpack_require__(/*! ../main/render */ \"./src/main/render.ts\");\nconst actionStateShortcuts_1 = __webpack_require__(/*! ../physics/actionStateShortcuts */ \"./src/physics/actionStateShortcuts.ts\");\nconst hitDetection_1 = __webpack_require__(/*! ../physics/hitDetection */ \"./src/physics/hitDetection.ts\");\nconst article_1 = __webpack_require__(/*! ../physics/article */ \"./src/physics/article.ts\");\nconst ai_1 = __webpack_require__(/*! ../main/ai */ \"./src/main/ai.ts\");\nconst physics_1 = __webpack_require__(/*! ../physics/physics */ \"./src/physics/physics.ts\");\nconst jquery_1 = __importDefault(__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"));\nconst transparency_1 = __webpack_require__(/*! ../main/vfx/transparency */ \"./src/main/vfx/transparency.js\");\nconst drawVfx_1 = __webpack_require__(/*! ../main/vfx/drawVfx */ \"./src/main/vfx/drawVfx.js\");\nconst vfxQueue_1 = __webpack_require__(/*! ../main/vfx/vfxQueue */ \"./src/main/vfx/vfxQueue.js\");\nconst activeStage_1 = __webpack_require__(/*! ../stages/activeStage */ \"./src/stages/activeStage.ts\");\nconst music_1 = __webpack_require__(/*! ./music */ \"./src/main/music.ts\");\nconst vfx_1 = __webpack_require__(/*! ../main/vfx */ \"./src/main/vfx.ts\");\nconst renderVfx_1 = __webpack_require__(/*! ./vfx/renderVfx */ \"./src/main/vfx/renderVfx.js\");\nconst Box2D_1 = __webpack_require__(/*! ./util/Box2D */ \"./src/main/util/Box2D.ts\");\nconst Vec2D_1 = __webpack_require__(/*! ./util/Vec2D */ \"./src/main/util/Vec2D.ts\");\nconst streamclient_1 = __webpack_require__(/*! ./multiplayer/streamclient */ \"./src/main/multiplayer/streamclient.js\");\nconst replay_1 = __webpack_require__(/*! ./replay */ \"./src/main/replay.ts\");\nconst input_1 = __webpack_require__(/*! ../input/input */ \"./src/input/input.ts\");\nconst meleeInputs_1 = __webpack_require__(/*! ../input/meleeInputs */ \"./src/input/meleeInputs.ts\");\nconst findGamepadInfo_1 = __webpack_require__(/*! ../input/gamepad/findGamepadInfo */ \"./src/input/gamepad/findGamepadInfo.ts\");\nconst custom_1 = __webpack_require__(/*! ../input/gamepad/gamepads/custom */ \"./src/input/gamepad/gamepads/custom.js\");\nconst retrieveGamepadInputs_1 = __webpack_require__(/*! ../input/gamepad/retrieveGamepadInputs */ \"./src/input/gamepad/retrieveGamepadInputs.ts\");\nconst drawGamepad_1 = __webpack_require__(/*! ../input/gamepad/drawGamepad */ \"./src/input/gamepad/drawGamepad.ts\");\nconst deepCopyObject_1 = __webpack_require__(/*! ./util/deepCopyObject */ \"./src/main/util/deepCopyObject.ts\");\nconst css_2 = __webpack_require__(/*! ../menus/css */ \"./src/menus/css.ts\");\n/*globals performance*/\nexports.holiday = 0;\nexports.snowCount = 150;\n//todo find 'Player' object\nexports.player = [0, 0, 0, 0];\nexports.renderTime = [10, 0, 100, 0];\nexports.gamelogicTime = [5, 0, 100, 0];\nexports.framerate = [0, 0, 0];\nexports.characterSelections = [0, 0, 0, 0];\nexports.shine = 0.5;\nexports.creditsPlayer = 0;\nexports.calibrationPlayer = 0;\nexports.gameEnd = false;\nexports.controllerResetCountdowns = [0, 0, 0, 0];\nfunction setControllerReset(i) {\n    exports.controllerResetCountdowns[i] = 0;\n}\nlet keyboardOccupied = false;\nexports.usingCustomControls = [false, false, false, false];\nfunction setUsingCustomControls(i, boolean, info) {\n    exports.usingCustomControls[i] = boolean;\n    if (bool) {\n        exports.mType[i] = custom_1.customGamepadInfo[exports.currentPlayers[i]];\n    }\n    else {\n        exports.mType[i] = info;\n    }\n}\nexports.firstTimeDetected = [true, true, true, true];\nwindow.mType = [null, null, null, null];\nexports.mType = [null, null, null, null];\nfunction setMtype(index, val) {\n    exports.mType[index] = val;\n}\nexports.currentPlayers = [];\nfunction setCurrentPlayer(index, val) {\n    exports.currentPlayers[index] = val;\n}\nexports.playerAmount = 0;\nexports.playerType = [-1, -1, -1, -1];\nexports.cpuDifficulty = [3, 3, 3, 3];\nexports.ports = 0;\nexports.activePorts = [];\nexports.playing = false;\nexports.frameByFrame = false;\nexports.wasFrameByFrame = false;\nexports.frameByFrameRender = false;\nexports.findingPlayers = true;\nexports.showDebug = false;\nexports.gameMode = 20;\n// 20:Startup\n// 13:Data Menu\n// 12:Keyboard Controls\n// 11:Gameplay Menu\n// 10:Sound Menu\n// 9: -\n// 8: -\n// 7:Target Select\n// 6:Stage Select (VS)\n// 5:Target Playing\n// 4:Target Builder\n// 3:Playing (VS)\n// 2:CSS\n// 1:Main Menu\n// 0:Title Screen\nexports.versusMode = 0;\nexports.randomTags = [\"NEO!\", \"SELF\", \"NOVA\", \"PNDA\", \"Panda\", \"LFFN\", \"Scorp\", \"AZ\", \"AXE\", \"Tempo\", \"TMPO\", \"[A]rmada\", \"WBALLZ\", \"Westballz\", \"PPMD\", \"Kreygasm\", \"M2K\", \"Mang0\", \"USA\", \"SCAR\", \"TOPH\", \"(.Y.)\", \"HBOX\", \"HungryBox\", \"PLUP\", \"Shroomed\", \"SFAT\", \"Wizz\", \"Lucky\", \"S2J\", \"SilentWolf\", \"aMSa\", \"S2J\", \"Hax$\"];\nexports.palettes = [[\"rgb(250, 89, 89)\", \"rgb(255, 170, 170)\", \"rgba(255, 206, 111, \", \"rgb(244, 68, 68)\", \"rgba(255, 225, 167, \"],\n    [\"rgb(95, 216, 84)\", \"rgb(184, 253, 154)\", \"rgba(252, 95, 95, \", \"rgb(255, 182, 96)\", \"rgba(254, 141, 141, \"],\n    [\"rgb(5, 195, 255)\", \"rgb(121, 223, 255)\", \"rgba(218, 96, 254, \", \"rgb(231, 134, 255)\", \"rgba(230, 144, 255, \"],\n    [\"rgb(255, 187, 70)\", \"rgb(248, 255, 122)\", \"rgba(80, 182, 255, \", \"rgb(255, 142, 70)\", \"rgba(139, 203, 249, \"],\n    [\"rgb(177, 89, 255)\", \"rgb(203, 144, 255)\", \"rgba(144, 255, 110, \", \"rgb(247, 126, 250)\", \"rgba(190, 255, 170, \"],\n    [\"rgb(182, 131, 70)\", \"rgb(252, 194, 126)\", \"rgba(47, 186, 123, \", \"rgb(255, 112, 66)\", \"rgba(111, 214, 168, \"],\n    [\"rgb(232, 232, 208)\", \"rgb(255, 255, 255)\", \"rgba(244, 255, 112, \", \"rgb(191, 119, 119)\", \"rgba(255, 255, 200, \"]];\nexports.hasTag = [false, false, false, false];\nexports.tagText = [\"\", \"\", \"\", \"\"];\nfunction setTagText(index, value) {\n    exports.tagText[index] = value;\n    exports.hasTag[index] = true;\n}\nexports.pPal = [0, 1, 2, 3];\nexports.costumeTimeout = [];\nexports.colours = [\"rgba(4, 255, 82, 0.62)\", \"rgba(117, 20, 255, 0.63)\", \"rgba(255, 20, 20, 0.63)\", \"rgba(255, 232, 20, 0.63)\"];\nexports.pause = [[true, true], [true, true], [true, true], [true, true]];\nexports.frameAdvance = [[true, true], [true, true], [true, true], [true, true]];\nexports.startingPoint = [[-50, 50], [50, 50], [-25, 5], [25, 5]];\nexports.startingFace = [1, -1, 1, -1];\nexports.ground = [[-68.4, 0], [68.4, 0]];\nexports.platforms = [[[-57.6, 27.2], [-20, 27.2]], [[20, 27.2], [57.6, 27.2]], [[-18.8, 54.4], [18.8, 54.4]]];\nexports.wallsL = [[[-68.4, 0], [-68.4, -108.8]]];\nexports.wallsR = [[[68.4, 0], [68.4, -108.8]]];\nexports.edges = [[[-68.4, 0], [-63.4, 0]], [[68.4, 0], [63.4, 0]]];\n//edgeOffset = [[-71.3,-23.7],[71.3,-23.7]];\nexports.edgeOffset = [[-2.9, -23.7], [2.9, -23.7]];\nexports.edgeOrientation = [1, -1];\nexports.respawnPoints = [[-50, 50, 1], [50, 50, -1], [25, 35, 1], [-25, 35, -1]];\nexports.stageSelect = 0;\nfunction setStageSelect(val) {\n    exports.stageSelect = val;\n}\nexports.blastzone = new Box2D_1.Box2D([-224, 200], [224, -108.8]);\nexports.starting = true;\nfunction setStarting(val) {\n    exports.starting = val;\n}\nexports.startTimer = 1.5;\nfunction setStartTimer(val) {\n    exports.startTimer = val;\n}\nfunction getStartTimer() {\n    return exports.startTimer;\n}\n//matchTimer = 5999.99;\nexports.matchTimer = 480;\nfunction addMatchTimer(val) {\n    exports.matchTimer += val;\n}\nfunction setMatchTimer(val) {\n    exports.matchTimer = val;\n}\nfunction getMatchTimer() {\n    return exports.matchTimer;\n}\nexports.usingLocalStorage = false;\nif (typeof (Storage) !== \"undefined\") {\n    // Code for localStorage/sessionStorage.\n    exports.usingLocalStorage = true;\n    console.log(\"local storage works\");\n}\nelse {\n    // Sorry! No Web Storage support..\n    console.log(\"local storage does not work\");\n}\nfunction setCookie(cname, cvalue, exdays) {\n    var d = new Date();\n    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));\n    var exp = \"expires=\" + d.toUTCString();\n    document.cookie = cname + \"=\" + cvalue + \"; \" + exp;\n    localStorage.setItem(cname, cvalue);\n}\nfunction setVersusMode(val) {\n    exports.versusMode = val;\n}\nfunction getCookie(cname) {\n    if (exports.usingLocalStorage) {\n        return localStorage.getItem(cname);\n    }\n    else {\n        var name = cname + \"=\";\n        var ca = document.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ')\n                c = c.substring(1);\n            if (c.indexOf(name) == 0)\n                return c.substring(name.length, c.length);\n        }\n        return \"\";\n    }\n}\nexports.keys = {};\nexports.keyBind = 0;\nexports.keyBinding = false;\nfunction setKeyBinding(val) {\n    exports.keyBinding = val;\n}\nfunction overrideKeyboardEvent(e) {\n    if (!showingCode && css_1.choosingTag == -1 && e.keyCode != 122 && e.keyCode != 116) {\n        switch (e.type) {\n            case \"keydown\":\n                if (!exports.keys[e.keyCode]) {\n                    exports.keys[e.keyCode] = true;\n                    exports.keyBind = e.keyCode;\n                    exports.keyBinding = true;\n                    // do key down stuff here\n                }\n                break;\n            case \"keyup\":\n                delete (exports.keys[e.keyCode]);\n                // do key up stuff here\n                break;\n        }\n        disabledEventPropagation(e);\n        e.preventDefault();\n        return false;\n    }\n    else {\n        if (css_1.choosingTag > -1) {\n            if (e.keyCode == 13) {\n                switch (e.type) {\n                    case \"keydown\":\n                        exports.keys[13] = true;\n                        break;\n                    case \"keyup\":\n                        delete (exports.keys[13]);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        return true;\n    }\n}\n;\nfunction disabledEventPropagation(e) {\n    if (e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        }\n        else if (event) {\n            event.cancelBubble = true;\n        }\n    }\n}\n;\ndocument.onkeydown = overrideKeyboardEvent;\ndocument.onkeyup = overrideKeyboardEvent;\n/*var keys = [];\nexport const onkeyup (e) {\n  keys[e.keyCode]=false;\n}\nexport const onkeydown (e) {\n  keys[e.keyCode]=true;\n}*/\nfunction SVG(tag) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tag);\n}\n/*if (Gamepad.supported) {\n    console.log(\"gamepad supported\");\n} else {\n    console.log(\"gamepad not supported\");\n}*/\nwindow.addEventListener(\"gamepadconnected\", function (e) {\n    console.log(\"Gamepad connected at index %d: %s. %d buttons, %d axes.\", e.gamepad.index, e.gamepad.id, e.gamepad.buttons.length, e.gamepad.axes.length);\n});\nif (navigator.getGamepads)\n    console.log(navigator.getGamepads());\nfunction matchTimerTick(input) {\n    exports.matchTimer -= 0.016667;\n    if (dom.matchMinutes && dom.matchSeconds) {\n        var sec = (exports.matchTimer % 60).toFixed(2);\n        dom.matchMinutes.innerHTML = Math.floor(exports.matchTimer / 60);\n        dom.matchSeconds.innerHTML = sec.length < 5 ? `0${sec}` : sec;\n    }\n    if (exports.matchTimer <= 0) {\n        finishGame(input);\n    }\n}\nfunction screenShake(kb) {\n    var seed = [Math.random(), Math.random(), Math.random(), Math.random()];\n    exports.fg1.translate(kb * 0.1 * seed[0], kb * 0.1 * seed[1]);\n    setTimeout(function () { exports.fg1.translate(-kb * 0.05 * seed[0], -kb * 0.05 * seed[1]); }, 20);\n    setTimeout(function () { exports.fg1.translate(-kb * 0.05 * seed[0], -kb * 0.05 * seed[1]); exports.fg1.translate(-kb * 0.1 * seed[2], -kb * 0.1 * seed[3]); }, 40);\n    setTimeout(function () { exports.fg1.translate(kb * 0.05 * seed[2], kb * 0.05 * seed[3]); }, 60);\n    setTimeout(function () { exports.fg1.translate(kb * 0.05 * seed[2], kb * 0.05 * seed[3]); }, 80);\n}\nfunction percentShake(kb, i) {\n    exports.player[i].percentShake = new Vec2D_1.Vec2D(kb * 0.1 * Math.random(), kb * 0.1 * Math.random());\n    setTimeout(function () { exports.player[i].percentShake = new Vec2D_1.Vec2D(kb * 0.05 * Math.random(), kb * 0.05 * Math.random()); }, 20);\n    setTimeout(function () { exports.player[i].percentShake = new Vec2D_1.Vec2D(-kb * 0.1 * Math.random(), -kb * 0.1 * Math.random()); }, 40);\n    setTimeout(function () { exports.player[i].percentShake = new Vec2D_1.Vec2D(-kb * 0.05 * Math.random(), -kb * 0.05 * Math.random()); }, 60);\n    setTimeout(function () { exports.player[i].percentShake = new Vec2D_1.Vec2D(0, 0); }, 80);\n}\nfunction findPlayers() {\n    var gps = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n    /*if (typeof gps != \"undefined\"){\n      console.log(gps);\n    }*/\n    if (!keyboardOccupied) {\n        if (exports.gameMode < 2 || exports.gameMode == 20) {\n            if (exports.keys[13] || exports.keys[settings_1.keyMap.s[0]] || exports.keys[settings_1.keyMap.s[1]]) {\n                if (exports.ports < 4) {\n                    changeGamemode(1);\n                    (0, jquery_1.default)(\"#keyboardPrompt\").hide();\n                    keyboardOccupied = true;\n                    sfx_1.sounds.menuForward.play();\n                    if (exports.ports == 0) {\n                        music_1.MusicManager.playMenuLoop();\n                    }\n                    addPlayer(exports.ports, \"keyboard\");\n                }\n            }\n        }\n        else {\n            if (exports.keys[settings_1.keyMap.a[0]] || exports.keys[settings_1.keyMap.a[1]]) {\n                if (exports.ports < 4) {\n                    keyboardOccupied = true;\n                    addPlayer(exports.ports, \"keyboard\");\n                }\n            }\n        }\n    }\n    for (var i = 0; i < gps.length; i++) {\n        var gamepad = navigator.getGamepads ? navigator.getGamepads()[i] : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads()[i] : null);\n        if (exports.playerType[i] === 2) {\n            var alreadyIn = false;\n            for (var k = 0; k < exports.ports; k++) {\n                if (exports.currentPlayers[k] === i) {\n                    alreadyIn = true;\n                }\n            }\n            if (!alreadyIn) {\n                if (exports.ports < 4) {\n                    addPlayer(i, 99);\n                }\n            }\n            continue;\n        }\n        var gamepad = navigator.getGamepads ? navigator.getGamepads()[i] : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads()[i] : null);\n        if (typeof gamepad != \"undefined\" && gamepad != null) {\n            var detected = false;\n            var gpdName;\n            var gpdInfo;\n            if (exports.usingCustomControls[i] && custom_1.customGamepadInfo[i] !== null) {\n                gpdName = \"custom controls\";\n                gpdInfo = custom_1.customGamepadInfo[i];\n                detected = true;\n            }\n            else {\n                const maybeNameAndInfo = (0, findGamepadInfo_1.getGamepadNameAndInfo)(gamepad.id);\n                if (maybeNameAndInfo === null) {\n                    console.log(\"Error in 'findPlayers': controller \" + (i + 1) + \" detected but not supported.\");\n                    console.log(\"Try manual calibration of your controller.\");\n                }\n                else {\n                    detected = true;\n                    [gpdName, gpdInfo] = maybeNameAndInfo;\n                }\n            }\n            if (detected) {\n                if (exports.firstTimeDetected[i]) {\n                    console.log(\"Controller \" + (i + 1) + \" is: \" + gpdName + \".\");\n                    exports.firstTimeDetected[i] = false;\n                }\n                if (exports.gameMode < 2 || exports.gameMode == 20) {\n                    if ((0, retrieveGamepadInputs_1.buttonState)(gamepad, gpdInfo, \"s\")) {\n                        var alreadyIn = false;\n                        for (var k = 0; k < exports.ports; k++) {\n                            if (exports.currentPlayers[k] == i) {\n                                alreadyIn = true;\n                            }\n                        }\n                        if (!alreadyIn) {\n                            if (exports.ports < 4) {\n                                changeGamemode(1);\n                                (0, jquery_1.default)(\"#keyboardPrompt\").hide();\n                                sfx_1.sounds.menuForward.play();\n                                if (exports.ports === 0) {\n                                    music_1.MusicManager.playMenuLoop();\n                                }\n                                addPlayer(i, gpdInfo);\n                            }\n                        }\n                    }\n                }\n                else {\n                    if ((0, retrieveGamepadInputs_1.buttonState)(gamepad, gpdInfo, \"a\")) {\n                        var alreadyIn = false;\n                        for (var k = 0; k < exports.ports; k++) {\n                            if (exports.currentPlayers[k] == i) {\n                                alreadyIn = true;\n                            }\n                        }\n                        if (!alreadyIn) {\n                            if (exports.ports < 4) {\n                                addPlayer(i, gpdInfo);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                console.log(\"No controller detected by browser\");\n            }\n        }\n    }\n}\nfunction setPlayerType(playerSlot, type) {\n    exports.playerType[playerSlot] = type;\n}\nfunction addPlayer(i, controllerInfo) {\n    if (controllerInfo === 99) {\n        exports.ports++;\n        exports.currentPlayers[exports.ports - 1] = i;\n        exports.playerType[exports.ports - 1] = 2;\n        exports.mType[exports.ports - 1] = controllerInfo;\n    }\n    else {\n        exports.ports++;\n        exports.currentPlayers[exports.ports - 1] = i;\n        exports.playerType[exports.ports - 1] = 0;\n        exports.mType[exports.ports - 1] = controllerInfo;\n        if (exports.showDebug) {\n            (0, drawGamepad_1.updateGamepadSVGColour)(i, \"gamepadSVG\" + i);\n            document.getElementById(\"gamepadSVG\" + i).style.display = \"\";\n        }\n    }\n}\nfunction togglePort(i) {\n    exports.playerType[i]++;\n    if (exports.playerType[i] == 3) {\n        exports.playerType[i] = -1;\n        if (exports.showDebug) {\n            document.getElementById(\"gamepadSVG\" + i).style.display = \"none\";\n        }\n    }\n    if (exports.playerType[i] == 0 && exports.ports <= i) {\n        exports.playerType[i] = 1;\n        (0, drawGamepad_1.setGamepadSVGColour)(i, \"black\");\n        if (exports.showDebug) {\n            (0, drawGamepad_1.updateGamepadSVGColour)(i, \"gamepadSVG\" + i);\n            document.getElementById(\"gamepadSVG\" + i).style.display = \"\";\n        }\n    }\n}\nfunction positionPlayersInCSS() {\n    for (var i = 0; i < 4; i++) {\n        var x = (-80 + i * 50) * 2 / 3;\n        var y = -30;\n        exports.player[i].phys.pos = new Vec2D_1.Vec2D(x, y);\n        exports.player[i].phys.hurtbox = new Box2D_1.Box2D([-4 + x, 18 + y], [4 + x, y]);\n    }\n}\n// 20:Startup\n// 14:Controller Menu\n// 13:Data Menu\n// 12:Keyboard Controls\n// 11:Gameplay Menu\n// 10:Sound Menu\n// 9: -\n// 8: -\n// 7:Target Select\n// 6:Stage Select (VS)\n// 5:Target Playing\n// 4:Target Builder\n// 3:Playing (VS)\n// 2:CSS\n// 1:Main Menu\n// 0:Title Screen\nfunction changeGamemode(newGamemode) {\n    exports.bg1.fillStyle = \"black\";\n    exports.bg1.fillRect(0, 0, exports.layers.BG1.width, exports.layers.BG1.height);\n    exports.fg1.clearRect(0, 0, exports.layers.FG1.width, exports.layers.FG1.height);\n    exports.gameMode = newGamemode;\n    switch (newGamemode) {\n        // TITLESCREEN\n        case 0:\n            (0, startscreen_1.drawStartScreenInit)();\n            break;\n        // MAIN MENU\n        case 1:\n            (0, jquery_1.default)(\"#logoVid\").remove();\n            (0, menu_1.drawMainMenuInit)();\n            break;\n        // CSS\n        case 2:\n            (0, css_1.drawCSSInit)();\n            break;\n        // Playing (VS)\n        case 3:\n            (0, stagerender_1.drawBackgroundInit)();\n            (0, stagerender_1.drawStageInit)();\n            break;\n        // Target Builder\n        case 4:\n            break;\n        // Target Playing\n        case 5:\n            (0, stagerender_1.drawBackgroundInit)();\n            (0, stagerender_1.drawStageInit)();\n            break;\n        // Stage select (vs)\n        case 6:\n            (0, stageselect_1.drawSSSInit)();\n            break;\n        // Target Select\n        case 7:\n            drawTSSInit();\n            break;\n        // sound menu\n        case 10:\n            (0, audiomenu_1.drawAudioMenuInit)();\n            break;\n        // gameplay menu\n        case 11:\n            (0, gameplaymenu_1.drawGameplayMenuInit)();\n            break;\n        // keyboard menu\n        case 12:\n            (0, keyboardmenu_1.drawKeyboardMenuInit)();\n            break;\n        // credits\n        case 13:\n            (0, credits_1.drawCreditsInit)();\n            break;\n        // Multiplayer Modes\n        case 14:\n            (0, controllermenu_1.drawControllerMenuInit)();\n            break;\n        case 15:\n            (0, css_1.drawCSSInit)();\n            (0, streamclient_1.connectToMPServer)();\n            break;\n        // startup\n        case 20:\n            break;\n        default:\n            break;\n    }\n}\n/*export const addPlayer (i,gType,pType){\n  console.log(i,gType,pType);\n\n  currentPlayers.push(i);\n  if (pType == 0){\n    ports++;\n    mType[ports-1] = gType;\n    playerType[ports-1] = pType;\n\n    costumeTimeout.push(false);\n    pPal.push(ports-1);\n    buildPlayerObject(ports-1);\n    player[playerAmount-1].phys.pos = new Vec2D(-100+25*(playerAmount=1),-40);\n    player[ports-1].phys.face = 1;\n    player[ports-1].actionState = 0;\n    $(\"#currentPlayers\").append('<div class=\"pBoxBox\"><div class=\"playerBox\" id=\"pBox'+(ports-1)+'\" style=\"background-color:'+palettes[pPal[ports-1]][0]+';border:5px solid '+palettes[pPal[ports-1]][2]+'0.8)\"><p>P'+ports+'<br><span class=\"cont\">(Cont. '+i+')</span></p></div><div id=\"pTag'+(ports-1)+'\" class=\"pTag\"><textarea id=\"pTagEdit'+(ports-1)+'\" class=\"pTagEdit\" maxlength=\"10\"></textarea></div></div>');\n  }\n  else {\n    mType[i] = gType;\n\n    costumeTimeout.push(false);\n    pPal.push(i);\n    buildPlayerObject(i);\n    player[playerAmount-1].phys.pos = new Vec2D(-100+25*(playerAmount=1),-40);\n    player[i].phys.face = 1;\n    player[i].actionState = 0;\n    $(\"#currentPlayers\").append('<div class=\"pBoxBox\"><div class=\"playerBox\" id=\"pBox'+i+'\" style=\"background-color:'+palettes[pPal[i]][0]+';border:5px solid '+palettes[pPal[i]][2]+'0.8)\"><p>P'+(i+1)+'<br><span class=\"cont\">(Cont. '+i+')</span></p></div><div id=\"pTag'+i+'\" class=\"pTag\"><textarea id=\"pTagEdit'+i+'\" class=\"pTagEdit\" maxlength=\"10\"></textarea></div></div>');\n  }\n  playerAmount++;\n}\n\nexport const removePlayer (i){\n  playerType[i] = -1;\n  playerAmount--;\n}*/\nfunction interpretInputs(i, active, playertype, inputBuffer) {\n    let tempBuffer = (0, input_1.nullInputs)();\n    // keep updating Z and Start all the time, even when paused\n    for (var k = 0; k < 7; k++) {\n        tempBuffer[7 - k].z = inputBuffer[6 - k].z;\n        tempBuffer[7 - k].s = inputBuffer[6 - k].s;\n    }\n    tempBuffer[0] = (0, input_1.pollInputs)(exports.gameMode, exports.frameByFrame, exports.mType[i], i, exports.currentPlayers[i], exports.keys, playertype);\n    let pastOffset = 0;\n    if ((exports.gameMode !== 3 && exports.gameMode !== 5) || (exports.playing && (exports.pause[i][1] || !exports.pause[i][0]))\n        || exports.wasFrameByFrame\n        || (!exports.playing && exports.pause[i][0] && !exports.pause[i][1])) {\n        pastOffset = 1;\n    }\n    exports.pause[i][1] = exports.pause[i][0];\n    exports.wasFrameByFrame = false;\n    exports.frameAdvance[i][1] = exports.frameAdvance[i][0];\n    for (var k = 0; k < 7; k++) {\n        tempBuffer[7 - k].lsX = inputBuffer[7 - k - pastOffset].lsX;\n        tempBuffer[7 - k].lsY = inputBuffer[7 - k - pastOffset].lsY;\n        tempBuffer[7 - k].rawX = inputBuffer[7 - k - pastOffset].rawX;\n        tempBuffer[7 - k].rawY = inputBuffer[7 - k - pastOffset].rawY;\n        tempBuffer[7 - k].csX = inputBuffer[7 - k - pastOffset].csX;\n        tempBuffer[7 - k].csY = inputBuffer[7 - k - pastOffset].csY;\n        tempBuffer[7 - k].rawcsX = inputBuffer[7 - k - pastOffset].rawcsX;\n        tempBuffer[7 - k].rawcsY = inputBuffer[7 - k - pastOffset].rawcsY;\n        tempBuffer[7 - k].lA = inputBuffer[7 - k - pastOffset].lA;\n        tempBuffer[7 - k].rA = inputBuffer[7 - k - pastOffset].rA;\n        tempBuffer[7 - k].a = inputBuffer[7 - k - pastOffset].a;\n        tempBuffer[7 - k].b = inputBuffer[7 - k - pastOffset].b;\n        tempBuffer[7 - k].x = inputBuffer[7 - k - pastOffset].x;\n        tempBuffer[7 - k].y = inputBuffer[7 - k - pastOffset].y;\n        tempBuffer[7 - k].r = inputBuffer[7 - k - pastOffset].r;\n        tempBuffer[7 - k].l = inputBuffer[7 - k - pastOffset].l;\n        tempBuffer[7 - k].dl = inputBuffer[7 - k - pastOffset].dl;\n        tempBuffer[7 - k].dd = inputBuffer[7 - k - pastOffset].dd;\n        tempBuffer[7 - k].dr = inputBuffer[7 - k - pastOffset].dr;\n        tempBuffer[7 - k].du = inputBuffer[7 - k - pastOffset].du;\n    }\n    if (exports.mType !== null) {\n        if ((exports.mType[i] === \"keyboard\" && (tempBuffer[0].z || tempBuffer[1].z))\n            || (exports.mType[i] !== \"keyboard\" && (tempBuffer[0].z && !tempBuffer[1].z))) {\n            exports.frameAdvance[i][0] = true;\n        }\n        else {\n            exports.frameAdvance[i][0] = false;\n        }\n    }\n    if (exports.frameAdvance[i][0] && !exports.frameAdvance[i][1] && !exports.playing && exports.gameMode !== 4) {\n        exports.frameByFrame = true;\n    }\n    if (exports.mType[i] === \"keyboard\") { // keyboard controls\n        if (tempBuffer[0].s || tempBuffer[1].s || (exports.gameMode === 5 && (tempBuffer[0].du || tempBuffer[1].du))) {\n            exports.pause[i][0] = true;\n        }\n        else {\n            exports.pause[i][0] = false;\n        }\n        if (!exports.playing && (exports.gameMode == 3 || exports.gameMode == 5)\n            && (tempBuffer[0].a || tempBuffer[1].a) && (tempBuffer[0].l || tempBuffer[1].l)\n            && (tempBuffer[0].r || tempBuffer[1].r) && (tempBuffer[0].s || tempBuffer[1].s)) {\n            if (tempBuffer[0].b || tempBuffer[1].b) {\n                startGame();\n            }\n            else {\n                endGame(inputBuffer);\n            }\n        }\n        interpretPause(exports.pause[i][0], exports.pause[i][1]);\n    }\n    else if (exports.mType[i] !== null) { // gamepad controls\n        if (!exports.playing && (exports.gameMode == 3 || exports.gameMode == 5) &&\n            (tempBuffer[0].a && tempBuffer[0].l && tempBuffer[0].r && tempBuffer[0].s)\n            && (!(tempBuffer[1].a && tempBuffer[1].l && tempBuffer[1].r && tempBuffer[1].s))) {\n            if (tempBuffer[0].b) {\n                startGame();\n            }\n            else {\n                endGame(inputBuffer);\n            }\n        }\n        if (tempBuffer[0].s || tempBuffer[0].du && exports.gameMode == 5) {\n            exports.pause[i][0] = true;\n        }\n        else {\n            exports.pause[i][0] = false;\n        }\n        // Controller reset functionality\n        if ((tempBuffer[0].z || tempBuffer[0].du) && tempBuffer[0].x && tempBuffer[0].y) {\n            exports.controllerResetCountdowns[i] -= 1;\n            if (exports.controllerResetCountdowns[i] === 0) {\n                // triggers code in input.js\n                console.log(\"Controller #\" + (i + 1) + \" was reset!\");\n                (0, jquery_1.default)(\"#resetIndicator\" + i).fadeIn(100);\n                (0, jquery_1.default)(\"#resetIndicator\" + i).fadeOut(500);\n            }\n        }\n        else {\n            exports.controllerResetCountdowns[i] = 125;\n        }\n        interpretPause(exports.pause[i][0], exports.pause[i][1]);\n    }\n    else { // AI\n        tempBuffer[0].rawX = tempBuffer[0].lsX;\n        tempBuffer[0].rawY = tempBuffer[0].lsY;\n        tempBuffer[0].rawcsX = tempBuffer[0].csX;\n        tempBuffer[0].rawcsY = tempBuffer[0].csY;\n        tempBuffer[0].lsX = (0, meleeInputs_1.deaden)(tempBuffer[0].rawX);\n        tempBuffer[0].lsY = (0, meleeInputs_1.deaden)(tempBuffer[0].rawY);\n        tempBuffer[0].csX = (0, meleeInputs_1.deaden)(tempBuffer[0].rawcsX);\n        tempBuffer[0].csY = (0, meleeInputs_1.deaden)(tempBuffer[0].rawcsY);\n    }\n    if (exports.showDebug) {\n        (0, jquery_1.default)(\"#lsAxisX\" + i).empty().append(tempBuffer[0].lsX.toFixed(3));\n        (0, jquery_1.default)(\"#lsAxisY\" + i).empty().append(tempBuffer[0].lsY.toFixed(3));\n        (0, jquery_1.default)(\"#csAxisX\" + i).empty().append(tempBuffer[0].csX.toFixed(3));\n        (0, jquery_1.default)(\"#csAxisY\" + i).empty().append(tempBuffer[0].csY.toFixed(3));\n        (0, jquery_1.default)(\"#lAnalog\" + i).empty().append(tempBuffer[0].lA.toFixed(3));\n        (0, jquery_1.default)(\"#rAnalog\" + i).empty().append(tempBuffer[0].rA.toFixed(3));\n        (0, drawGamepad_1.updateGamepadSVGState)(i, \"gamepadSVG\" + i, tempBuffer[0]);\n    }\n    if (exports.gameMode === 14) { // controller calibration screen\n        (0, drawGamepad_1.updateGamepadSVGState)(i, \"gamepadSVGCalibration\", tempBuffer[0]);\n    }\n    if (exports.showDebug || exports.gameMode === 14) {\n        const which = (exports.showDebug && exports.gameMode === 14) ? \"both\" : exports.showDebug ? \"debug\" : \"calibration\";\n        if (tempBuffer[0].x && !tempBuffer[1].x && tempBuffer[0].du) {\n            (0, drawGamepad_1.cycleGamepadColour)(i, which, true);\n        }\n        if (tempBuffer[0].y && !tempBuffer[1].y && tempBuffer[0].du) {\n            (0, drawGamepad_1.cycleGamepadColour)(i, which, false);\n        }\n    }\n    if (streamclient_1.giveInputs[i] === true) {\n        //turns out keyboards leave gaps in the input buffer\n        (0, deepCopyObject_1.deepObjectMerge)(true, (0, input_1.nullInput)(), tempBuffer[0]);\n        (0, streamclient_1.updateNetworkInputs)(tempBuffer[0], i);\n    }\n    if (active) {\n        if (tempBuffer[0].dl && !tempBuffer[1].dl) {\n            exports.player[i].showLedgeGrabBox ^= true;\n        }\n        if (tempBuffer[0].dd && !tempBuffer[1].dd) {\n            exports.player[i].showECB ^= true;\n        }\n        if (tempBuffer[0].dr && !tempBuffer[1].dr) {\n            exports.player[i].showHitbox ^= true;\n        }\n    }\n    if (exports.frameByFrame) {\n        tempBuffer[0].z = false;\n    }\n    return tempBuffer;\n}\nfunction interpretPause(pause0, pause1) {\n    if (pause0 && !pause1) {\n        if (exports.gameMode == 3 || exports.gameMode == 5) {\n            exports.playing ^= true;\n            if (!exports.playing) {\n                sfx_1.sounds.pause.play();\n                changeVolume(music_1.MusicManager, audiomenu_1.masterVolume[1] * 0.3, 1);\n                (0, render_1.renderForeground)();\n            }\n            else {\n                changeVolume(music_1.MusicManager, audiomenu_1.masterVolume[1], 1);\n            }\n        }\n    }\n}\nexports.bg1 = 0;\nexports.bg2 = 0;\nexports.fg1 = 0;\nexports.fg2 = 0;\nexports.ui = 0;\nexports.c = 0;\nexports.canvasMain = 0;\nexports.layers = {\n    BG1: 0,\n    BG2: 0,\n    FG1: 0,\n    FG2: 0,\n    UI: 0\n};\nexports.layerSwitches = {\n    BG1: true,\n    BG2: true,\n    FG1: true,\n    FG2: true,\n    UI: true\n};\nfunction renderToMain() {\n    var keys = Object.keys(exports.layers);\n    for (var i = 0; i < keys.length; i++) {\n        if (exports.layerSwitches[keys[i]]) {\n            exports.c.drawImage(exports.layers[keys[i]], 0, 0);\n        }\n    }\n}\nfunction update(i, inputBuffers) {\n    if (!exports.starting) {\n        if (exports.currentPlayers[i] != -1) {\n            if (exports.playerType[i] == 0) {\n                // do nothing, use the provided player i inputs\n            }\n            else if (exports.playerType[i] === 1) {\n                if (exports.player[i].actionState != \"SLEEP\") {\n                    (0, ai_1.runAI)(i); // no need to return input since polling returns ai input if they are active\n                }\n            }\n        }\n    }\n    (0, physics_1.physics)(i, inputBuffers);\n}\nlet delta = 0;\nlet lastFrameTimeMs = 0;\nlet lastUpdate = performance.now();\nfunction gameTick(oldInputBuffers) {\n    var start = performance.now();\n    var diff = 0;\n    let input = [(0, input_1.nullInputs)(), (0, input_1.nullInputs)(), (0, input_1.nullInputs)(), (0, input_1.nullInputs)()];\n    if (exports.gameMode == 0 || exports.gameMode == 20) {\n        findPlayers();\n    }\n    else if (exports.gameMode == 1) {\n        //console.log(playerType);\n        for (var i = 0; i < exports.ports; i++) {\n            input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n            (0, menu_1.menuMove)(i, input);\n        }\n    }\n    else if (exports.gameMode == 10) {\n        for (var i = 0; i < exports.ports; i++) {\n            input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n            (0, audiomenu_1.audioMenuControls)(i, input);\n        }\n    }\n    else if (exports.gameMode == 11) {\n        for (var i = 0; i < exports.ports; i++) {\n            input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n            (0, gameplaymenu_1.gameplayMenuControls)(i, input);\n        }\n    }\n    else if (exports.gameMode == 12) {\n        for (var i = 0; i < exports.ports; i++) {\n            input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n            (0, keyboardmenu_1.keyboardMenuControls)(i, input);\n        }\n    }\n    else if (exports.gameMode == 13) {\n        input[exports.creditsPlayer] = interpretInputs(exports.creditsPlayer, true, exports.playerType[exports.creditsPlayer], oldInputBuffers[exports.creditsPlayer]);\n        (0, credits_1.credits)(exports.creditsPlayer, input);\n    }\n    else if (exports.gameMode == 14) {\n        // controller calibration\n        input[exports.calibrationPlayer] = interpretInputs(exports.calibrationPlayer, true, exports.playerType[exports.calibrationPlayer], oldInputBuffers[exports.calibrationPlayer]);\n    }\n    else if (exports.gameMode == 15) {\n        for (var i = 0; i < exports.ports; i++) {\n            input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n            (0, menu_1.menuMove)(i, input);\n        }\n    }\n    else if (exports.gameMode == 2) {\n        for (var i = 0; i < 4; i++) {\n            if (i < exports.ports) {\n                input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n                (0, css_1.cssControls)(i, input);\n            }\n            actionStateShortcuts_1.actionStates[exports.characterSelections[i]][exports.player[i].actionState].main(i, input);\n        }\n        for (var i = 0; i < 4; i++) {\n            if (exports.playerType[i] > -1) {\n                (0, hitDetection_1.hitDetect)(i, input);\n            }\n        }\n        (0, hitDetection_1.executeHits)(input);\n        (0, hitDetection_1.resetHitQueue)();\n        findPlayers();\n    }\n    else if (exports.gameMode == 6) {\n        // stage select\n        for (var i = 0; i < 4; i++) {\n            if (i < exports.ports) {\n                input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n                (0, stageselect_1.sssControls)(i, input);\n            }\n        }\n    }\n    else if (exports.playing || exports.frameByFrame) {\n        //console.log(\"test0\");\n        /*delta = timestamp - lastFrameTimeMs; // get the delta time since last frame\n        lastFrameTimeMs = timestamp;\n        console.log(delta);*/\n        var now = performance.now();\n        var dt = now - lastUpdate;\n        //console.log(now);\n        //console.log(dt);\n        lastUpdate = now;\n        (0, hitDetection_1.resetHitQueue)();\n        (0, activeStage_1.getActiveStage)().movingPlatforms();\n        (0, article_1.destroyArticles)();\n        (0, article_1.executeArticles)();\n        for (var i = 0; i < 4; i++) {\n            if (exports.playerType[i] > -1) {\n                if (!exports.starting) {\n                    input[i] = interpretInputs(i, true, exports.playerType[i], oldInputBuffers[i]);\n                }\n                update(i, input);\n            }\n        }\n        (0, hitDetection_1.checkPhantoms)();\n        for (var i = 0; i < 4; i++) {\n            if (exports.playerType[i] > -1) {\n                (0, hitDetection_1.hitDetect)(i, input);\n            }\n        }\n        (0, hitDetection_1.executeHits)(input);\n        (0, article_1.articlesHitDetection)();\n        (0, article_1.executeArticleHits)(input);\n        if (!exports.starting && !exports.versusMode) {\n            matchTimerTick(input);\n        }\n        else {\n            exports.startTimer -= 0.01666667;\n            if (exports.startTimer < 0) {\n                exports.starting = false;\n            }\n        }\n        if (exports.frameByFrame) {\n            exports.frameByFrameRender = true;\n            exports.wasFrameByFrame = true;\n        }\n        exports.frameByFrame = false;\n        if (exports.showDebug) {\n            diff = performance.now() - start;\n            exports.gamelogicTime[0] += diff;\n            exports.gamelogicTime[0] /= 2;\n            if (diff >= 10) {\n                exports.gamelogicTime[3]++;\n            }\n            if (diff < exports.gamelogicTime[2]) {\n                exports.gamelogicTime[2] = diff;\n            }\n            if (diff > exports.gamelogicTime[1]) {\n                exports.gamelogicTime[1] = diff;\n            }\n            dom.gamelogicAvg.innerHTML = Math.round(exports.gamelogicTime[0]);\n            dom.gamelogicHigh.innerHTML = Math.round(exports.gamelogicTime[1]);\n            dom.gamelogicLow.innerHTML = Math.round(exports.gamelogicTime[2]);\n            dom.gamelogicPeak.innerHTML = exports.gamelogicTime[3];\n        }\n    }\n    else if (exports.findingPlayers) {\n        findPlayers();\n    }\n    else {\n        if (!exports.gameEnd) {\n            for (var i = 0; i < 4; i++) {\n                if (exports.playerType[i] == 0 || exports.playerType[i] == 2) {\n                    if (exports.currentPlayers[i] != -1) {\n                        input[i] = interpretInputs(i, false, exports.playerType[i], oldInputBuffers[i]);\n                    }\n                }\n            }\n        }\n    }\n    /*\n  \n    var beforeWaster = performance.now();\n    // neeed to waste 0.666ms\n    var timeWasted = false;\n    var t = 0;\n    var o = performance.now();\n    while(!timeWasted){\n      var n = performance.now();\n      t += n - o;\n      //console.log(t);\n      if (t > 0.6666){\n        timeWasted = true;\n      }\n      o = n;\n      //console.log(\".\");\n    }\n    //console.log(performance.now() - beforeWaster);*/\n    (0, replay_1.saveGameState)(input, exports.ports);\n    setTimeout(gameTick, 16, input);\n}\nfunction clearScreen() {\n    //bg1.fillStyle = \"rgb(0, 0, 0)\";\n    //bg1.fillRect(0,0,layers.BG1.width,layers.BG1.height);\n    exports.bg2.clearRect(0, 0, exports.layers.BG2.width, exports.layers.BG2.height);\n    //fg1.clearRect(0,0,layers.FG1.width,layers.FG1.height);\n    exports.fg2.clearRect(0, 0, exports.layers.FG2.width, exports.layers.FG2.height);\n    exports.ui.clearRect(0, 0, exports.layers.UI.width, exports.layers.UI.height);\n}\nlet otherFrame = true;\nlet fps30 = false;\nfunction renderTick() {\n    window.requestAnimationFrame(renderTick);\n    otherFrame ^= true;\n    if ((fps30 && otherFrame) || !fps30) {\n        //console.log(\"------\");\n        if (exports.gameMode == 20) {\n            (0, startup_1.drawStartUp)();\n        }\n        else if (exports.gameMode == 10) {\n            (0, audiomenu_1.drawAudioMenu)();\n        }\n        else if (exports.gameMode == 11) {\n            (0, gameplaymenu_1.drawGameplayMenu)();\n        }\n        else if (exports.gameMode == 12) {\n            (0, keyboardmenu_1.drawKeyboardMenu)();\n        }\n        else if (exports.gameMode == 13) {\n            (0, credits_1.drawCredits)();\n        }\n        else if (exports.gameMode == 14) {\n            (0, controllermenu_1.drawControllerMenu)();\n        }\n        else if (exports.gameMode == 0) {\n            (0, startscreen_1.drawStartScreen)();\n        }\n        else if (exports.gameMode == 1) {\n            (0, menu_1.drawMainMenu)();\n        }\n        else if (exports.gameMode == 2) {\n            (0, css_1.drawCSS)();\n            //renderVfx();\n        }\n        else if (exports.gameMode == 6) {\n            (0, stageselect_1.drawSSS)();\n        }\n        else if (exports.playing || exports.frameByFrameRender) {\n            /*delta = timestamp - lastFrameTimeMs; // get the delta time since last frame\n            lastFrameTimeMs = timestamp;\n            console.log(delta);*/\n            //console.log(\"test2\");\n            var rStart = performance.now();\n            clearScreen();\n            if ((0, vfx_1.isShowSFX)()) {\n                (0, stagerender_1.drawBackground)();\n            }\n            (0, stagerender_1.drawStage)();\n            for (var i = 0; i < 4; i++) {\n                if (exports.playerType[i] > -1) {\n                    (0, render_1.renderPlayer)(i);\n                }\n            }\n            (0, article_1.renderArticles)();\n            (0, renderVfx_1.renderVfx)();\n            (0, render_1.renderOverlay)(true);\n            if (exports.showDebug) {\n                var diff = performance.now() - rStart;\n                exports.renderTime[0] += diff;\n                exports.renderTime[0] /= 2;\n                if (diff >= 10) {\n                    exports.renderTime[3]++;\n                }\n                if (diff > exports.renderTime[1]) {\n                    exports.renderTime[1] = diff;\n                }\n                if (diff < exports.renderTime[2]) {\n                    exports.renderTime[2] = diff;\n                }\n                dom.renderAvg.innerHTML = Math.round(exports.renderTime[0]);\n                dom.renderHigh.innerHTML = Math.round(exports.renderTime[1]);\n                dom.renderLow.innerHTML = Math.round(exports.renderTime[2]);\n                dom.renderPeak.innerHTML = exports.renderTime[3];\n            }\n        }\n        if (exports.frameByFrameRender) {\n            (0, render_1.renderForeground)();\n        }\n        exports.frameByFrameRender = false;\n        //renderToMain();\n        //console.log(performance.now());\n    }\n    else {\n        if (exports.playing) {\n            (0, renderVfx_1.renderVfx)(true);\n        }\n    }\n}\nfunction buildPlayerObject(i) {\n    exports.player[i] = new player_1.playerObject(exports.characterSelections[i], exports.startingPoint[i], exports.startingFace[i]);\n    exports.player[i].phys.ECB1 = [new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y), new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y), new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y), new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y)];\n    exports.player[i].phys.ECBp = [new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y), new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y), new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y), new Vec2D_1.Vec2D(exports.startingPoint[i].x, exports.startingPoint[i].y)];\n    exports.player[i].difficulty = exports.cpuDifficulty[i];\n}\nfunction initializePlayers(i, target) {\n    buildPlayerObject(i);\n    if (target) {\n        (0, drawVfx_1.drawVfx)({\n            name: \"entrance\",\n            pos: new Vec2D_1.Vec2D(activeStage_1.activeStage.startingPoint[0].x, activeStage_1.activeStage.startingPoint[0].y)\n        });\n    }\n    else {\n        (0, drawVfx_1.drawVfx)({\n            name: \"entrance\",\n            pos: new Vec2D_1.Vec2D(exports.startingPoint[i][0], exports.startingPoint[i][1])\n        });\n    }\n}\nfunction startGame() {\n    (0, activeStage_1.setVsStage)(exports.stageSelect);\n    (0, stagerender_1.setBackgroundType)(Math.round(Math.random()));\n    changeGamemode(3);\n    (0, vfxQueue_1.resetVfxQueue)();\n    for (var n = 0; n < 4; n++) {\n        if (exports.playerType[n] > -1) {\n            initializePlayers(n, false);\n            (0, render_1.renderPlayer)(n);\n            exports.player[n].inCSS = false;\n        }\n        if (exports.versusMode) {\n            exports.player[n].stocks = 1;\n        }\n    }\n    exports.matchTimer = 480;\n    exports.startTimer = 1.5;\n    exports.starting = true;\n    music_1.MusicManager.stopWhatisPlaying();\n    switch (exports.stageSelect) {\n        case 0:\n            music_1.MusicManager.playBattleFieldLoop();\n            break;\n        case 1:\n            music_1.MusicManager.playyStoryLoop();\n            break;\n        case 2:\n            music_1.MusicManager.playpStadiumLoop();\n            break;\n        case 3:\n            music_1.MusicManager.playDreamLandLoop();\n            break;\n        case 4:\n            music_1.MusicManager.playfinaldLoop();\n            break;\n        case 5:\n            music_1.MusicManager.playfodLoop();\n            break;\n        default:\n            break;\n    }\n    (0, drawVfx_1.drawVfx)({\n        name: \"start\",\n        pos: new Vec2D_1.Vec2D(0, 0)\n    });\n    exports.findingPlayers = false;\n    exports.playing = true;\n}\nfunction endGame(input) {\n    exports.gameEnd = false;\n    (0, render_1.resetLostStockQueue)();\n    (0, hitDetection_1.setPhantonQueue)([]);\n    (0, article_1.resetAArticles)();\n    music_1.MusicManager.stopWhatisPlaying();\n    changeVolume(music_1.MusicManager, audiomenu_1.masterVolume[1], 1);\n    exports.playing = false;\n    clearScreen();\n    (0, stagerender_1.drawStage)();\n    (0, css_2.setTokenPosSnapToChar)(0);\n    (0, css_2.setTokenPosSnapToChar)(1);\n    (0, css_2.setTokenPosSnapToChar)(2);\n    (0, css_2.setTokenPosSnapToChar)(3);\n    if (exports.gameMode == 3) {\n        changeGamemode(2);\n        music_1.MusicManager.playMenuLoop();\n        exports.pause = [[true, true], [true, true], [true, true], [true, true]];\n        exports.frameAdvance = [\n            [true, true],\n            [true, true],\n            [true, true],\n            [true, true]\n        ];\n        exports.findingPlayers = true;\n        positionPlayersInCSS();\n        for (var i = 0; i < 4; i++) {\n            if (exports.playerType[i] > -1) {\n                if (exports.player[i].actionState == \"FURAFURA\") {\n                    sfx_1.sounds.furaloop.stop(exports.player[i].furaLoopID);\n                }\n                //input[i][0].a = true; // do\n                //input[i][1].a = true; // not\n                exports.player[i].inCSS = true;\n                exports.player[i].phys.face = 1;\n                exports.player[i].actionState = \"WAIT\";\n                exports.player[i].timer = 0;\n            }\n        }\n    }\n}\nfunction finishGame(input) {\n    exports.gameEnd = true;\n    exports.playing = false;\n    exports.fg2.save();\n    exports.fg2.textAlign = \"center\";\n    var text = \"Game!\";\n    var size = 300;\n    var textScale = 1;\n    var textGrad = exports.fg2.createLinearGradient(0, 200, 0, 520);\n    if (exports.matchTimer <= 0) {\n        text = \"Time!\";\n        sfx_1.sounds.time.play();\n        textGrad.addColorStop(0, \"black\");\n        textGrad.addColorStop(0.5, \"black\");\n        textGrad.addColorStop(0.7, \"rgb(21, 51, 180)\");\n        textGrad.addColorStop(1, \"rgb(71, 94, 250)\");\n    }\n    else {\n        sfx_1.sounds.game.play();\n        textGrad.addColorStop(0, \"black\");\n        textGrad.addColorStop(0.4, \"black\");\n        textGrad.addColorStop(0.7, \"rgb(167, 27, 40)\");\n        textGrad.addColorStop(1, \"rgb(255, 31, 52)\");\n    }\n    exports.fg2.scale(1, textScale);\n    exports.fg2.fillStyle = textGrad;\n    exports.fg2.lineWidth = 40;\n    exports.fg2.strokeStyle = \"black\";\n    exports.fg2.font = \"900 \" + size + \"px Arial\";\n    exports.fg2.strokeText(text, 600, 470 / textScale);\n    exports.fg2.lineWidth = 20;\n    exports.fg2.strokeStyle = \"white\";\n    exports.fg2.font = \"900 \" + size + \"px Arial\";\n    exports.fg2.strokeText(text, 600, 470 / textScale);\n    exports.fg2.font = \"900 \" + size + \"px Arial\";\n    exports.fg2.fillText(text, 600, 470 / textScale);\n    exports.fg2.restore();\n    music_1.MusicManager.stopWhatisPlaying();\n    setTimeout(function () {\n        endGame(input);\n    }, 2500);\n}\nfunction onFullScreenChange() {\n    var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;\n    // if in fullscreen mode fullscreenElement won't be null\n    var cont = document.getElementById(\"topButtonContainer\");\n    var icn = document.querySelectorAll(\".topButton\");\n    if (fullscreenElement != null) {\n        cont.style.transition = \"opacity 0.5s linear 0s\";\n        cont.style.opacity = 0;\n        ;\n        setTimeout(function () {\n            var i;\n            for (i = 0; i < icn.length; i++) {\n                icn[i].style.height = \"5px\";\n            }\n            cont.style.height = \"5px\";\n            resize();\n        }, 500);\n        (0, jquery_1.default)(\"#keyboardPrompt\").hide();\n        (0, jquery_1.default)(\"#keyboardControlsImg\").hide();\n        (0, jquery_1.default)(\"#controllerSupportContainer\").hide();\n        (0, jquery_1.default)(\"#debugButtonEdit\").empty().append(\"OFF\");\n        (0, jquery_1.default)(\"#debug\").hide();\n        (0, jquery_1.default)(\"#players\").hide();\n        (0, jquery_1.default)(\"body\").css(\"overflow\", \"hidden\");\n        showHeader = false;\n    }\n    else {\n        var i;\n        for (i = 0; i < icn.length; i++) {\n            icn[i].style.height = \"25px\";\n        }\n        cont.style.height = \"31px\";\n        cont.style.transition = \"opacity 0.5s linear 0s\";\n        cont.style.opacity = 1;\n    }\n}\nfunction start() {\n    if (exports.holiday === 1) {\n        (0, jquery_1.default)(\"#layerButton\").after('<div id=\"snowButton\" class=\"gameButton\" style=\"width:90px\"><img src=\"assets/christmas/snowflake.png\" height=17 width=17 style=\"display:inline-block\"/><p style=\"width:30px;display:inline-block\"><span id=\"snowButtonEdit\">150</span></p><div id=\"snowMinus\" class=\"snowControl\" style=\"display:inline-block;padding:3px\"><p style=\"padding:0;font-size:20px\">-</p></div><div id=\"snowPlus\" style=\"display:inline-block;padding:3px\"><p style=\"padding:0;font-size:17px\">+</p></div></div>');\n    }\n    for (var i = 0; i < 4; i++) {\n        buildPlayerObject(i);\n        exports.player[i].phys.face = 1;\n        exports.player[i].actionState = \"WAIT\";\n    }\n    cacheDom();\n    (0, keyboardmenu_1.getKeyboardCookie)();\n    giveMedals();\n    (0, audiomenu_1.getAudioCookies)();\n    (0, gameplaymenu_1.getGameplayCookies)();\n    (0, jquery_1.default)(\"#keyboardButton\").click(function () {\n        (0, jquery_1.default)(\"#keyboardControlsImg\").toggle();\n        (0, jquery_1.default)(\"#keyboardPrompt\").hide();\n    });\n    (0, jquery_1.default)(\"#controllerButton\").click(function () {\n        (0, jquery_1.default)(\"#controllerSupportContainer\").toggle();\n    });\n    exports.layers.BG1 = document.getElementById(\"background1Canvas\");\n    exports.bg1 = exports.layers.BG1.getContext(\"2d\");\n    exports.layers.BG2 = document.getElementById(\"background2Canvas\");\n    exports.bg2 = exports.layers.BG2.getContext(\"2d\");\n    exports.layers.FG1 = document.getElementById(\"foreground1Canvas\");\n    exports.fg1 = exports.layers.FG1.getContext(\"2d\");\n    exports.layers.FG2 = document.getElementById(\"foreground2Canvas\");\n    exports.fg2 = exports.layers.FG2.getContext(\"2d\");\n    exports.layers.UI = document.getElementById(\"uiCanvas\");\n    exports.ui = exports.layers.UI.getContext(\"2d\");\n    exports.bg1.fillStyle = \"rgb(0, 0, 0)\";\n    exports.bg1.fillRect(0, 0, exports.layers.BG1.width, exports.layers.BG1.height);\n    let nullInputBuffers = [(0, input_1.nullInputs)(), (0, input_1.nullInputs)(), (0, input_1.nullInputs)(), (0, input_1.nullInputs)()];\n    gameTick(nullInputBuffers);\n    renderTick();\n    (0, jquery_1.default)(\"#effectsButton\").click(function () {\n        if ((0, vfx_1.isShowSFX)()) {\n            (0, jquery_1.default)(\"#effectsButtonEdit\").empty().append(\"OFF\");\n        }\n        else {\n            (0, jquery_1.default)(\"#effectsButtonEdit\").empty().append(\"ON\");\n        }\n        (0, vfx_1.toggleShowSFX)();\n    });\n    (0, jquery_1.default)(\"#fpsButton\").click(function () {\n        if (fps30) {\n            (0, jquery_1.default)(\"#fpsButtonEdit\").empty().append(\"60\");\n        }\n        else {\n            (0, jquery_1.default)(\"#fpsButtonEdit\").empty().append(\"30\");\n        }\n        fps30 ^= true;\n    });\n    (0, jquery_1.default)(\"#alphaButton\").click(function () {\n        if ((0, transparency_1.getTransparency)()) {\n            (0, jquery_1.default)(\"#alphaButtonEdit\").empty().append(\"OFF\");\n        }\n        else {\n            (0, jquery_1.default)(\"#alphaButtonEdit\").empty().append(\"ON\");\n        }\n        (0, transparency_1.toggleTransparency)();\n    });\n    (0, jquery_1.default)(\"#layerButton\").hover(function () {\n        (0, jquery_1.default)(\"#layerDropdown\").toggle();\n    });\n    (0, jquery_1.default)(\".layer\").click(function () {\n        var id = (0, jquery_1.default)(this).attr(\"id\");\n        switch (id) {\n            case \"layer1\":\n                exports.layerSwitches.BG1 ^= true;\n                (0, jquery_1.default)(\"#background1Canvas\").toggle();\n                break;\n            case \"layer2\":\n                exports.layerSwitches.BG2 ^= true;\n                (0, jquery_1.default)(\"#background2Canvas\").toggle();\n                break;\n            case \"layer3\":\n                exports.layerSwitches.FG1 ^= true;\n                (0, jquery_1.default)(\"#foreground1Canvas\").toggle();\n                break;\n            case \"layer4\":\n                exports.layerSwitches.FG2 ^= true;\n                (0, jquery_1.default)(\"#foreground2Canvas\").toggle();\n                break;\n            case \"layer5\":\n                exports.layerSwitches.UI ^= true;\n                (0, jquery_1.default)(\"#uiCanvas\").toggle();\n                break;\n            default:\n                break;\n        }\n        (0, jquery_1.default)(this).toggleClass(\"layerOn\");\n    });\n    (0, jquery_1.default)(\"#debugButton\").click(function () {\n        if (exports.showDebug) {\n            for (let i = 0; i < 4; i++) {\n                document.getElementById(\"gamepadSVG\" + i).style.display = \"none\";\n            }\n            (0, jquery_1.default)(\"#debugButtonEdit\").empty().append(\"OFF\");\n            (0, jquery_1.default)(\"#debug\").hide();\n            (0, jquery_1.default)(\"#players\").hide();\n            (0, jquery_1.default)(\"body\").css(\"overflow\", \"hidden\");\n            //var mY = Math.max(($(window).height()-750)/2,0);\n            //$(\"#display\").css(\"margin\",mY+\"px 0px 0px \"+mX+\"px\");\n        }\n        else {\n            for (let i = 0; i < 4; i++) {\n                if (exports.playerType[i] !== -1) {\n                    (0, drawGamepad_1.updateGamepadSVGColour)(i, \"gamepadSVG\" + i);\n                    document.getElementById(\"gamepadSVG\" + i).style.display = \"\";\n                }\n            }\n            (0, jquery_1.default)(\"#debugButtonEdit\").empty().append(\"ON\");\n            (0, jquery_1.default)(\"#debug\").show();\n            (0, jquery_1.default)(\"#players\").show();\n            (0, jquery_1.default)(\"body\").css(\"overflow\", \"scroll\");\n            //var mY = Math.max(($(window).height()-900)/2,0);\n            //$(\"#display\").css(\"margin\",mY+\" 0px 0px px \"+mX+\"px\");\n        }\n        exports.showDebug ^= true;\n        resize();\n    });\n    (0, jquery_1.default)(\"#hideButton\").click(function () {\n        (0, jquery_1.default)(\"#header\").toggle();\n        showHeader ^= true;\n        resize();\n    });\n    (0, jquery_1.default)(\"#fullscreenButton\").click(function () {\n        if ((document.fullScreenElement && document.fullScreenElement !== null) || (!document.mozFullScreen && !document.webkitIsFullScreen)) {\n            if (document.documentElement.requestFullScreen) {\n                document.documentElement.requestFullScreen();\n            }\n            else if (document.documentElement.mozRequestFullScreen) {\n                document.documentElement.mozRequestFullScreen();\n            }\n            else if (document.documentElement.webkitRequestFullScreen) {\n                document.documentElement.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);\n            }\n        }\n        else {\n            if (document.cancelFullScreen) {\n                document.cancelFullScreen();\n            }\n            else if (document.mozCancelFullScreen) {\n                document.mozCancelFullScreen();\n            }\n            else if (document.webkitCancelFullScreen) {\n                document.webkitCancelFullScreen();\n            }\n        }\n        // resize();\n    });\n    document.addEventListener(\"fullscreenchange\", onFullScreenChange, false);\n    document.addEventListener(\"webkitfullscreenchange\", onFullScreenChange, false);\n    document.addEventListener(\"mozfullscreenchange\", onFullScreenChange, false);\n    (0, jquery_1.default)(\".topButton\").hover(function () {\n        (0, jquery_1.default)(this).children(\".buttonDetails\").toggle();\n    });\n    if (mobile === false) {\n        (0, jquery_1.default)(\".button\").hover(function () {\n            (0, jquery_1.default)(this).toggleClass(\"buttonhighlighted\");\n        });\n        (0, jquery_1.default)(\".socialmedia\").hover(function () {\n            (0, jquery_1.default)(this).toggleClass(\"socialmediahighlight\");\n        });\n        (0, jquery_1.default)(\".sugbtn\").hover(function () {\n            (0, jquery_1.default)(this).toggleClass(\"sugbtnhighlight\");\n        });\n    }\n    (0, jquery_1.default)(\"#appsButton\").hover(function () {\n        (0, jquery_1.default)(\"#appsDropdown\").show();\n    }, function () {\n        (0, jquery_1.default)(\"#appsDropdown\").hide();\n    });\n    if (exports.holiday === 1) {\n        (0, jquery_1.default)(\"#snowMinus\").click(function () {\n            exports.snowCount -= 20;\n            if (exports.snowCount < 0) {\n                exports.snowCount = 0;\n            }\n            (0, jquery_1.default)(\"#snowButtonEdit\").text(exports.snowCount);\n        });\n        (0, jquery_1.default)(\"#snowPlus\").click(function () {\n            exports.snowCount += 20;\n            if (exports.snowCount > 1200) {\n                exports.snowCount = 1200;\n            }\n            (0, jquery_1.default)(\"#snowButtonEdit\").text(exports.snowCount);\n        });\n    }\n    (0, jquery_1.default)(\"#replay\").change(function () {\n        // grab the first image in the FileList object and pass it to the function\n        (0, replay_1.loadReplay)(this.files[0]);\n    });\n    resize();\n}\nwindow.start = start;\nfunction customDeadzone() {\n    this.ls = new Vec2D_1.Vec2D(0, 0);\n    this.cs = new Vec2D_1.Vec2D(0, 0);\n    this.l = 0;\n    this.r = 0;\n}\nfunction addShine(val) {\n    exports.shine += val;\n}\nfunction setShine(val) {\n    exports.shine = val;\n}\nfunction setFindingPlayers(val) {\n    exports.findingPlayers = val;\n}\nfunction setPlaying(val) {\n    exports.playing = val;\n}\nfunction setCreditsPlayer(val) {\n    exports.creditsPlayer = val;\n}\nfunction setCalibrationPlayer(val) {\n    exports.calibrationPlayer = val;\n}\nconst dom = {};\nfunction cacheDom() {\n    const elementIds = [\n        \"matchMinutes\",\n        \"matchSeconds\",\n        \"gamelogicAvg\",\n        \"gamelogicHigh\",\n        \"gamelogicLow\",\n        \"gamelogicPeak\",\n        \"renderAvg\",\n        \"renderHigh\",\n        \"renderLow\",\n        \"renderPeak\",\n    ];\n    elementIds.forEach((id) => {\n        dom[id] = document.getElementById(id);\n    });\n}\n;\nfunction setCS(index, val) {\n    exports.characterSelections[index] = val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi9tYWluLnRzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsc0JBQXNCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxhQUFhLEdBQUcseUJBQXlCLEdBQUcsMkJBQTJCLEdBQUcsaUNBQWlDLEdBQUcsZUFBZSxHQUFHLHlCQUF5QixHQUFHLHFCQUFxQixHQUFHLGFBQWEsR0FBRywyQkFBMkIsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsZUFBZTtBQUNsakMscUJBQXFCLEdBQUcsY0FBYyxHQUFHLGtCQUFrQixHQUFHLFNBQVMsR0FBRyxVQUFVLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcseUJBQXlCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQzNSLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsZ0JBQWdCO0FBQ2hCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQix5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx3Q0FBYztBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyw0Q0FBZ0I7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsc0NBQWE7QUFDeEMsa0JBQWtCLG1CQUFPLENBQUMsZ0RBQWtCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywwQ0FBZTtBQUN0QyxjQUFjLG1CQUFPLENBQUMsc0NBQWE7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsd0RBQXNCO0FBQ3BELHNCQUFzQixtQkFBTyxDQUFDLDBEQUF1QjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyx3REFBc0I7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsb0RBQW9CO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLDBEQUF1QjtBQUN0RCx1QkFBdUIsbUJBQU8sQ0FBQywwREFBdUI7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsOERBQXlCO0FBQzFELGtCQUFrQixtQkFBTyxDQUFDLGdEQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyw0Q0FBZ0I7QUFDekMsK0JBQStCLG1CQUFPLENBQUMsOEVBQWlDO0FBQ3hFLHVCQUF1QixtQkFBTyxDQUFDLDhEQUF5QjtBQUN4RCxrQkFBa0IsbUJBQU8sQ0FBQyxvREFBb0I7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLG9DQUFZO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLG9EQUFvQjtBQUM5QyxpQ0FBaUMsbUJBQU8sQ0FBQyxvREFBUTtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQyxnRUFBMEI7QUFDekQsa0JBQWtCLG1CQUFPLENBQUMsc0RBQXFCO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLHdEQUFzQjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQywwREFBdUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsb0NBQVM7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHNDQUFhO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLG9EQUFpQjtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4Q0FBYztBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4Q0FBYztBQUN0Qyx1QkFBdUIsbUJBQU8sQ0FBQywwRUFBNEI7QUFDM0QsaUJBQWlCLG1CQUFPLENBQUMsc0NBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsNENBQWdCO0FBQ3hDLHNCQUFzQixtQkFBTyxDQUFDLHdEQUFzQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxnRkFBa0M7QUFDcEUsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWtDO0FBQzNELGdDQUFnQyxtQkFBTyxDQUFDLDRGQUF3QztBQUNoRixzQkFBc0IsbUJBQU8sQ0FBQyx3RUFBOEI7QUFDNUQseUJBQXlCLG1CQUFPLENBQUMsZ0VBQXVCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyx3Q0FBYztBQUNwQztBQUNBLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGVBQWU7QUFDZixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHNCQUFzQjtBQUN0QixlQUFlO0FBQ2YsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2I7QUFDQSxrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxJQUFJLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0VBQW9FO0FBQ2pHLDZCQUE2QixtRUFBbUUsa0VBQWtFO0FBQ2xLLDZCQUE2QixrRUFBa0U7QUFDL0YsNkJBQTZCLGtFQUFrRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkdBQTJHO0FBQ3hJLDZCQUE2QiwyR0FBMkc7QUFDeEksNkJBQTZCLDZHQUE2RztBQUMxSSw2QkFBNkIsMkRBQTJEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySkFBMko7QUFDM0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZJQUE2STtBQUM3STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QjtBQUMzQjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1gsVUFBVTtBQUNWLFNBQVM7QUFDVCxrQkFBa0I7QUFDbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0EsUUFBUSxvQkFBb0I7QUFDNUI7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxrQkFBa0I7QUFDdEIsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHNCQUFzQjtBQUMxQixJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQixRQUFRLG9CQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CLElBQUksZUFBZTtBQUNuQjtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QixJQUFJLHFCQUFxQjtBQUN6QixJQUFJLHVCQUF1QjtBQUMzQixJQUFJLGdCQUFnQjtBQUNwQjtBQUNBLElBQUkscUJBQXFCO0FBQ3pCLElBQUksdUJBQXVCO0FBQzNCLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdPQUFnTyxrSUFBa0ksaUNBQWlDLDBFQUEwRSxpQ0FBaUM7QUFDOWU7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGtCQUFrQjtBQUN0QixJQUFJLFdBQVc7QUFDZixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLFdBQVc7QUFDZixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLFdBQVc7QUFDZixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLFdBQVc7QUFDZixJQUFJLGlCQUFpQjtBQUNyQixJQUFJLFVBQVU7QUFDZCxJQUFJLHFCQUFxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJLGFBQWE7QUFDakI7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWxlZWxpZ2h0Ly4vc3JjL21haW4vbWFpbi50cz8xM2UzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ibGFzdHpvbmUgPSBleHBvcnRzLnN0YWdlU2VsZWN0ID0gZXhwb3J0cy5yZXNwYXduUG9pbnRzID0gZXhwb3J0cy5lZGdlT3JpZW50YXRpb24gPSBleHBvcnRzLmVkZ2VPZmZzZXQgPSBleHBvcnRzLmVkZ2VzID0gZXhwb3J0cy53YWxsc1IgPSBleHBvcnRzLndhbGxzTCA9IGV4cG9ydHMucGxhdGZvcm1zID0gZXhwb3J0cy5ncm91bmQgPSBleHBvcnRzLnN0YXJ0aW5nRmFjZSA9IGV4cG9ydHMuc3RhcnRpbmdQb2ludCA9IGV4cG9ydHMuZnJhbWVBZHZhbmNlID0gZXhwb3J0cy5wYXVzZSA9IGV4cG9ydHMuY29sb3VycyA9IGV4cG9ydHMuY29zdHVtZVRpbWVvdXQgPSBleHBvcnRzLnBQYWwgPSBleHBvcnRzLnRhZ1RleHQgPSBleHBvcnRzLmhhc1RhZyA9IGV4cG9ydHMucGFsZXR0ZXMgPSBleHBvcnRzLnJhbmRvbVRhZ3MgPSBleHBvcnRzLnZlcnN1c01vZGUgPSBleHBvcnRzLmdhbWVNb2RlID0gZXhwb3J0cy5zaG93RGVidWcgPSBleHBvcnRzLmZpbmRpbmdQbGF5ZXJzID0gZXhwb3J0cy5mcmFtZUJ5RnJhbWVSZW5kZXIgPSBleHBvcnRzLndhc0ZyYW1lQnlGcmFtZSA9IGV4cG9ydHMuZnJhbWVCeUZyYW1lID0gZXhwb3J0cy5wbGF5aW5nID0gZXhwb3J0cy5hY3RpdmVQb3J0cyA9IGV4cG9ydHMucG9ydHMgPSBleHBvcnRzLmNwdURpZmZpY3VsdHkgPSBleHBvcnRzLnBsYXllclR5cGUgPSBleHBvcnRzLnBsYXllckFtb3VudCA9IGV4cG9ydHMuY3VycmVudFBsYXllcnMgPSBleHBvcnRzLm1UeXBlID0gZXhwb3J0cy5maXJzdFRpbWVEZXRlY3RlZCA9IGV4cG9ydHMudXNpbmdDdXN0b21Db250cm9scyA9IGV4cG9ydHMuY29udHJvbGxlclJlc2V0Q291bnRkb3ducyA9IGV4cG9ydHMuZ2FtZUVuZCA9IGV4cG9ydHMuY2FsaWJyYXRpb25QbGF5ZXIgPSBleHBvcnRzLmNyZWRpdHNQbGF5ZXIgPSBleHBvcnRzLnNoaW5lID0gZXhwb3J0cy5jaGFyYWN0ZXJTZWxlY3Rpb25zID0gZXhwb3J0cy5mcmFtZXJhdGUgPSBleHBvcnRzLmdhbWVsb2dpY1RpbWUgPSBleHBvcnRzLnJlbmRlclRpbWUgPSBleHBvcnRzLnBsYXllciA9IGV4cG9ydHMuc25vd0NvdW50ID0gZXhwb3J0cy5ob2xpZGF5ID0gdm9pZCAwO1xuZXhwb3J0cy5sYXllclN3aXRjaGVzID0gZXhwb3J0cy5sYXllcnMgPSBleHBvcnRzLmNhbnZhc01haW4gPSBleHBvcnRzLmMgPSBleHBvcnRzLnVpID0gZXhwb3J0cy5mZzIgPSBleHBvcnRzLmZnMSA9IGV4cG9ydHMuYmcyID0gZXhwb3J0cy5iZzEgPSBleHBvcnRzLmtleUJpbmRpbmcgPSBleHBvcnRzLmtleUJpbmQgPSBleHBvcnRzLmtleXMgPSBleHBvcnRzLnVzaW5nTG9jYWxTdG9yYWdlID0gZXhwb3J0cy5tYXRjaFRpbWVyID0gZXhwb3J0cy5zdGFydFRpbWVyID0gZXhwb3J0cy5zdGFydGluZyA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0Q29udHJvbGxlclJlc2V0ID0gc2V0Q29udHJvbGxlclJlc2V0O1xuZXhwb3J0cy5zZXRVc2luZ0N1c3RvbUNvbnRyb2xzID0gc2V0VXNpbmdDdXN0b21Db250cm9scztcbmV4cG9ydHMuc2V0TXR5cGUgPSBzZXRNdHlwZTtcbmV4cG9ydHMuc2V0Q3VycmVudFBsYXllciA9IHNldEN1cnJlbnRQbGF5ZXI7XG5leHBvcnRzLnNldFRhZ1RleHQgPSBzZXRUYWdUZXh0O1xuZXhwb3J0cy5zZXRTdGFnZVNlbGVjdCA9IHNldFN0YWdlU2VsZWN0O1xuZXhwb3J0cy5zZXRTdGFydGluZyA9IHNldFN0YXJ0aW5nO1xuZXhwb3J0cy5zZXRTdGFydFRpbWVyID0gc2V0U3RhcnRUaW1lcjtcbmV4cG9ydHMuZ2V0U3RhcnRUaW1lciA9IGdldFN0YXJ0VGltZXI7XG5leHBvcnRzLmFkZE1hdGNoVGltZXIgPSBhZGRNYXRjaFRpbWVyO1xuZXhwb3J0cy5zZXRNYXRjaFRpbWVyID0gc2V0TWF0Y2hUaW1lcjtcbmV4cG9ydHMuZ2V0TWF0Y2hUaW1lciA9IGdldE1hdGNoVGltZXI7XG5leHBvcnRzLnNldENvb2tpZSA9IHNldENvb2tpZTtcbmV4cG9ydHMuc2V0VmVyc3VzTW9kZSA9IHNldFZlcnN1c01vZGU7XG5leHBvcnRzLmdldENvb2tpZSA9IGdldENvb2tpZTtcbmV4cG9ydHMuc2V0S2V5QmluZGluZyA9IHNldEtleUJpbmRpbmc7XG5leHBvcnRzLm92ZXJyaWRlS2V5Ym9hcmRFdmVudCA9IG92ZXJyaWRlS2V5Ym9hcmRFdmVudDtcbmV4cG9ydHMuZGlzYWJsZWRFdmVudFByb3BhZ2F0aW9uID0gZGlzYWJsZWRFdmVudFByb3BhZ2F0aW9uO1xuZXhwb3J0cy5TVkcgPSBTVkc7XG5leHBvcnRzLm1hdGNoVGltZXJUaWNrID0gbWF0Y2hUaW1lclRpY2s7XG5leHBvcnRzLnNjcmVlblNoYWtlID0gc2NyZWVuU2hha2U7XG5leHBvcnRzLnBlcmNlbnRTaGFrZSA9IHBlcmNlbnRTaGFrZTtcbmV4cG9ydHMuZmluZFBsYXllcnMgPSBmaW5kUGxheWVycztcbmV4cG9ydHMuc2V0UGxheWVyVHlwZSA9IHNldFBsYXllclR5cGU7XG5leHBvcnRzLmFkZFBsYXllciA9IGFkZFBsYXllcjtcbmV4cG9ydHMudG9nZ2xlUG9ydCA9IHRvZ2dsZVBvcnQ7XG5leHBvcnRzLnBvc2l0aW9uUGxheWVyc0luQ1NTID0gcG9zaXRpb25QbGF5ZXJzSW5DU1M7XG5leHBvcnRzLmNoYW5nZUdhbWVtb2RlID0gY2hhbmdlR2FtZW1vZGU7XG5leHBvcnRzLmludGVycHJldElucHV0cyA9IGludGVycHJldElucHV0cztcbmV4cG9ydHMucmVuZGVyVG9NYWluID0gcmVuZGVyVG9NYWluO1xuZXhwb3J0cy51cGRhdGUgPSB1cGRhdGU7XG5leHBvcnRzLmdhbWVUaWNrID0gZ2FtZVRpY2s7XG5leHBvcnRzLmNsZWFyU2NyZWVuID0gY2xlYXJTY3JlZW47XG5leHBvcnRzLnJlbmRlclRpY2sgPSByZW5kZXJUaWNrO1xuZXhwb3J0cy5idWlsZFBsYXllck9iamVjdCA9IGJ1aWxkUGxheWVyT2JqZWN0O1xuZXhwb3J0cy5pbml0aWFsaXplUGxheWVycyA9IGluaXRpYWxpemVQbGF5ZXJzO1xuZXhwb3J0cy5zdGFydEdhbWUgPSBzdGFydEdhbWU7XG5leHBvcnRzLmVuZEdhbWUgPSBlbmRHYW1lO1xuZXhwb3J0cy5maW5pc2hHYW1lID0gZmluaXNoR2FtZTtcbmV4cG9ydHMuc3RhcnQgPSBzdGFydDtcbmV4cG9ydHMuY3VzdG9tRGVhZHpvbmUgPSBjdXN0b21EZWFkem9uZTtcbmV4cG9ydHMuYWRkU2hpbmUgPSBhZGRTaGluZTtcbmV4cG9ydHMuc2V0U2hpbmUgPSBzZXRTaGluZTtcbmV4cG9ydHMuc2V0RmluZGluZ1BsYXllcnMgPSBzZXRGaW5kaW5nUGxheWVycztcbmV4cG9ydHMuc2V0UGxheWluZyA9IHNldFBsYXlpbmc7XG5leHBvcnRzLnNldENyZWRpdHNQbGF5ZXIgPSBzZXRDcmVkaXRzUGxheWVyO1xuZXhwb3J0cy5zZXRDYWxpYnJhdGlvblBsYXllciA9IHNldENhbGlicmF0aW9uUGxheWVyO1xuZXhwb3J0cy5jYWNoZURvbSA9IGNhY2hlRG9tO1xuZXhwb3J0cy5zZXRDUyA9IHNldENTO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGNzc18xID0gcmVxdWlyZShcIi4uL21lbnVzL2Nzc1wiKTtcbmNvbnN0IHBsYXllcl8xID0gcmVxdWlyZShcIi4uL21haW4vcGxheWVyXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9zZXR0aW5nc1wiKTtcbmNvbnN0IHN0YXJ0dXBfMSA9IHJlcXVpcmUoXCIuLi9tZW51cy9zdGFydHVwXCIpO1xuY29uc3QgbWVudV8xID0gcmVxdWlyZShcIi4uL21lbnVzL21lbnVcIik7XG5jb25zdCBzZnhfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3NmeFwiKTtcbmNvbnN0IHN0YXJ0c2NyZWVuXzEgPSByZXF1aXJlKFwiLi4vbWVudXMvc3RhcnRzY3JlZW5cIik7XG5jb25zdCBzdGFnZXJlbmRlcl8xID0gcmVxdWlyZShcIi4uL3N0YWdlcy9zdGFnZXJlbmRlclwiKTtcbmNvbnN0IHN0YWdlc2VsZWN0XzEgPSByZXF1aXJlKFwiLi4vbWVudXMvc3RhZ2VzZWxlY3RcIik7XG5jb25zdCBhdWRpb21lbnVfMSA9IHJlcXVpcmUoXCIuLi9tZW51cy9hdWRpb21lbnVcIik7XG5jb25zdCBnYW1lcGxheW1lbnVfMSA9IHJlcXVpcmUoXCIuLi9tZW51cy9nYW1lcGxheW1lbnVcIik7XG5jb25zdCBrZXlib2FyZG1lbnVfMSA9IHJlcXVpcmUoXCIuLi9tZW51cy9rZXlib2FyZG1lbnVcIik7XG5jb25zdCBjb250cm9sbGVybWVudV8xID0gcmVxdWlyZShcIi4uL21lbnVzL2NvbnRyb2xsZXJtZW51XCIpO1xuY29uc3QgY3JlZGl0c18xID0gcmVxdWlyZShcIi4uL21lbnVzL2NyZWRpdHNcIik7XG5jb25zdCByZW5kZXJfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3JlbmRlclwiKTtcbmNvbnN0IGFjdGlvblN0YXRlU2hvcnRjdXRzXzEgPSByZXF1aXJlKFwiLi4vcGh5c2ljcy9hY3Rpb25TdGF0ZVNob3J0Y3V0c1wiKTtcbmNvbnN0IGhpdERldGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3BoeXNpY3MvaGl0RGV0ZWN0aW9uXCIpO1xuY29uc3QgYXJ0aWNsZV8xID0gcmVxdWlyZShcIi4uL3BoeXNpY3MvYXJ0aWNsZVwiKTtcbmNvbnN0IGFpXzEgPSByZXF1aXJlKFwiLi4vbWFpbi9haVwiKTtcbmNvbnN0IHBoeXNpY3NfMSA9IHJlcXVpcmUoXCIuLi9waHlzaWNzL3BoeXNpY3NcIik7XG5jb25zdCBqcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcbmNvbnN0IHRyYW5zcGFyZW5jeV8xID0gcmVxdWlyZShcIi4uL21haW4vdmZ4L3RyYW5zcGFyZW5jeVwiKTtcbmNvbnN0IGRyYXdWZnhfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3ZmeC9kcmF3VmZ4XCIpO1xuY29uc3QgdmZ4UXVldWVfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3ZmeC92ZnhRdWV1ZVwiKTtcbmNvbnN0IGFjdGl2ZVN0YWdlXzEgPSByZXF1aXJlKFwiLi4vc3RhZ2VzL2FjdGl2ZVN0YWdlXCIpO1xuY29uc3QgbXVzaWNfMSA9IHJlcXVpcmUoXCIuL211c2ljXCIpO1xuY29uc3QgdmZ4XzEgPSByZXF1aXJlKFwiLi4vbWFpbi92ZnhcIik7XG5jb25zdCByZW5kZXJWZnhfMSA9IHJlcXVpcmUoXCIuL3ZmeC9yZW5kZXJWZnhcIik7XG5jb25zdCBCb3gyRF8xID0gcmVxdWlyZShcIi4vdXRpbC9Cb3gyRFwiKTtcbmNvbnN0IFZlYzJEXzEgPSByZXF1aXJlKFwiLi91dGlsL1ZlYzJEXCIpO1xuY29uc3Qgc3RyZWFtY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tdWx0aXBsYXllci9zdHJlYW1jbGllbnRcIik7XG5jb25zdCByZXBsYXlfMSA9IHJlcXVpcmUoXCIuL3JlcGxheVwiKTtcbmNvbnN0IGlucHV0XzEgPSByZXF1aXJlKFwiLi4vaW5wdXQvaW5wdXRcIik7XG5jb25zdCBtZWxlZUlucHV0c18xID0gcmVxdWlyZShcIi4uL2lucHV0L21lbGVlSW5wdXRzXCIpO1xuY29uc3QgZmluZEdhbWVwYWRJbmZvXzEgPSByZXF1aXJlKFwiLi4vaW5wdXQvZ2FtZXBhZC9maW5kR2FtZXBhZEluZm9cIik7XG5jb25zdCBjdXN0b21fMSA9IHJlcXVpcmUoXCIuLi9pbnB1dC9nYW1lcGFkL2dhbWVwYWRzL2N1c3RvbVwiKTtcbmNvbnN0IHJldHJpZXZlR2FtZXBhZElucHV0c18xID0gcmVxdWlyZShcIi4uL2lucHV0L2dhbWVwYWQvcmV0cmlldmVHYW1lcGFkSW5wdXRzXCIpO1xuY29uc3QgZHJhd0dhbWVwYWRfMSA9IHJlcXVpcmUoXCIuLi9pbnB1dC9nYW1lcGFkL2RyYXdHYW1lcGFkXCIpO1xuY29uc3QgZGVlcENvcHlPYmplY3RfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZGVlcENvcHlPYmplY3RcIik7XG5jb25zdCBjc3NfMiA9IHJlcXVpcmUoXCIuLi9tZW51cy9jc3NcIik7XG4vKmdsb2JhbHMgcGVyZm9ybWFuY2UqL1xuZXhwb3J0cy5ob2xpZGF5ID0gMDtcbmV4cG9ydHMuc25vd0NvdW50ID0gMTUwO1xuLy90b2RvIGZpbmQgJ1BsYXllcicgb2JqZWN0XG5leHBvcnRzLnBsYXllciA9IFswLCAwLCAwLCAwXTtcbmV4cG9ydHMucmVuZGVyVGltZSA9IFsxMCwgMCwgMTAwLCAwXTtcbmV4cG9ydHMuZ2FtZWxvZ2ljVGltZSA9IFs1LCAwLCAxMDAsIDBdO1xuZXhwb3J0cy5mcmFtZXJhdGUgPSBbMCwgMCwgMF07XG5leHBvcnRzLmNoYXJhY3RlclNlbGVjdGlvbnMgPSBbMCwgMCwgMCwgMF07XG5leHBvcnRzLnNoaW5lID0gMC41O1xuZXhwb3J0cy5jcmVkaXRzUGxheWVyID0gMDtcbmV4cG9ydHMuY2FsaWJyYXRpb25QbGF5ZXIgPSAwO1xuZXhwb3J0cy5nYW1lRW5kID0gZmFsc2U7XG5leHBvcnRzLmNvbnRyb2xsZXJSZXNldENvdW50ZG93bnMgPSBbMCwgMCwgMCwgMF07XG5mdW5jdGlvbiBzZXRDb250cm9sbGVyUmVzZXQoaSkge1xuICAgIGV4cG9ydHMuY29udHJvbGxlclJlc2V0Q291bnRkb3duc1tpXSA9IDA7XG59XG5sZXQga2V5Ym9hcmRPY2N1cGllZCA9IGZhbHNlO1xuZXhwb3J0cy51c2luZ0N1c3RvbUNvbnRyb2xzID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcbmZ1bmN0aW9uIHNldFVzaW5nQ3VzdG9tQ29udHJvbHMoaSwgYm9vbGVhbiwgaW5mbykge1xuICAgIGV4cG9ydHMudXNpbmdDdXN0b21Db250cm9sc1tpXSA9IGJvb2xlYW47XG4gICAgaWYgKGJvb2wpIHtcbiAgICAgICAgZXhwb3J0cy5tVHlwZVtpXSA9IGN1c3RvbV8xLmN1c3RvbUdhbWVwYWRJbmZvW2V4cG9ydHMuY3VycmVudFBsYXllcnNbaV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwb3J0cy5tVHlwZVtpXSA9IGluZm87XG4gICAgfVxufVxuZXhwb3J0cy5maXJzdFRpbWVEZXRlY3RlZCA9IFt0cnVlLCB0cnVlLCB0cnVlLCB0cnVlXTtcbndpbmRvdy5tVHlwZSA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsXTtcbmV4cG9ydHMubVR5cGUgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XG5mdW5jdGlvbiBzZXRNdHlwZShpbmRleCwgdmFsKSB7XG4gICAgZXhwb3J0cy5tVHlwZVtpbmRleF0gPSB2YWw7XG59XG5leHBvcnRzLmN1cnJlbnRQbGF5ZXJzID0gW107XG5mdW5jdGlvbiBzZXRDdXJyZW50UGxheWVyKGluZGV4LCB2YWwpIHtcbiAgICBleHBvcnRzLmN1cnJlbnRQbGF5ZXJzW2luZGV4XSA9IHZhbDtcbn1cbmV4cG9ydHMucGxheWVyQW1vdW50ID0gMDtcbmV4cG9ydHMucGxheWVyVHlwZSA9IFstMSwgLTEsIC0xLCAtMV07XG5leHBvcnRzLmNwdURpZmZpY3VsdHkgPSBbMywgMywgMywgM107XG5leHBvcnRzLnBvcnRzID0gMDtcbmV4cG9ydHMuYWN0aXZlUG9ydHMgPSBbXTtcbmV4cG9ydHMucGxheWluZyA9IGZhbHNlO1xuZXhwb3J0cy5mcmFtZUJ5RnJhbWUgPSBmYWxzZTtcbmV4cG9ydHMud2FzRnJhbWVCeUZyYW1lID0gZmFsc2U7XG5leHBvcnRzLmZyYW1lQnlGcmFtZVJlbmRlciA9IGZhbHNlO1xuZXhwb3J0cy5maW5kaW5nUGxheWVycyA9IHRydWU7XG5leHBvcnRzLnNob3dEZWJ1ZyA9IGZhbHNlO1xuZXhwb3J0cy5nYW1lTW9kZSA9IDIwO1xuLy8gMjA6U3RhcnR1cFxuLy8gMTM6RGF0YSBNZW51XG4vLyAxMjpLZXlib2FyZCBDb250cm9sc1xuLy8gMTE6R2FtZXBsYXkgTWVudVxuLy8gMTA6U291bmQgTWVudVxuLy8gOTogLVxuLy8gODogLVxuLy8gNzpUYXJnZXQgU2VsZWN0XG4vLyA2OlN0YWdlIFNlbGVjdCAoVlMpXG4vLyA1OlRhcmdldCBQbGF5aW5nXG4vLyA0OlRhcmdldCBCdWlsZGVyXG4vLyAzOlBsYXlpbmcgKFZTKVxuLy8gMjpDU1Ncbi8vIDE6TWFpbiBNZW51XG4vLyAwOlRpdGxlIFNjcmVlblxuZXhwb3J0cy52ZXJzdXNNb2RlID0gMDtcbmV4cG9ydHMucmFuZG9tVGFncyA9IFtcIk5FTyFcIiwgXCJTRUxGXCIsIFwiTk9WQVwiLCBcIlBOREFcIiwgXCJQYW5kYVwiLCBcIkxGRk5cIiwgXCJTY29ycFwiLCBcIkFaXCIsIFwiQVhFXCIsIFwiVGVtcG9cIiwgXCJUTVBPXCIsIFwiW0Fdcm1hZGFcIiwgXCJXQkFMTFpcIiwgXCJXZXN0YmFsbHpcIiwgXCJQUE1EXCIsIFwiS3JleWdhc21cIiwgXCJNMktcIiwgXCJNYW5nMFwiLCBcIlVTQVwiLCBcIlNDQVJcIiwgXCJUT1BIXCIsIFwiKC5ZLilcIiwgXCJIQk9YXCIsIFwiSHVuZ3J5Qm94XCIsIFwiUExVUFwiLCBcIlNocm9vbWVkXCIsIFwiU0ZBVFwiLCBcIldpenpcIiwgXCJMdWNreVwiLCBcIlMySlwiLCBcIlNpbGVudFdvbGZcIiwgXCJhTVNhXCIsIFwiUzJKXCIsIFwiSGF4JFwiXTtcbmV4cG9ydHMucGFsZXR0ZXMgPSBbW1wicmdiKDI1MCwgODksIDg5KVwiLCBcInJnYigyNTUsIDE3MCwgMTcwKVwiLCBcInJnYmEoMjU1LCAyMDYsIDExMSwgXCIsIFwicmdiKDI0NCwgNjgsIDY4KVwiLCBcInJnYmEoMjU1LCAyMjUsIDE2NywgXCJdLFxuICAgIFtcInJnYig5NSwgMjE2LCA4NClcIiwgXCJyZ2IoMTg0LCAyNTMsIDE1NClcIiwgXCJyZ2JhKDI1MiwgOTUsIDk1LCBcIiwgXCJyZ2IoMjU1LCAxODIsIDk2KVwiLCBcInJnYmEoMjU0LCAxNDEsIDE0MSwgXCJdLFxuICAgIFtcInJnYig1LCAxOTUsIDI1NSlcIiwgXCJyZ2IoMTIxLCAyMjMsIDI1NSlcIiwgXCJyZ2JhKDIxOCwgOTYsIDI1NCwgXCIsIFwicmdiKDIzMSwgMTM0LCAyNTUpXCIsIFwicmdiYSgyMzAsIDE0NCwgMjU1LCBcIl0sXG4gICAgW1wicmdiKDI1NSwgMTg3LCA3MClcIiwgXCJyZ2IoMjQ4LCAyNTUsIDEyMilcIiwgXCJyZ2JhKDgwLCAxODIsIDI1NSwgXCIsIFwicmdiKDI1NSwgMTQyLCA3MClcIiwgXCJyZ2JhKDEzOSwgMjAzLCAyNDksIFwiXSxcbiAgICBbXCJyZ2IoMTc3LCA4OSwgMjU1KVwiLCBcInJnYigyMDMsIDE0NCwgMjU1KVwiLCBcInJnYmEoMTQ0LCAyNTUsIDExMCwgXCIsIFwicmdiKDI0NywgMTI2LCAyNTApXCIsIFwicmdiYSgxOTAsIDI1NSwgMTcwLCBcIl0sXG4gICAgW1wicmdiKDE4MiwgMTMxLCA3MClcIiwgXCJyZ2IoMjUyLCAxOTQsIDEyNilcIiwgXCJyZ2JhKDQ3LCAxODYsIDEyMywgXCIsIFwicmdiKDI1NSwgMTEyLCA2NilcIiwgXCJyZ2JhKDExMSwgMjE0LCAxNjgsIFwiXSxcbiAgICBbXCJyZ2IoMjMyLCAyMzIsIDIwOClcIiwgXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiwgXCJyZ2JhKDI0NCwgMjU1LCAxMTIsIFwiLCBcInJnYigxOTEsIDExOSwgMTE5KVwiLCBcInJnYmEoMjU1LCAyNTUsIDIwMCwgXCJdXTtcbmV4cG9ydHMuaGFzVGFnID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcbmV4cG9ydHMudGFnVGV4dCA9IFtcIlwiLCBcIlwiLCBcIlwiLCBcIlwiXTtcbmZ1bmN0aW9uIHNldFRhZ1RleHQoaW5kZXgsIHZhbHVlKSB7XG4gICAgZXhwb3J0cy50YWdUZXh0W2luZGV4XSA9IHZhbHVlO1xuICAgIGV4cG9ydHMuaGFzVGFnW2luZGV4XSA9IHRydWU7XG59XG5leHBvcnRzLnBQYWwgPSBbMCwgMSwgMiwgM107XG5leHBvcnRzLmNvc3R1bWVUaW1lb3V0ID0gW107XG5leHBvcnRzLmNvbG91cnMgPSBbXCJyZ2JhKDQsIDI1NSwgODIsIDAuNjIpXCIsIFwicmdiYSgxMTcsIDIwLCAyNTUsIDAuNjMpXCIsIFwicmdiYSgyNTUsIDIwLCAyMCwgMC42MylcIiwgXCJyZ2JhKDI1NSwgMjMyLCAyMCwgMC42MylcIl07XG5leHBvcnRzLnBhdXNlID0gW1t0cnVlLCB0cnVlXSwgW3RydWUsIHRydWVdLCBbdHJ1ZSwgdHJ1ZV0sIFt0cnVlLCB0cnVlXV07XG5leHBvcnRzLmZyYW1lQWR2YW5jZSA9IFtbdHJ1ZSwgdHJ1ZV0sIFt0cnVlLCB0cnVlXSwgW3RydWUsIHRydWVdLCBbdHJ1ZSwgdHJ1ZV1dO1xuZXhwb3J0cy5zdGFydGluZ1BvaW50ID0gW1stNTAsIDUwXSwgWzUwLCA1MF0sIFstMjUsIDVdLCBbMjUsIDVdXTtcbmV4cG9ydHMuc3RhcnRpbmdGYWNlID0gWzEsIC0xLCAxLCAtMV07XG5leHBvcnRzLmdyb3VuZCA9IFtbLTY4LjQsIDBdLCBbNjguNCwgMF1dO1xuZXhwb3J0cy5wbGF0Zm9ybXMgPSBbW1stNTcuNiwgMjcuMl0sIFstMjAsIDI3LjJdXSwgW1syMCwgMjcuMl0sIFs1Ny42LCAyNy4yXV0sIFtbLTE4LjgsIDU0LjRdLCBbMTguOCwgNTQuNF1dXTtcbmV4cG9ydHMud2FsbHNMID0gW1tbLTY4LjQsIDBdLCBbLTY4LjQsIC0xMDguOF1dXTtcbmV4cG9ydHMud2FsbHNSID0gW1tbNjguNCwgMF0sIFs2OC40LCAtMTA4LjhdXV07XG5leHBvcnRzLmVkZ2VzID0gW1tbLTY4LjQsIDBdLCBbLTYzLjQsIDBdXSwgW1s2OC40LCAwXSwgWzYzLjQsIDBdXV07XG4vL2VkZ2VPZmZzZXQgPSBbWy03MS4zLC0yMy43XSxbNzEuMywtMjMuN11dO1xuZXhwb3J0cy5lZGdlT2Zmc2V0ID0gW1stMi45LCAtMjMuN10sIFsyLjksIC0yMy43XV07XG5leHBvcnRzLmVkZ2VPcmllbnRhdGlvbiA9IFsxLCAtMV07XG5leHBvcnRzLnJlc3Bhd25Qb2ludHMgPSBbWy01MCwgNTAsIDFdLCBbNTAsIDUwLCAtMV0sIFsyNSwgMzUsIDFdLCBbLTI1LCAzNSwgLTFdXTtcbmV4cG9ydHMuc3RhZ2VTZWxlY3QgPSAwO1xuZnVuY3Rpb24gc2V0U3RhZ2VTZWxlY3QodmFsKSB7XG4gICAgZXhwb3J0cy5zdGFnZVNlbGVjdCA9IHZhbDtcbn1cbmV4cG9ydHMuYmxhc3R6b25lID0gbmV3IEJveDJEXzEuQm94MkQoWy0yMjQsIDIwMF0sIFsyMjQsIC0xMDguOF0pO1xuZXhwb3J0cy5zdGFydGluZyA9IHRydWU7XG5mdW5jdGlvbiBzZXRTdGFydGluZyh2YWwpIHtcbiAgICBleHBvcnRzLnN0YXJ0aW5nID0gdmFsO1xufVxuZXhwb3J0cy5zdGFydFRpbWVyID0gMS41O1xuZnVuY3Rpb24gc2V0U3RhcnRUaW1lcih2YWwpIHtcbiAgICBleHBvcnRzLnN0YXJ0VGltZXIgPSB2YWw7XG59XG5mdW5jdGlvbiBnZXRTdGFydFRpbWVyKCkge1xuICAgIHJldHVybiBleHBvcnRzLnN0YXJ0VGltZXI7XG59XG4vL21hdGNoVGltZXIgPSA1OTk5Ljk5O1xuZXhwb3J0cy5tYXRjaFRpbWVyID0gNDgwO1xuZnVuY3Rpb24gYWRkTWF0Y2hUaW1lcih2YWwpIHtcbiAgICBleHBvcnRzLm1hdGNoVGltZXIgKz0gdmFsO1xufVxuZnVuY3Rpb24gc2V0TWF0Y2hUaW1lcih2YWwpIHtcbiAgICBleHBvcnRzLm1hdGNoVGltZXIgPSB2YWw7XG59XG5mdW5jdGlvbiBnZXRNYXRjaFRpbWVyKCkge1xuICAgIHJldHVybiBleHBvcnRzLm1hdGNoVGltZXI7XG59XG5leHBvcnRzLnVzaW5nTG9jYWxTdG9yYWdlID0gZmFsc2U7XG5pZiAodHlwZW9mIChTdG9yYWdlKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIENvZGUgZm9yIGxvY2FsU3RvcmFnZS9zZXNzaW9uU3RvcmFnZS5cbiAgICBleHBvcnRzLnVzaW5nTG9jYWxTdG9yYWdlID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcImxvY2FsIHN0b3JhZ2Ugd29ya3NcIik7XG59XG5lbHNlIHtcbiAgICAvLyBTb3JyeSEgTm8gV2ViIFN0b3JhZ2Ugc3VwcG9ydC4uXG4gICAgY29uc29sZS5sb2coXCJsb2NhbCBzdG9yYWdlIGRvZXMgbm90IHdvcmtcIik7XG59XG5mdW5jdGlvbiBzZXRDb29raWUoY25hbWUsIGN2YWx1ZSwgZXhkYXlzKSB7XG4gICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgIGQuc2V0VGltZShkLmdldFRpbWUoKSArIChleGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgdmFyIGV4cCA9IFwiZXhwaXJlcz1cIiArIGQudG9VVENTdHJpbmcoKTtcbiAgICBkb2N1bWVudC5jb29raWUgPSBjbmFtZSArIFwiPVwiICsgY3ZhbHVlICsgXCI7IFwiICsgZXhwO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGNuYW1lLCBjdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0VmVyc3VzTW9kZSh2YWwpIHtcbiAgICBleHBvcnRzLnZlcnN1c01vZGUgPSB2YWw7XG59XG5mdW5jdGlvbiBnZXRDb29raWUoY25hbWUpIHtcbiAgICBpZiAoZXhwb3J0cy51c2luZ0xvY2FsU3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oY25hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjbmFtZSArIFwiPVwiO1xuICAgICAgICB2YXIgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PSAnICcpXG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lKSA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydHMua2V5cyA9IHt9O1xuZXhwb3J0cy5rZXlCaW5kID0gMDtcbmV4cG9ydHMua2V5QmluZGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0S2V5QmluZGluZyh2YWwpIHtcbiAgICBleHBvcnRzLmtleUJpbmRpbmcgPSB2YWw7XG59XG5mdW5jdGlvbiBvdmVycmlkZUtleWJvYXJkRXZlbnQoZSkge1xuICAgIGlmICghc2hvd2luZ0NvZGUgJiYgY3NzXzEuY2hvb3NpbmdUYWcgPT0gLTEgJiYgZS5rZXlDb2RlICE9IDEyMiAmJiBlLmtleUNvZGUgIT0gMTE2KSB7XG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICAgICAgICAgIGlmICghZXhwb3J0cy5rZXlzW2Uua2V5Q29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5rZXlzW2Uua2V5Q29kZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmtleUJpbmQgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMua2V5QmluZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIGtleSBkb3duIHN0dWZmIGhlcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICAgICAgICBkZWxldGUgKGV4cG9ydHMua2V5c1tlLmtleUNvZGVdKTtcbiAgICAgICAgICAgICAgICAvLyBkbyBrZXkgdXAgc3R1ZmYgaGVyZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRpc2FibGVkRXZlbnRQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY3NzXzEuY2hvb3NpbmdUYWcgPiAtMSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmtleXNbMTNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwia2V5dXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSAoZXhwb3J0cy5rZXlzWzEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG47XG5mdW5jdGlvbiBkaXNhYmxlZEV2ZW50UHJvcGFnYXRpb24oZSkge1xuICAgIGlmIChlKSB7XG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbjtcbmRvY3VtZW50Lm9ua2V5ZG93biA9IG92ZXJyaWRlS2V5Ym9hcmRFdmVudDtcbmRvY3VtZW50Lm9ua2V5dXAgPSBvdmVycmlkZUtleWJvYXJkRXZlbnQ7XG4vKnZhciBrZXlzID0gW107XG5leHBvcnQgY29uc3Qgb25rZXl1cCAoZSkge1xuICBrZXlzW2Uua2V5Q29kZV09ZmFsc2U7XG59XG5leHBvcnQgY29uc3Qgb25rZXlkb3duIChlKSB7XG4gIGtleXNbZS5rZXlDb2RlXT10cnVlO1xufSovXG5mdW5jdGlvbiBTVkcodGFnKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpO1xufVxuLyppZiAoR2FtZXBhZC5zdXBwb3J0ZWQpIHtcbiAgICBjb25zb2xlLmxvZyhcImdhbWVwYWQgc3VwcG9ydGVkXCIpO1xufSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhcImdhbWVwYWQgbm90IHN1cHBvcnRlZFwiKTtcbn0qL1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkY29ubmVjdGVkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgY29uc29sZS5sb2coXCJHYW1lcGFkIGNvbm5lY3RlZCBhdCBpbmRleCAlZDogJXMuICVkIGJ1dHRvbnMsICVkIGF4ZXMuXCIsIGUuZ2FtZXBhZC5pbmRleCwgZS5nYW1lcGFkLmlkLCBlLmdhbWVwYWQuYnV0dG9ucy5sZW5ndGgsIGUuZ2FtZXBhZC5heGVzLmxlbmd0aCk7XG59KTtcbmlmIChuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMpXG4gICAgY29uc29sZS5sb2cobmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpO1xuZnVuY3Rpb24gbWF0Y2hUaW1lclRpY2soaW5wdXQpIHtcbiAgICBleHBvcnRzLm1hdGNoVGltZXIgLT0gMC4wMTY2Njc7XG4gICAgaWYgKGRvbS5tYXRjaE1pbnV0ZXMgJiYgZG9tLm1hdGNoU2Vjb25kcykge1xuICAgICAgICB2YXIgc2VjID0gKGV4cG9ydHMubWF0Y2hUaW1lciAlIDYwKS50b0ZpeGVkKDIpO1xuICAgICAgICBkb20ubWF0Y2hNaW51dGVzLmlubmVySFRNTCA9IE1hdGguZmxvb3IoZXhwb3J0cy5tYXRjaFRpbWVyIC8gNjApO1xuICAgICAgICBkb20ubWF0Y2hTZWNvbmRzLmlubmVySFRNTCA9IHNlYy5sZW5ndGggPCA1ID8gYDAke3NlY31gIDogc2VjO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5tYXRjaFRpbWVyIDw9IDApIHtcbiAgICAgICAgZmluaXNoR2FtZShpbnB1dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NyZWVuU2hha2Uoa2IpIHtcbiAgICB2YXIgc2VlZCA9IFtNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpXTtcbiAgICBleHBvcnRzLmZnMS50cmFuc2xhdGUoa2IgKiAwLjEgKiBzZWVkWzBdLCBrYiAqIDAuMSAqIHNlZWRbMV0pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBleHBvcnRzLmZnMS50cmFuc2xhdGUoLWtiICogMC4wNSAqIHNlZWRbMF0sIC1rYiAqIDAuMDUgKiBzZWVkWzFdKTsgfSwgMjApO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBleHBvcnRzLmZnMS50cmFuc2xhdGUoLWtiICogMC4wNSAqIHNlZWRbMF0sIC1rYiAqIDAuMDUgKiBzZWVkWzFdKTsgZXhwb3J0cy5mZzEudHJhbnNsYXRlKC1rYiAqIDAuMSAqIHNlZWRbMl0sIC1rYiAqIDAuMSAqIHNlZWRbM10pOyB9LCA0MCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGV4cG9ydHMuZmcxLnRyYW5zbGF0ZShrYiAqIDAuMDUgKiBzZWVkWzJdLCBrYiAqIDAuMDUgKiBzZWVkWzNdKTsgfSwgNjApO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBleHBvcnRzLmZnMS50cmFuc2xhdGUoa2IgKiAwLjA1ICogc2VlZFsyXSwga2IgKiAwLjA1ICogc2VlZFszXSk7IH0sIDgwKTtcbn1cbmZ1bmN0aW9uIHBlcmNlbnRTaGFrZShrYiwgaSkge1xuICAgIGV4cG9ydHMucGxheWVyW2ldLnBlcmNlbnRTaGFrZSA9IG5ldyBWZWMyRF8xLlZlYzJEKGtiICogMC4xICogTWF0aC5yYW5kb20oKSwga2IgKiAwLjEgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZXhwb3J0cy5wbGF5ZXJbaV0ucGVyY2VudFNoYWtlID0gbmV3IFZlYzJEXzEuVmVjMkQoa2IgKiAwLjA1ICogTWF0aC5yYW5kb20oKSwga2IgKiAwLjA1ICogTWF0aC5yYW5kb20oKSk7IH0sIDIwKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZXhwb3J0cy5wbGF5ZXJbaV0ucGVyY2VudFNoYWtlID0gbmV3IFZlYzJEXzEuVmVjMkQoLWtiICogMC4xICogTWF0aC5yYW5kb20oKSwgLWtiICogMC4xICogTWF0aC5yYW5kb20oKSk7IH0sIDQwKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgZXhwb3J0cy5wbGF5ZXJbaV0ucGVyY2VudFNoYWtlID0gbmV3IFZlYzJEXzEuVmVjMkQoLWtiICogMC4wNSAqIE1hdGgucmFuZG9tKCksIC1rYiAqIDAuMDUgKiBNYXRoLnJhbmRvbSgpKTsgfSwgNjApO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBleHBvcnRzLnBsYXllcltpXS5wZXJjZW50U2hha2UgPSBuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKTsgfSwgODApO1xufVxuZnVuY3Rpb24gZmluZFBsYXllcnMoKSB7XG4gICAgdmFyIGdwcyA9IG5hdmlnYXRvci5nZXRHYW1lcGFkcyA/IG5hdmlnYXRvci5nZXRHYW1lcGFkcygpIDogKG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcyA/IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpIDogW10pO1xuICAgIC8qaWYgKHR5cGVvZiBncHMgIT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICBjb25zb2xlLmxvZyhncHMpO1xuICAgIH0qL1xuICAgIGlmICgha2V5Ym9hcmRPY2N1cGllZCkge1xuICAgICAgICBpZiAoZXhwb3J0cy5nYW1lTW9kZSA8IDIgfHwgZXhwb3J0cy5nYW1lTW9kZSA9PSAyMCkge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMua2V5c1sxM10gfHwgZXhwb3J0cy5rZXlzW3NldHRpbmdzXzEua2V5TWFwLnNbMF1dIHx8IGV4cG9ydHMua2V5c1tzZXR0aW5nc18xLmtleU1hcC5zWzFdXSkge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLnBvcnRzIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VHYW1lbW9kZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2tleWJvYXJkUHJvbXB0XCIpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRPY2N1cGllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNmeF8xLnNvdW5kcy5tZW51Rm9yd2FyZC5wbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLnBvcnRzID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c2ljXzEuTXVzaWNNYW5hZ2VyLnBsYXlNZW51TG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkZFBsYXllcihleHBvcnRzLnBvcnRzLCBcImtleWJvYXJkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLmtleXNbc2V0dGluZ3NfMS5rZXlNYXAuYVswXV0gfHwgZXhwb3J0cy5rZXlzW3NldHRpbmdzXzEua2V5TWFwLmFbMV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMucG9ydHMgPCA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkT2NjdXBpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhZGRQbGF5ZXIoZXhwb3J0cy5wb3J0cywgXCJrZXlib2FyZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdhbWVwYWQgPSBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMgPyBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKVtpXSA6IChuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHMgPyBuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHMoKVtpXSA6IG51bGwpO1xuICAgICAgICBpZiAoZXhwb3J0cy5wbGF5ZXJUeXBlW2ldID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgYWxyZWFkeUluID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGV4cG9ydHMucG9ydHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLmN1cnJlbnRQbGF5ZXJzW2tdID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbHJlYWR5SW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0cy5wb3J0cyA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGxheWVyKGksIDk5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2FtZXBhZCA9IG5hdmlnYXRvci5nZXRHYW1lcGFkcyA/IG5hdmlnYXRvci5nZXRHYW1lcGFkcygpW2ldIDogKG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcyA/IG5hdmlnYXRvci53ZWJraXRHZXRHYW1lcGFkcygpW2ldIDogbnVsbCk7XG4gICAgICAgIGlmICh0eXBlb2YgZ2FtZXBhZCAhPSBcInVuZGVmaW5lZFwiICYmIGdhbWVwYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRldGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZ3BkTmFtZTtcbiAgICAgICAgICAgIHZhciBncGRJbmZvO1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMudXNpbmdDdXN0b21Db250cm9sc1tpXSAmJiBjdXN0b21fMS5jdXN0b21HYW1lcGFkSW5mb1tpXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdwZE5hbWUgPSBcImN1c3RvbSBjb250cm9sc1wiO1xuICAgICAgICAgICAgICAgIGdwZEluZm8gPSBjdXN0b21fMS5jdXN0b21HYW1lcGFkSW5mb1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXliZU5hbWVBbmRJbmZvID0gKDAsIGZpbmRHYW1lcGFkSW5mb18xLmdldEdhbWVwYWROYW1lQW5kSW5mbykoZ2FtZXBhZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlTmFtZUFuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBpbiAnZmluZFBsYXllcnMnOiBjb250cm9sbGVyIFwiICsgKGkgKyAxKSArIFwiIGRldGVjdGVkIGJ1dCBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUcnkgbWFudWFsIGNhbGlicmF0aW9uIG9mIHlvdXIgY29udHJvbGxlci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIFtncGROYW1lLCBncGRJbmZvXSA9IG1heWJlTmFtZUFuZEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMuZmlyc3RUaW1lRGV0ZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb250cm9sbGVyIFwiICsgKGkgKyAxKSArIFwiIGlzOiBcIiArIGdwZE5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuZmlyc3RUaW1lRGV0ZWN0ZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPCAyIHx8IGV4cG9ydHMuZ2FtZU1vZGUgPT0gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCByZXRyaWV2ZUdhbWVwYWRJbnB1dHNfMS5idXR0b25TdGF0ZSkoZ2FtZXBhZCwgZ3BkSW5mbywgXCJzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxyZWFkeUluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGV4cG9ydHMucG9ydHM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLmN1cnJlbnRQbGF5ZXJzW2tdID09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeUluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlJbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLnBvcnRzIDwgNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VHYW1lbW9kZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2tleWJvYXJkUHJvbXB0XCIpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Z4XzEuc291bmRzLm1lbnVGb3J3YXJkLnBsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMucG9ydHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11c2ljXzEuTXVzaWNNYW5hZ2VyLnBsYXlNZW51TG9vcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBsYXllcihpLCBncGRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgcmV0cmlldmVHYW1lcGFkSW5wdXRzXzEuYnV0dG9uU3RhdGUpKGdhbWVwYWQsIGdwZEluZm8sIFwiYVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFscmVhZHlJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBleHBvcnRzLnBvcnRzOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0cy5jdXJyZW50UGxheWVyc1trXSA9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5SW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0cy5wb3J0cyA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGxheWVyKGksIGdwZEluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gY29udHJvbGxlciBkZXRlY3RlZCBieSBicm93c2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0UGxheWVyVHlwZShwbGF5ZXJTbG90LCB0eXBlKSB7XG4gICAgZXhwb3J0cy5wbGF5ZXJUeXBlW3BsYXllclNsb3RdID0gdHlwZTtcbn1cbmZ1bmN0aW9uIGFkZFBsYXllcihpLCBjb250cm9sbGVySW5mbykge1xuICAgIGlmIChjb250cm9sbGVySW5mbyA9PT0gOTkpIHtcbiAgICAgICAgZXhwb3J0cy5wb3J0cysrO1xuICAgICAgICBleHBvcnRzLmN1cnJlbnRQbGF5ZXJzW2V4cG9ydHMucG9ydHMgLSAxXSA9IGk7XG4gICAgICAgIGV4cG9ydHMucGxheWVyVHlwZVtleHBvcnRzLnBvcnRzIC0gMV0gPSAyO1xuICAgICAgICBleHBvcnRzLm1UeXBlW2V4cG9ydHMucG9ydHMgLSAxXSA9IGNvbnRyb2xsZXJJbmZvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwb3J0cy5wb3J0cysrO1xuICAgICAgICBleHBvcnRzLmN1cnJlbnRQbGF5ZXJzW2V4cG9ydHMucG9ydHMgLSAxXSA9IGk7XG4gICAgICAgIGV4cG9ydHMucGxheWVyVHlwZVtleHBvcnRzLnBvcnRzIC0gMV0gPSAwO1xuICAgICAgICBleHBvcnRzLm1UeXBlW2V4cG9ydHMucG9ydHMgLSAxXSA9IGNvbnRyb2xsZXJJbmZvO1xuICAgICAgICBpZiAoZXhwb3J0cy5zaG93RGVidWcpIHtcbiAgICAgICAgICAgICgwLCBkcmF3R2FtZXBhZF8xLnVwZGF0ZUdhbWVwYWRTVkdDb2xvdXIpKGksIFwiZ2FtZXBhZFNWR1wiICsgaSk7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdhbWVwYWRTVkdcIiArIGkpLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdG9nZ2xlUG9ydChpKSB7XG4gICAgZXhwb3J0cy5wbGF5ZXJUeXBlW2ldKys7XG4gICAgaWYgKGV4cG9ydHMucGxheWVyVHlwZVtpXSA9PSAzKSB7XG4gICAgICAgIGV4cG9ydHMucGxheWVyVHlwZVtpXSA9IC0xO1xuICAgICAgICBpZiAoZXhwb3J0cy5zaG93RGVidWcpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZXBhZFNWR1wiICsgaSkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHBvcnRzLnBsYXllclR5cGVbaV0gPT0gMCAmJiBleHBvcnRzLnBvcnRzIDw9IGkpIHtcbiAgICAgICAgZXhwb3J0cy5wbGF5ZXJUeXBlW2ldID0gMTtcbiAgICAgICAgKDAsIGRyYXdHYW1lcGFkXzEuc2V0R2FtZXBhZFNWR0NvbG91cikoaSwgXCJibGFja1wiKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuc2hvd0RlYnVnKSB7XG4gICAgICAgICAgICAoMCwgZHJhd0dhbWVwYWRfMS51cGRhdGVHYW1lcGFkU1ZHQ29sb3VyKShpLCBcImdhbWVwYWRTVkdcIiArIGkpO1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lcGFkU1ZHXCIgKyBpKS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc2l0aW9uUGxheWVyc0luQ1NTKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gKC04MCArIGkgKiA1MCkgKiAyIC8gMztcbiAgICAgICAgdmFyIHkgPSAtMzA7XG4gICAgICAgIGV4cG9ydHMucGxheWVyW2ldLnBoeXMucG9zID0gbmV3IFZlYzJEXzEuVmVjMkQoeCwgeSk7XG4gICAgICAgIGV4cG9ydHMucGxheWVyW2ldLnBoeXMuaHVydGJveCA9IG5ldyBCb3gyRF8xLkJveDJEKFstNCArIHgsIDE4ICsgeV0sIFs0ICsgeCwgeV0pO1xuICAgIH1cbn1cbi8vIDIwOlN0YXJ0dXBcbi8vIDE0OkNvbnRyb2xsZXIgTWVudVxuLy8gMTM6RGF0YSBNZW51XG4vLyAxMjpLZXlib2FyZCBDb250cm9sc1xuLy8gMTE6R2FtZXBsYXkgTWVudVxuLy8gMTA6U291bmQgTWVudVxuLy8gOTogLVxuLy8gODogLVxuLy8gNzpUYXJnZXQgU2VsZWN0XG4vLyA2OlN0YWdlIFNlbGVjdCAoVlMpXG4vLyA1OlRhcmdldCBQbGF5aW5nXG4vLyA0OlRhcmdldCBCdWlsZGVyXG4vLyAzOlBsYXlpbmcgKFZTKVxuLy8gMjpDU1Ncbi8vIDE6TWFpbiBNZW51XG4vLyAwOlRpdGxlIFNjcmVlblxuZnVuY3Rpb24gY2hhbmdlR2FtZW1vZGUobmV3R2FtZW1vZGUpIHtcbiAgICBleHBvcnRzLmJnMS5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG4gICAgZXhwb3J0cy5iZzEuZmlsbFJlY3QoMCwgMCwgZXhwb3J0cy5sYXllcnMuQkcxLndpZHRoLCBleHBvcnRzLmxheWVycy5CRzEuaGVpZ2h0KTtcbiAgICBleHBvcnRzLmZnMS5jbGVhclJlY3QoMCwgMCwgZXhwb3J0cy5sYXllcnMuRkcxLndpZHRoLCBleHBvcnRzLmxheWVycy5GRzEuaGVpZ2h0KTtcbiAgICBleHBvcnRzLmdhbWVNb2RlID0gbmV3R2FtZW1vZGU7XG4gICAgc3dpdGNoIChuZXdHYW1lbW9kZSkge1xuICAgICAgICAvLyBUSVRMRVNDUkVFTlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAoMCwgc3RhcnRzY3JlZW5fMS5kcmF3U3RhcnRTY3JlZW5Jbml0KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1BSU4gTUVOVVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjbG9nb1ZpZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICgwLCBtZW51XzEuZHJhd01haW5NZW51SW5pdCkoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDU1NcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgKDAsIGNzc18xLmRyYXdDU1NJbml0KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFBsYXlpbmcgKFZTKVxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAoMCwgc3RhZ2VyZW5kZXJfMS5kcmF3QmFja2dyb3VuZEluaXQpKCk7XG4gICAgICAgICAgICAoMCwgc3RhZ2VyZW5kZXJfMS5kcmF3U3RhZ2VJbml0KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRhcmdldCBCdWlsZGVyXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUYXJnZXQgUGxheWluZ1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAoMCwgc3RhZ2VyZW5kZXJfMS5kcmF3QmFja2dyb3VuZEluaXQpKCk7XG4gICAgICAgICAgICAoMCwgc3RhZ2VyZW5kZXJfMS5kcmF3U3RhZ2VJbml0KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFN0YWdlIHNlbGVjdCAodnMpXG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICgwLCBzdGFnZXNlbGVjdF8xLmRyYXdTU1NJbml0KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRhcmdldCBTZWxlY3RcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgZHJhd1RTU0luaXQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBzb3VuZCBtZW51XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAoMCwgYXVkaW9tZW51XzEuZHJhd0F1ZGlvTWVudUluaXQpKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZ2FtZXBsYXkgbWVudVxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgKDAsIGdhbWVwbGF5bWVudV8xLmRyYXdHYW1lcGxheU1lbnVJbml0KSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGtleWJvYXJkIG1lbnVcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICgwLCBrZXlib2FyZG1lbnVfMS5kcmF3S2V5Ym9hcmRNZW51SW5pdCkoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBjcmVkaXRzXG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAoMCwgY3JlZGl0c18xLmRyYXdDcmVkaXRzSW5pdCkoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNdWx0aXBsYXllciBNb2Rlc1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51XzEuZHJhd0NvbnRyb2xsZXJNZW51SW5pdCkoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgKDAsIGNzc18xLmRyYXdDU1NJbml0KSgpO1xuICAgICAgICAgICAgKDAsIHN0cmVhbWNsaWVudF8xLmNvbm5lY3RUb01QU2VydmVyKSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIHN0YXJ0dXBcbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuLypleHBvcnQgY29uc3QgYWRkUGxheWVyIChpLGdUeXBlLHBUeXBlKXtcbiAgY29uc29sZS5sb2coaSxnVHlwZSxwVHlwZSk7XG5cbiAgY3VycmVudFBsYXllcnMucHVzaChpKTtcbiAgaWYgKHBUeXBlID09IDApe1xuICAgIHBvcnRzKys7XG4gICAgbVR5cGVbcG9ydHMtMV0gPSBnVHlwZTtcbiAgICBwbGF5ZXJUeXBlW3BvcnRzLTFdID0gcFR5cGU7XG5cbiAgICBjb3N0dW1lVGltZW91dC5wdXNoKGZhbHNlKTtcbiAgICBwUGFsLnB1c2gocG9ydHMtMSk7XG4gICAgYnVpbGRQbGF5ZXJPYmplY3QocG9ydHMtMSk7XG4gICAgcGxheWVyW3BsYXllckFtb3VudC0xXS5waHlzLnBvcyA9IG5ldyBWZWMyRCgtMTAwKzI1KihwbGF5ZXJBbW91bnQ9MSksLTQwKTtcbiAgICBwbGF5ZXJbcG9ydHMtMV0ucGh5cy5mYWNlID0gMTtcbiAgICBwbGF5ZXJbcG9ydHMtMV0uYWN0aW9uU3RhdGUgPSAwO1xuICAgICQoXCIjY3VycmVudFBsYXllcnNcIikuYXBwZW5kKCc8ZGl2IGNsYXNzPVwicEJveEJveFwiPjxkaXYgY2xhc3M9XCJwbGF5ZXJCb3hcIiBpZD1cInBCb3gnKyhwb3J0cy0xKSsnXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrcGFsZXR0ZXNbcFBhbFtwb3J0cy0xXV1bMF0rJztib3JkZXI6NXB4IHNvbGlkICcrcGFsZXR0ZXNbcFBhbFtwb3J0cy0xXV1bMl0rJzAuOClcIj48cD5QJytwb3J0cysnPGJyPjxzcGFuIGNsYXNzPVwiY29udFwiPihDb250LiAnK2krJyk8L3NwYW4+PC9wPjwvZGl2PjxkaXYgaWQ9XCJwVGFnJysocG9ydHMtMSkrJ1wiIGNsYXNzPVwicFRhZ1wiPjx0ZXh0YXJlYSBpZD1cInBUYWdFZGl0JysocG9ydHMtMSkrJ1wiIGNsYXNzPVwicFRhZ0VkaXRcIiBtYXhsZW5ndGg9XCIxMFwiPjwvdGV4dGFyZWE+PC9kaXY+PC9kaXY+Jyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbVR5cGVbaV0gPSBnVHlwZTtcblxuICAgIGNvc3R1bWVUaW1lb3V0LnB1c2goZmFsc2UpO1xuICAgIHBQYWwucHVzaChpKTtcbiAgICBidWlsZFBsYXllck9iamVjdChpKTtcbiAgICBwbGF5ZXJbcGxheWVyQW1vdW50LTFdLnBoeXMucG9zID0gbmV3IFZlYzJEKC0xMDArMjUqKHBsYXllckFtb3VudD0xKSwtNDApO1xuICAgIHBsYXllcltpXS5waHlzLmZhY2UgPSAxO1xuICAgIHBsYXllcltpXS5hY3Rpb25TdGF0ZSA9IDA7XG4gICAgJChcIiNjdXJyZW50UGxheWVyc1wiKS5hcHBlbmQoJzxkaXYgY2xhc3M9XCJwQm94Qm94XCI+PGRpdiBjbGFzcz1cInBsYXllckJveFwiIGlkPVwicEJveCcraSsnXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicrcGFsZXR0ZXNbcFBhbFtpXV1bMF0rJztib3JkZXI6NXB4IHNvbGlkICcrcGFsZXR0ZXNbcFBhbFtpXV1bMl0rJzAuOClcIj48cD5QJysoaSsxKSsnPGJyPjxzcGFuIGNsYXNzPVwiY29udFwiPihDb250LiAnK2krJyk8L3NwYW4+PC9wPjwvZGl2PjxkaXYgaWQ9XCJwVGFnJytpKydcIiBjbGFzcz1cInBUYWdcIj48dGV4dGFyZWEgaWQ9XCJwVGFnRWRpdCcraSsnXCIgY2xhc3M9XCJwVGFnRWRpdFwiIG1heGxlbmd0aD1cIjEwXCI+PC90ZXh0YXJlYT48L2Rpdj48L2Rpdj4nKTtcbiAgfVxuICBwbGF5ZXJBbW91bnQrKztcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZVBsYXllciAoaSl7XG4gIHBsYXllclR5cGVbaV0gPSAtMTtcbiAgcGxheWVyQW1vdW50LS07XG59Ki9cbmZ1bmN0aW9uIGludGVycHJldElucHV0cyhpLCBhY3RpdmUsIHBsYXllcnR5cGUsIGlucHV0QnVmZmVyKSB7XG4gICAgbGV0IHRlbXBCdWZmZXIgPSAoMCwgaW5wdXRfMS5udWxsSW5wdXRzKSgpO1xuICAgIC8vIGtlZXAgdXBkYXRpbmcgWiBhbmQgU3RhcnQgYWxsIHRoZSB0aW1lLCBldmVuIHdoZW4gcGF1c2VkXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA3OyBrKyspIHtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10ueiA9IGlucHV0QnVmZmVyWzYgLSBrXS56O1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5zID0gaW5wdXRCdWZmZXJbNiAtIGtdLnM7XG4gICAgfVxuICAgIHRlbXBCdWZmZXJbMF0gPSAoMCwgaW5wdXRfMS5wb2xsSW5wdXRzKShleHBvcnRzLmdhbWVNb2RlLCBleHBvcnRzLmZyYW1lQnlGcmFtZSwgZXhwb3J0cy5tVHlwZVtpXSwgaSwgZXhwb3J0cy5jdXJyZW50UGxheWVyc1tpXSwgZXhwb3J0cy5rZXlzLCBwbGF5ZXJ0eXBlKTtcbiAgICBsZXQgcGFzdE9mZnNldCA9IDA7XG4gICAgaWYgKChleHBvcnRzLmdhbWVNb2RlICE9PSAzICYmIGV4cG9ydHMuZ2FtZU1vZGUgIT09IDUpIHx8IChleHBvcnRzLnBsYXlpbmcgJiYgKGV4cG9ydHMucGF1c2VbaV1bMV0gfHwgIWV4cG9ydHMucGF1c2VbaV1bMF0pKVxuICAgICAgICB8fCBleHBvcnRzLndhc0ZyYW1lQnlGcmFtZVxuICAgICAgICB8fCAoIWV4cG9ydHMucGxheWluZyAmJiBleHBvcnRzLnBhdXNlW2ldWzBdICYmICFleHBvcnRzLnBhdXNlW2ldWzFdKSkge1xuICAgICAgICBwYXN0T2Zmc2V0ID0gMTtcbiAgICB9XG4gICAgZXhwb3J0cy5wYXVzZVtpXVsxXSA9IGV4cG9ydHMucGF1c2VbaV1bMF07XG4gICAgZXhwb3J0cy53YXNGcmFtZUJ5RnJhbWUgPSBmYWxzZTtcbiAgICBleHBvcnRzLmZyYW1lQWR2YW5jZVtpXVsxXSA9IGV4cG9ydHMuZnJhbWVBZHZhbmNlW2ldWzBdO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgNzsgaysrKSB7XG4gICAgICAgIHRlbXBCdWZmZXJbNyAtIGtdLmxzWCA9IGlucHV0QnVmZmVyWzcgLSBrIC0gcGFzdE9mZnNldF0ubHNYO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5sc1kgPSBpbnB1dEJ1ZmZlcls3IC0gayAtIHBhc3RPZmZzZXRdLmxzWTtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10ucmF3WCA9IGlucHV0QnVmZmVyWzcgLSBrIC0gcGFzdE9mZnNldF0ucmF3WDtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10ucmF3WSA9IGlucHV0QnVmZmVyWzcgLSBrIC0gcGFzdE9mZnNldF0ucmF3WTtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10uY3NYID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5jc1g7XG4gICAgICAgIHRlbXBCdWZmZXJbNyAtIGtdLmNzWSA9IGlucHV0QnVmZmVyWzcgLSBrIC0gcGFzdE9mZnNldF0uY3NZO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5yYXdjc1ggPSBpbnB1dEJ1ZmZlcls3IC0gayAtIHBhc3RPZmZzZXRdLnJhd2NzWDtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10ucmF3Y3NZID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5yYXdjc1k7XG4gICAgICAgIHRlbXBCdWZmZXJbNyAtIGtdLmxBID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5sQTtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10uckEgPSBpbnB1dEJ1ZmZlcls3IC0gayAtIHBhc3RPZmZzZXRdLnJBO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5hID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5hO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5iID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5iO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS54ID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS54O1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS55ID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS55O1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5yID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5yO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5sID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5sO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5kbCA9IGlucHV0QnVmZmVyWzcgLSBrIC0gcGFzdE9mZnNldF0uZGw7XG4gICAgICAgIHRlbXBCdWZmZXJbNyAtIGtdLmRkID0gaW5wdXRCdWZmZXJbNyAtIGsgLSBwYXN0T2Zmc2V0XS5kZDtcbiAgICAgICAgdGVtcEJ1ZmZlcls3IC0ga10uZHIgPSBpbnB1dEJ1ZmZlcls3IC0gayAtIHBhc3RPZmZzZXRdLmRyO1xuICAgICAgICB0ZW1wQnVmZmVyWzcgLSBrXS5kdSA9IGlucHV0QnVmZmVyWzcgLSBrIC0gcGFzdE9mZnNldF0uZHU7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLm1UeXBlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICgoZXhwb3J0cy5tVHlwZVtpXSA9PT0gXCJrZXlib2FyZFwiICYmICh0ZW1wQnVmZmVyWzBdLnogfHwgdGVtcEJ1ZmZlclsxXS56KSlcbiAgICAgICAgICAgIHx8IChleHBvcnRzLm1UeXBlW2ldICE9PSBcImtleWJvYXJkXCIgJiYgKHRlbXBCdWZmZXJbMF0ueiAmJiAhdGVtcEJ1ZmZlclsxXS56KSkpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWVBZHZhbmNlW2ldWzBdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWVBZHZhbmNlW2ldWzBdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuZnJhbWVBZHZhbmNlW2ldWzBdICYmICFleHBvcnRzLmZyYW1lQWR2YW5jZVtpXVsxXSAmJiAhZXhwb3J0cy5wbGF5aW5nICYmIGV4cG9ydHMuZ2FtZU1vZGUgIT09IDQpIHtcbiAgICAgICAgZXhwb3J0cy5mcmFtZUJ5RnJhbWUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5tVHlwZVtpXSA9PT0gXCJrZXlib2FyZFwiKSB7IC8vIGtleWJvYXJkIGNvbnRyb2xzXG4gICAgICAgIGlmICh0ZW1wQnVmZmVyWzBdLnMgfHwgdGVtcEJ1ZmZlclsxXS5zIHx8IChleHBvcnRzLmdhbWVNb2RlID09PSA1ICYmICh0ZW1wQnVmZmVyWzBdLmR1IHx8IHRlbXBCdWZmZXJbMV0uZHUpKSkge1xuICAgICAgICAgICAgZXhwb3J0cy5wYXVzZVtpXVswXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRzLnBhdXNlW2ldWzBdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleHBvcnRzLnBsYXlpbmcgJiYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMyB8fCBleHBvcnRzLmdhbWVNb2RlID09IDUpXG4gICAgICAgICAgICAmJiAodGVtcEJ1ZmZlclswXS5hIHx8IHRlbXBCdWZmZXJbMV0uYSkgJiYgKHRlbXBCdWZmZXJbMF0ubCB8fCB0ZW1wQnVmZmVyWzFdLmwpXG4gICAgICAgICAgICAmJiAodGVtcEJ1ZmZlclswXS5yIHx8IHRlbXBCdWZmZXJbMV0ucikgJiYgKHRlbXBCdWZmZXJbMF0ucyB8fCB0ZW1wQnVmZmVyWzFdLnMpKSB7XG4gICAgICAgICAgICBpZiAodGVtcEJ1ZmZlclswXS5iIHx8IHRlbXBCdWZmZXJbMV0uYikge1xuICAgICAgICAgICAgICAgIHN0YXJ0R2FtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kR2FtZShpbnB1dEJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJwcmV0UGF1c2UoZXhwb3J0cy5wYXVzZVtpXVswXSwgZXhwb3J0cy5wYXVzZVtpXVsxXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cG9ydHMubVR5cGVbaV0gIT09IG51bGwpIHsgLy8gZ2FtZXBhZCBjb250cm9sc1xuICAgICAgICBpZiAoIWV4cG9ydHMucGxheWluZyAmJiAoZXhwb3J0cy5nYW1lTW9kZSA9PSAzIHx8IGV4cG9ydHMuZ2FtZU1vZGUgPT0gNSkgJiZcbiAgICAgICAgICAgICh0ZW1wQnVmZmVyWzBdLmEgJiYgdGVtcEJ1ZmZlclswXS5sICYmIHRlbXBCdWZmZXJbMF0uciAmJiB0ZW1wQnVmZmVyWzBdLnMpXG4gICAgICAgICAgICAmJiAoISh0ZW1wQnVmZmVyWzFdLmEgJiYgdGVtcEJ1ZmZlclsxXS5sICYmIHRlbXBCdWZmZXJbMV0uciAmJiB0ZW1wQnVmZmVyWzFdLnMpKSkge1xuICAgICAgICAgICAgaWYgKHRlbXBCdWZmZXJbMF0uYikge1xuICAgICAgICAgICAgICAgIHN0YXJ0R2FtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kR2FtZShpbnB1dEJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBCdWZmZXJbMF0ucyB8fCB0ZW1wQnVmZmVyWzBdLmR1ICYmIGV4cG9ydHMuZ2FtZU1vZGUgPT0gNSkge1xuICAgICAgICAgICAgZXhwb3J0cy5wYXVzZVtpXVswXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRzLnBhdXNlW2ldWzBdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udHJvbGxlciByZXNldCBmdW5jdGlvbmFsaXR5XG4gICAgICAgIGlmICgodGVtcEJ1ZmZlclswXS56IHx8IHRlbXBCdWZmZXJbMF0uZHUpICYmIHRlbXBCdWZmZXJbMF0ueCAmJiB0ZW1wQnVmZmVyWzBdLnkpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuY29udHJvbGxlclJlc2V0Q291bnRkb3duc1tpXSAtPSAxO1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuY29udHJvbGxlclJlc2V0Q291bnRkb3duc1tpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJzIGNvZGUgaW4gaW5wdXQuanNcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbnRyb2xsZXIgI1wiICsgKGkgKyAxKSArIFwiIHdhcyByZXNldCFcIik7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI3Jlc2V0SW5kaWNhdG9yXCIgKyBpKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjcmVzZXRJbmRpY2F0b3JcIiArIGkpLmZhZGVPdXQoNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydHMuY29udHJvbGxlclJlc2V0Q291bnRkb3duc1tpXSA9IDEyNTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnByZXRQYXVzZShleHBvcnRzLnBhdXNlW2ldWzBdLCBleHBvcnRzLnBhdXNlW2ldWzFdKTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIEFJXG4gICAgICAgIHRlbXBCdWZmZXJbMF0ucmF3WCA9IHRlbXBCdWZmZXJbMF0ubHNYO1xuICAgICAgICB0ZW1wQnVmZmVyWzBdLnJhd1kgPSB0ZW1wQnVmZmVyWzBdLmxzWTtcbiAgICAgICAgdGVtcEJ1ZmZlclswXS5yYXdjc1ggPSB0ZW1wQnVmZmVyWzBdLmNzWDtcbiAgICAgICAgdGVtcEJ1ZmZlclswXS5yYXdjc1kgPSB0ZW1wQnVmZmVyWzBdLmNzWTtcbiAgICAgICAgdGVtcEJ1ZmZlclswXS5sc1ggPSAoMCwgbWVsZWVJbnB1dHNfMS5kZWFkZW4pKHRlbXBCdWZmZXJbMF0ucmF3WCk7XG4gICAgICAgIHRlbXBCdWZmZXJbMF0ubHNZID0gKDAsIG1lbGVlSW5wdXRzXzEuZGVhZGVuKSh0ZW1wQnVmZmVyWzBdLnJhd1kpO1xuICAgICAgICB0ZW1wQnVmZmVyWzBdLmNzWCA9ICgwLCBtZWxlZUlucHV0c18xLmRlYWRlbikodGVtcEJ1ZmZlclswXS5yYXdjc1gpO1xuICAgICAgICB0ZW1wQnVmZmVyWzBdLmNzWSA9ICgwLCBtZWxlZUlucHV0c18xLmRlYWRlbikodGVtcEJ1ZmZlclswXS5yYXdjc1kpO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5zaG93RGVidWcpIHtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2xzQXhpc1hcIiArIGkpLmVtcHR5KCkuYXBwZW5kKHRlbXBCdWZmZXJbMF0ubHNYLnRvRml4ZWQoMykpO1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjbHNBeGlzWVwiICsgaSkuZW1wdHkoKS5hcHBlbmQodGVtcEJ1ZmZlclswXS5sc1kudG9GaXhlZCgzKSk7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNjc0F4aXNYXCIgKyBpKS5lbXB0eSgpLmFwcGVuZCh0ZW1wQnVmZmVyWzBdLmNzWC50b0ZpeGVkKDMpKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2NzQXhpc1lcIiArIGkpLmVtcHR5KCkuYXBwZW5kKHRlbXBCdWZmZXJbMF0uY3NZLnRvRml4ZWQoMykpO1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjbEFuYWxvZ1wiICsgaSkuZW1wdHkoKS5hcHBlbmQodGVtcEJ1ZmZlclswXS5sQS50b0ZpeGVkKDMpKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI3JBbmFsb2dcIiArIGkpLmVtcHR5KCkuYXBwZW5kKHRlbXBCdWZmZXJbMF0uckEudG9GaXhlZCgzKSk7XG4gICAgICAgICgwLCBkcmF3R2FtZXBhZF8xLnVwZGF0ZUdhbWVwYWRTVkdTdGF0ZSkoaSwgXCJnYW1lcGFkU1ZHXCIgKyBpLCB0ZW1wQnVmZmVyWzBdKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT09IDE0KSB7IC8vIGNvbnRyb2xsZXIgY2FsaWJyYXRpb24gc2NyZWVuXG4gICAgICAgICgwLCBkcmF3R2FtZXBhZF8xLnVwZGF0ZUdhbWVwYWRTVkdTdGF0ZSkoaSwgXCJnYW1lcGFkU1ZHQ2FsaWJyYXRpb25cIiwgdGVtcEJ1ZmZlclswXSk7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLnNob3dEZWJ1ZyB8fCBleHBvcnRzLmdhbWVNb2RlID09PSAxNCkge1xuICAgICAgICBjb25zdCB3aGljaCA9IChleHBvcnRzLnNob3dEZWJ1ZyAmJiBleHBvcnRzLmdhbWVNb2RlID09PSAxNCkgPyBcImJvdGhcIiA6IGV4cG9ydHMuc2hvd0RlYnVnID8gXCJkZWJ1Z1wiIDogXCJjYWxpYnJhdGlvblwiO1xuICAgICAgICBpZiAodGVtcEJ1ZmZlclswXS54ICYmICF0ZW1wQnVmZmVyWzFdLnggJiYgdGVtcEJ1ZmZlclswXS5kdSkge1xuICAgICAgICAgICAgKDAsIGRyYXdHYW1lcGFkXzEuY3ljbGVHYW1lcGFkQ29sb3VyKShpLCB3aGljaCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBCdWZmZXJbMF0ueSAmJiAhdGVtcEJ1ZmZlclsxXS55ICYmIHRlbXBCdWZmZXJbMF0uZHUpIHtcbiAgICAgICAgICAgICgwLCBkcmF3R2FtZXBhZF8xLmN5Y2xlR2FtZXBhZENvbG91cikoaSwgd2hpY2gsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RyZWFtY2xpZW50XzEuZ2l2ZUlucHV0c1tpXSA9PT0gdHJ1ZSkge1xuICAgICAgICAvL3R1cm5zIG91dCBrZXlib2FyZHMgbGVhdmUgZ2FwcyBpbiB0aGUgaW5wdXQgYnVmZmVyXG4gICAgICAgICgwLCBkZWVwQ29weU9iamVjdF8xLmRlZXBPYmplY3RNZXJnZSkodHJ1ZSwgKDAsIGlucHV0XzEubnVsbElucHV0KSgpLCB0ZW1wQnVmZmVyWzBdKTtcbiAgICAgICAgKDAsIHN0cmVhbWNsaWVudF8xLnVwZGF0ZU5ldHdvcmtJbnB1dHMpKHRlbXBCdWZmZXJbMF0sIGkpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGlmICh0ZW1wQnVmZmVyWzBdLmRsICYmICF0ZW1wQnVmZmVyWzFdLmRsKSB7XG4gICAgICAgICAgICBleHBvcnRzLnBsYXllcltpXS5zaG93TGVkZ2VHcmFiQm94IF49IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBCdWZmZXJbMF0uZGQgJiYgIXRlbXBCdWZmZXJbMV0uZGQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMucGxheWVyW2ldLnNob3dFQ0IgXj0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcEJ1ZmZlclswXS5kciAmJiAhdGVtcEJ1ZmZlclsxXS5kcikge1xuICAgICAgICAgICAgZXhwb3J0cy5wbGF5ZXJbaV0uc2hvd0hpdGJveCBePSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmZyYW1lQnlGcmFtZSkge1xuICAgICAgICB0ZW1wQnVmZmVyWzBdLnogPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBCdWZmZXI7XG59XG5mdW5jdGlvbiBpbnRlcnByZXRQYXVzZShwYXVzZTAsIHBhdXNlMSkge1xuICAgIGlmIChwYXVzZTAgJiYgIXBhdXNlMSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5nYW1lTW9kZSA9PSAzIHx8IGV4cG9ydHMuZ2FtZU1vZGUgPT0gNSkge1xuICAgICAgICAgICAgZXhwb3J0cy5wbGF5aW5nIF49IHRydWU7XG4gICAgICAgICAgICBpZiAoIWV4cG9ydHMucGxheWluZykge1xuICAgICAgICAgICAgICAgIHNmeF8xLnNvdW5kcy5wYXVzZS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlVm9sdW1lKG11c2ljXzEuTXVzaWNNYW5hZ2VyLCBhdWRpb21lbnVfMS5tYXN0ZXJWb2x1bWVbMV0gKiAwLjMsIDEpO1xuICAgICAgICAgICAgICAgICgwLCByZW5kZXJfMS5yZW5kZXJGb3JlZ3JvdW5kKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVm9sdW1lKG11c2ljXzEuTXVzaWNNYW5hZ2VyLCBhdWRpb21lbnVfMS5tYXN0ZXJWb2x1bWVbMV0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5iZzEgPSAwO1xuZXhwb3J0cy5iZzIgPSAwO1xuZXhwb3J0cy5mZzEgPSAwO1xuZXhwb3J0cy5mZzIgPSAwO1xuZXhwb3J0cy51aSA9IDA7XG5leHBvcnRzLmMgPSAwO1xuZXhwb3J0cy5jYW52YXNNYWluID0gMDtcbmV4cG9ydHMubGF5ZXJzID0ge1xuICAgIEJHMTogMCxcbiAgICBCRzI6IDAsXG4gICAgRkcxOiAwLFxuICAgIEZHMjogMCxcbiAgICBVSTogMFxufTtcbmV4cG9ydHMubGF5ZXJTd2l0Y2hlcyA9IHtcbiAgICBCRzE6IHRydWUsXG4gICAgQkcyOiB0cnVlLFxuICAgIEZHMTogdHJ1ZSxcbiAgICBGRzI6IHRydWUsXG4gICAgVUk6IHRydWVcbn07XG5mdW5jdGlvbiByZW5kZXJUb01haW4oKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmxheWVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLmxheWVyU3dpdGNoZXNba2V5c1tpXV0pIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYy5kcmF3SW1hZ2UoZXhwb3J0cy5sYXllcnNba2V5c1tpXV0sIDAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlKGksIGlucHV0QnVmZmVycykge1xuICAgIGlmICghZXhwb3J0cy5zdGFydGluZykge1xuICAgICAgICBpZiAoZXhwb3J0cy5jdXJyZW50UGxheWVyc1tpXSAhPSAtMSkge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMucGxheWVyVHlwZVtpXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZywgdXNlIHRoZSBwcm92aWRlZCBwbGF5ZXIgaSBpbnB1dHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cG9ydHMucGxheWVyVHlwZVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLnBsYXllcltpXS5hY3Rpb25TdGF0ZSAhPSBcIlNMRUVQXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGFpXzEucnVuQUkpKGkpOyAvLyBubyBuZWVkIHRvIHJldHVybiBpbnB1dCBzaW5jZSBwb2xsaW5nIHJldHVybnMgYWkgaW5wdXQgaWYgdGhleSBhcmUgYWN0aXZlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICgwLCBwaHlzaWNzXzEucGh5c2ljcykoaSwgaW5wdXRCdWZmZXJzKTtcbn1cbmxldCBkZWx0YSA9IDA7XG5sZXQgbGFzdEZyYW1lVGltZU1zID0gMDtcbmxldCBsYXN0VXBkYXRlID0gcGVyZm9ybWFuY2Uubm93KCk7XG5mdW5jdGlvbiBnYW1lVGljayhvbGRJbnB1dEJ1ZmZlcnMpIHtcbiAgICB2YXIgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgZGlmZiA9IDA7XG4gICAgbGV0IGlucHV0ID0gWygwLCBpbnB1dF8xLm51bGxJbnB1dHMpKCksICgwLCBpbnB1dF8xLm51bGxJbnB1dHMpKCksICgwLCBpbnB1dF8xLm51bGxJbnB1dHMpKCksICgwLCBpbnB1dF8xLm51bGxJbnB1dHMpKCldO1xuICAgIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDAgfHwgZXhwb3J0cy5nYW1lTW9kZSA9PSAyMCkge1xuICAgICAgICBmaW5kUGxheWVycygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDEpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhwbGF5ZXJUeXBlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBvcnRzLnBvcnRzOyBpKyspIHtcbiAgICAgICAgICAgIGlucHV0W2ldID0gaW50ZXJwcmV0SW5wdXRzKGksIHRydWUsIGV4cG9ydHMucGxheWVyVHlwZVtpXSwgb2xkSW5wdXRCdWZmZXJzW2ldKTtcbiAgICAgICAgICAgICgwLCBtZW51XzEubWVudU1vdmUpKGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDEwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwb3J0cy5wb3J0czsgaSsrKSB7XG4gICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbaV0sIG9sZElucHV0QnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAoMCwgYXVkaW9tZW51XzEuYXVkaW9NZW51Q29udHJvbHMpKGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDExKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwb3J0cy5wb3J0czsgaSsrKSB7XG4gICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbaV0sIG9sZElucHV0QnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAoMCwgZ2FtZXBsYXltZW51XzEuZ2FtZXBsYXlNZW51Q29udHJvbHMpKGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDEyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwb3J0cy5wb3J0czsgaSsrKSB7XG4gICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbaV0sIG9sZElucHV0QnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAoMCwga2V5Ym9hcmRtZW51XzEua2V5Ym9hcmRNZW51Q29udHJvbHMpKGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDEzKSB7XG4gICAgICAgIGlucHV0W2V4cG9ydHMuY3JlZGl0c1BsYXllcl0gPSBpbnRlcnByZXRJbnB1dHMoZXhwb3J0cy5jcmVkaXRzUGxheWVyLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbZXhwb3J0cy5jcmVkaXRzUGxheWVyXSwgb2xkSW5wdXRCdWZmZXJzW2V4cG9ydHMuY3JlZGl0c1BsYXllcl0pO1xuICAgICAgICAoMCwgY3JlZGl0c18xLmNyZWRpdHMpKGV4cG9ydHMuY3JlZGl0c1BsYXllciwgaW5wdXQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDE0KSB7XG4gICAgICAgIC8vIGNvbnRyb2xsZXIgY2FsaWJyYXRpb25cbiAgICAgICAgaW5wdXRbZXhwb3J0cy5jYWxpYnJhdGlvblBsYXllcl0gPSBpbnRlcnByZXRJbnB1dHMoZXhwb3J0cy5jYWxpYnJhdGlvblBsYXllciwgdHJ1ZSwgZXhwb3J0cy5wbGF5ZXJUeXBlW2V4cG9ydHMuY2FsaWJyYXRpb25QbGF5ZXJdLCBvbGRJbnB1dEJ1ZmZlcnNbZXhwb3J0cy5jYWxpYnJhdGlvblBsYXllcl0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDE1KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwb3J0cy5wb3J0czsgaSsrKSB7XG4gICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbaV0sIG9sZElucHV0QnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAoMCwgbWVudV8xLm1lbnVNb3ZlKShpLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwb3J0cy5nYW1lTW9kZSA9PSAyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGV4cG9ydHMucG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbaV0sIG9sZElucHV0QnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgKDAsIGNzc18xLmNzc0NvbnRyb2xzKShpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb25TdGF0ZVNob3J0Y3V0c18xLmFjdGlvblN0YXRlc1tleHBvcnRzLmNoYXJhY3RlclNlbGVjdGlvbnNbaV1dW2V4cG9ydHMucGxheWVyW2ldLmFjdGlvblN0YXRlXS5tYWluKGksIGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMucGxheWVyVHlwZVtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgKDAsIGhpdERldGVjdGlvbl8xLmhpdERldGVjdCkoaSwgaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICgwLCBoaXREZXRlY3Rpb25fMS5leGVjdXRlSGl0cykoaW5wdXQpO1xuICAgICAgICAoMCwgaGl0RGV0ZWN0aW9uXzEucmVzZXRIaXRRdWV1ZSkoKTtcbiAgICAgICAgZmluZFBsYXllcnMoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwb3J0cy5nYW1lTW9kZSA9PSA2KSB7XG4gICAgICAgIC8vIHN0YWdlIHNlbGVjdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBleHBvcnRzLnBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRbaV0gPSBpbnRlcnByZXRJbnB1dHMoaSwgdHJ1ZSwgZXhwb3J0cy5wbGF5ZXJUeXBlW2ldLCBvbGRJbnB1dEJ1ZmZlcnNbaV0pO1xuICAgICAgICAgICAgICAgICgwLCBzdGFnZXNlbGVjdF8xLnNzc0NvbnRyb2xzKShpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwb3J0cy5wbGF5aW5nIHx8IGV4cG9ydHMuZnJhbWVCeUZyYW1lKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJ0ZXN0MFwiKTtcbiAgICAgICAgLypkZWx0YSA9IHRpbWVzdGFtcCAtIGxhc3RGcmFtZVRpbWVNczsgLy8gZ2V0IHRoZSBkZWx0YSB0aW1lIHNpbmNlIGxhc3QgZnJhbWVcbiAgICAgICAgbGFzdEZyYW1lVGltZU1zID0gdGltZXN0YW1wO1xuICAgICAgICBjb25zb2xlLmxvZyhkZWx0YSk7Ki9cbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgZHQgPSBub3cgLSBsYXN0VXBkYXRlO1xuICAgICAgICAvL2NvbnNvbGUubG9nKG5vdyk7XG4gICAgICAgIC8vY29uc29sZS5sb2coZHQpO1xuICAgICAgICBsYXN0VXBkYXRlID0gbm93O1xuICAgICAgICAoMCwgaGl0RGV0ZWN0aW9uXzEucmVzZXRIaXRRdWV1ZSkoKTtcbiAgICAgICAgKDAsIGFjdGl2ZVN0YWdlXzEuZ2V0QWN0aXZlU3RhZ2UpKCkubW92aW5nUGxhdGZvcm1zKCk7XG4gICAgICAgICgwLCBhcnRpY2xlXzEuZGVzdHJveUFydGljbGVzKSgpO1xuICAgICAgICAoMCwgYXJ0aWNsZV8xLmV4ZWN1dGVBcnRpY2xlcykoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLnBsYXllclR5cGVbaV0gPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghZXhwb3J0cy5zdGFydGluZykge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCB0cnVlLCBleHBvcnRzLnBsYXllclR5cGVbaV0sIG9sZElucHV0QnVmZmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZShpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGhpdERldGVjdGlvbl8xLmNoZWNrUGhhbnRvbXMpKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5wbGF5ZXJUeXBlW2ldID4gLTEpIHtcbiAgICAgICAgICAgICAgICAoMCwgaGl0RGV0ZWN0aW9uXzEuaGl0RGV0ZWN0KShpLCBpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGhpdERldGVjdGlvbl8xLmV4ZWN1dGVIaXRzKShpbnB1dCk7XG4gICAgICAgICgwLCBhcnRpY2xlXzEuYXJ0aWNsZXNIaXREZXRlY3Rpb24pKCk7XG4gICAgICAgICgwLCBhcnRpY2xlXzEuZXhlY3V0ZUFydGljbGVIaXRzKShpbnB1dCk7XG4gICAgICAgIGlmICghZXhwb3J0cy5zdGFydGluZyAmJiAhZXhwb3J0cy52ZXJzdXNNb2RlKSB7XG4gICAgICAgICAgICBtYXRjaFRpbWVyVGljayhpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvcnRzLnN0YXJ0VGltZXIgLT0gMC4wMTY2NjY2NztcbiAgICAgICAgICAgIGlmIChleHBvcnRzLnN0YXJ0VGltZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5zdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLmZyYW1lQnlGcmFtZSkge1xuICAgICAgICAgICAgZXhwb3J0cy5mcmFtZUJ5RnJhbWVSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgZXhwb3J0cy53YXNGcmFtZUJ5RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuZnJhbWVCeUZyYW1lID0gZmFsc2U7XG4gICAgICAgIGlmIChleHBvcnRzLnNob3dEZWJ1Zykge1xuICAgICAgICAgICAgZGlmZiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICBleHBvcnRzLmdhbWVsb2dpY1RpbWVbMF0gKz0gZGlmZjtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2FtZWxvZ2ljVGltZVswXSAvPSAyO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gMTApIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLmdhbWVsb2dpY1RpbWVbM10rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmIDwgZXhwb3J0cy5nYW1lbG9naWNUaW1lWzJdKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5nYW1lbG9naWNUaW1lWzJdID0gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmID4gZXhwb3J0cy5nYW1lbG9naWNUaW1lWzFdKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5nYW1lbG9naWNUaW1lWzFdID0gZGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbS5nYW1lbG9naWNBdmcuaW5uZXJIVE1MID0gTWF0aC5yb3VuZChleHBvcnRzLmdhbWVsb2dpY1RpbWVbMF0pO1xuICAgICAgICAgICAgZG9tLmdhbWVsb2dpY0hpZ2guaW5uZXJIVE1MID0gTWF0aC5yb3VuZChleHBvcnRzLmdhbWVsb2dpY1RpbWVbMV0pO1xuICAgICAgICAgICAgZG9tLmdhbWVsb2dpY0xvdy5pbm5lckhUTUwgPSBNYXRoLnJvdW5kKGV4cG9ydHMuZ2FtZWxvZ2ljVGltZVsyXSk7XG4gICAgICAgICAgICBkb20uZ2FtZWxvZ2ljUGVhay5pbm5lckhUTUwgPSBleHBvcnRzLmdhbWVsb2dpY1RpbWVbM107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwb3J0cy5maW5kaW5nUGxheWVycykge1xuICAgICAgICBmaW5kUGxheWVycygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFleHBvcnRzLmdhbWVFbmQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMucGxheWVyVHlwZVtpXSA9PSAwIHx8IGV4cG9ydHMucGxheWVyVHlwZVtpXSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLmN1cnJlbnRQbGF5ZXJzW2ldICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFtpXSA9IGludGVycHJldElucHV0cyhpLCBmYWxzZSwgZXhwb3J0cy5wbGF5ZXJUeXBlW2ldLCBvbGRJbnB1dEJ1ZmZlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gIFxuICAgIHZhciBiZWZvcmVXYXN0ZXIgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBuZWVlZCB0byB3YXN0ZSAwLjY2Nm1zXG4gICAgdmFyIHRpbWVXYXN0ZWQgPSBmYWxzZTtcbiAgICB2YXIgdCA9IDA7XG4gICAgdmFyIG8gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZSghdGltZVdhc3RlZCl7XG4gICAgICB2YXIgbiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdCArPSBuIC0gbztcbiAgICAgIC8vY29uc29sZS5sb2codCk7XG4gICAgICBpZiAodCA+IDAuNjY2Nil7XG4gICAgICAgIHRpbWVXYXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbyA9IG47XG4gICAgICAvL2NvbnNvbGUubG9nKFwiLlwiKTtcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhwZXJmb3JtYW5jZS5ub3coKSAtIGJlZm9yZVdhc3Rlcik7Ki9cbiAgICAoMCwgcmVwbGF5XzEuc2F2ZUdhbWVTdGF0ZSkoaW5wdXQsIGV4cG9ydHMucG9ydHMpO1xuICAgIHNldFRpbWVvdXQoZ2FtZVRpY2ssIDE2LCBpbnB1dCk7XG59XG5mdW5jdGlvbiBjbGVhclNjcmVlbigpIHtcbiAgICAvL2JnMS5maWxsU3R5bGUgPSBcInJnYigwLCAwLCAwKVwiO1xuICAgIC8vYmcxLmZpbGxSZWN0KDAsMCxsYXllcnMuQkcxLndpZHRoLGxheWVycy5CRzEuaGVpZ2h0KTtcbiAgICBleHBvcnRzLmJnMi5jbGVhclJlY3QoMCwgMCwgZXhwb3J0cy5sYXllcnMuQkcyLndpZHRoLCBleHBvcnRzLmxheWVycy5CRzIuaGVpZ2h0KTtcbiAgICAvL2ZnMS5jbGVhclJlY3QoMCwwLGxheWVycy5GRzEud2lkdGgsbGF5ZXJzLkZHMS5oZWlnaHQpO1xuICAgIGV4cG9ydHMuZmcyLmNsZWFyUmVjdCgwLCAwLCBleHBvcnRzLmxheWVycy5GRzIud2lkdGgsIGV4cG9ydHMubGF5ZXJzLkZHMi5oZWlnaHQpO1xuICAgIGV4cG9ydHMudWkuY2xlYXJSZWN0KDAsIDAsIGV4cG9ydHMubGF5ZXJzLlVJLndpZHRoLCBleHBvcnRzLmxheWVycy5VSS5oZWlnaHQpO1xufVxubGV0IG90aGVyRnJhbWUgPSB0cnVlO1xubGV0IGZwczMwID0gZmFsc2U7XG5mdW5jdGlvbiByZW5kZXJUaWNrKCkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyVGljayk7XG4gICAgb3RoZXJGcmFtZSBePSB0cnVlO1xuICAgIGlmICgoZnBzMzAgJiYgb3RoZXJGcmFtZSkgfHwgIWZwczMwKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCItLS0tLS1cIik7XG4gICAgICAgIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDIwKSB7XG4gICAgICAgICAgICAoMCwgc3RhcnR1cF8xLmRyYXdTdGFydFVwKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMTApIHtcbiAgICAgICAgICAgICgwLCBhdWRpb21lbnVfMS5kcmF3QXVkaW9NZW51KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMTEpIHtcbiAgICAgICAgICAgICgwLCBnYW1lcGxheW1lbnVfMS5kcmF3R2FtZXBsYXlNZW51KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMTIpIHtcbiAgICAgICAgICAgICgwLCBrZXlib2FyZG1lbnVfMS5kcmF3S2V5Ym9hcmRNZW51KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMTMpIHtcbiAgICAgICAgICAgICgwLCBjcmVkaXRzXzEuZHJhd0NyZWRpdHMpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwb3J0cy5nYW1lTW9kZSA9PSAxNCkge1xuICAgICAgICAgICAgKDAsIGNvbnRyb2xsZXJtZW51XzEuZHJhd0NvbnRyb2xsZXJNZW51KSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMCkge1xuICAgICAgICAgICAgKDAsIHN0YXJ0c2NyZWVuXzEuZHJhd1N0YXJ0U2NyZWVuKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMuZ2FtZU1vZGUgPT0gMSkge1xuICAgICAgICAgICAgKDAsIG1lbnVfMS5kcmF3TWFpbk1lbnUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwb3J0cy5nYW1lTW9kZSA9PSAyKSB7XG4gICAgICAgICAgICAoMCwgY3NzXzEuZHJhd0NTUykoKTtcbiAgICAgICAgICAgIC8vcmVuZGVyVmZ4KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwb3J0cy5nYW1lTW9kZSA9PSA2KSB7XG4gICAgICAgICAgICAoMCwgc3RhZ2VzZWxlY3RfMS5kcmF3U1NTKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cG9ydHMucGxheWluZyB8fCBleHBvcnRzLmZyYW1lQnlGcmFtZVJlbmRlcikge1xuICAgICAgICAgICAgLypkZWx0YSA9IHRpbWVzdGFtcCAtIGxhc3RGcmFtZVRpbWVNczsgLy8gZ2V0IHRoZSBkZWx0YSB0aW1lIHNpbmNlIGxhc3QgZnJhbWVcbiAgICAgICAgICAgIGxhc3RGcmFtZVRpbWVNcyA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRlbHRhKTsqL1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInRlc3QyXCIpO1xuICAgICAgICAgICAgdmFyIHJTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY2xlYXJTY3JlZW4oKTtcbiAgICAgICAgICAgIGlmICgoMCwgdmZ4XzEuaXNTaG93U0ZYKSgpKSB7XG4gICAgICAgICAgICAgICAgKDAsIHN0YWdlcmVuZGVyXzEuZHJhd0JhY2tncm91bmQpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgc3RhZ2VyZW5kZXJfMS5kcmF3U3RhZ2UpKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLnBsYXllclR5cGVbaV0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgcmVuZGVyXzEucmVuZGVyUGxheWVyKShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgYXJ0aWNsZV8xLnJlbmRlckFydGljbGVzKSgpO1xuICAgICAgICAgICAgKDAsIHJlbmRlclZmeF8xLnJlbmRlclZmeCkoKTtcbiAgICAgICAgICAgICgwLCByZW5kZXJfMS5yZW5kZXJPdmVybGF5KSh0cnVlKTtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLnNob3dEZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gcGVyZm9ybWFuY2Uubm93KCkgLSByU3RhcnQ7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5yZW5kZXJUaW1lWzBdICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5yZW5kZXJUaW1lWzBdIC89IDI7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPj0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5yZW5kZXJUaW1lWzNdKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWZmID4gZXhwb3J0cy5yZW5kZXJUaW1lWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucmVuZGVyVGltZVsxXSA9IGRpZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgZXhwb3J0cy5yZW5kZXJUaW1lWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucmVuZGVyVGltZVsyXSA9IGRpZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvbS5yZW5kZXJBdmcuaW5uZXJIVE1MID0gTWF0aC5yb3VuZChleHBvcnRzLnJlbmRlclRpbWVbMF0pO1xuICAgICAgICAgICAgICAgIGRvbS5yZW5kZXJIaWdoLmlubmVySFRNTCA9IE1hdGgucm91bmQoZXhwb3J0cy5yZW5kZXJUaW1lWzFdKTtcbiAgICAgICAgICAgICAgICBkb20ucmVuZGVyTG93LmlubmVySFRNTCA9IE1hdGgucm91bmQoZXhwb3J0cy5yZW5kZXJUaW1lWzJdKTtcbiAgICAgICAgICAgICAgICBkb20ucmVuZGVyUGVhay5pbm5lckhUTUwgPSBleHBvcnRzLnJlbmRlclRpbWVbM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMuZnJhbWVCeUZyYW1lUmVuZGVyKSB7XG4gICAgICAgICAgICAoMCwgcmVuZGVyXzEucmVuZGVyRm9yZWdyb3VuZCkoKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLmZyYW1lQnlGcmFtZVJlbmRlciA9IGZhbHNlO1xuICAgICAgICAvL3JlbmRlclRvTWFpbigpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChleHBvcnRzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgICgwLCByZW5kZXJWZnhfMS5yZW5kZXJWZngpKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRQbGF5ZXJPYmplY3QoaSkge1xuICAgIGV4cG9ydHMucGxheWVyW2ldID0gbmV3IHBsYXllcl8xLnBsYXllck9iamVjdChleHBvcnRzLmNoYXJhY3RlclNlbGVjdGlvbnNbaV0sIGV4cG9ydHMuc3RhcnRpbmdQb2ludFtpXSwgZXhwb3J0cy5zdGFydGluZ0ZhY2VbaV0pO1xuICAgIGV4cG9ydHMucGxheWVyW2ldLnBoeXMuRUNCMSA9IFtuZXcgVmVjMkRfMS5WZWMyRChleHBvcnRzLnN0YXJ0aW5nUG9pbnRbaV0ueCwgZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLnkpLCBuZXcgVmVjMkRfMS5WZWMyRChleHBvcnRzLnN0YXJ0aW5nUG9pbnRbaV0ueCwgZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLnkpLCBuZXcgVmVjMkRfMS5WZWMyRChleHBvcnRzLnN0YXJ0aW5nUG9pbnRbaV0ueCwgZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLnkpLCBuZXcgVmVjMkRfMS5WZWMyRChleHBvcnRzLnN0YXJ0aW5nUG9pbnRbaV0ueCwgZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLnkpXTtcbiAgICBleHBvcnRzLnBsYXllcltpXS5waHlzLkVDQnAgPSBbbmV3IFZlYzJEXzEuVmVjMkQoZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLngsIGV4cG9ydHMuc3RhcnRpbmdQb2ludFtpXS55KSwgbmV3IFZlYzJEXzEuVmVjMkQoZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLngsIGV4cG9ydHMuc3RhcnRpbmdQb2ludFtpXS55KSwgbmV3IFZlYzJEXzEuVmVjMkQoZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLngsIGV4cG9ydHMuc3RhcnRpbmdQb2ludFtpXS55KSwgbmV3IFZlYzJEXzEuVmVjMkQoZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldLngsIGV4cG9ydHMuc3RhcnRpbmdQb2ludFtpXS55KV07XG4gICAgZXhwb3J0cy5wbGF5ZXJbaV0uZGlmZmljdWx0eSA9IGV4cG9ydHMuY3B1RGlmZmljdWx0eVtpXTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVQbGF5ZXJzKGksIHRhcmdldCkge1xuICAgIGJ1aWxkUGxheWVyT2JqZWN0KGkpO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgKDAsIGRyYXdWZnhfMS5kcmF3VmZ4KSh7XG4gICAgICAgICAgICBuYW1lOiBcImVudHJhbmNlXCIsXG4gICAgICAgICAgICBwb3M6IG5ldyBWZWMyRF8xLlZlYzJEKGFjdGl2ZVN0YWdlXzEuYWN0aXZlU3RhZ2Uuc3RhcnRpbmdQb2ludFswXS54LCBhY3RpdmVTdGFnZV8xLmFjdGl2ZVN0YWdlLnN0YXJ0aW5nUG9pbnRbMF0ueSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgZHJhd1ZmeF8xLmRyYXdWZngpKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW50cmFuY2VcIixcbiAgICAgICAgICAgIHBvczogbmV3IFZlYzJEXzEuVmVjMkQoZXhwb3J0cy5zdGFydGluZ1BvaW50W2ldWzBdLCBleHBvcnRzLnN0YXJ0aW5nUG9pbnRbaV1bMV0pXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0R2FtZSgpIHtcbiAgICAoMCwgYWN0aXZlU3RhZ2VfMS5zZXRWc1N0YWdlKShleHBvcnRzLnN0YWdlU2VsZWN0KTtcbiAgICAoMCwgc3RhZ2VyZW5kZXJfMS5zZXRCYWNrZ3JvdW5kVHlwZSkoTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKSk7XG4gICAgY2hhbmdlR2FtZW1vZGUoMyk7XG4gICAgKDAsIHZmeFF1ZXVlXzEucmVzZXRWZnhRdWV1ZSkoKTtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDQ7IG4rKykge1xuICAgICAgICBpZiAoZXhwb3J0cy5wbGF5ZXJUeXBlW25dID4gLTEpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVQbGF5ZXJzKG4sIGZhbHNlKTtcbiAgICAgICAgICAgICgwLCByZW5kZXJfMS5yZW5kZXJQbGF5ZXIpKG4pO1xuICAgICAgICAgICAgZXhwb3J0cy5wbGF5ZXJbbl0uaW5DU1MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0cy52ZXJzdXNNb2RlKSB7XG4gICAgICAgICAgICBleHBvcnRzLnBsYXllcltuXS5zdG9ja3MgPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMubWF0Y2hUaW1lciA9IDQ4MDtcbiAgICBleHBvcnRzLnN0YXJ0VGltZXIgPSAxLjU7XG4gICAgZXhwb3J0cy5zdGFydGluZyA9IHRydWU7XG4gICAgbXVzaWNfMS5NdXNpY01hbmFnZXIuc3RvcFdoYXRpc1BsYXlpbmcoKTtcbiAgICBzd2l0Y2ggKGV4cG9ydHMuc3RhZ2VTZWxlY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbXVzaWNfMS5NdXNpY01hbmFnZXIucGxheUJhdHRsZUZpZWxkTG9vcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIG11c2ljXzEuTXVzaWNNYW5hZ2VyLnBsYXl5U3RvcnlMb29wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbXVzaWNfMS5NdXNpY01hbmFnZXIucGxheXBTdGFkaXVtTG9vcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIG11c2ljXzEuTXVzaWNNYW5hZ2VyLnBsYXlEcmVhbUxhbmRMb29wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgbXVzaWNfMS5NdXNpY01hbmFnZXIucGxheWZpbmFsZExvb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBtdXNpY18xLk11c2ljTWFuYWdlci5wbGF5Zm9kTG9vcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgKDAsIGRyYXdWZnhfMS5kcmF3VmZ4KSh7XG4gICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgcG9zOiBuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKVxuICAgIH0pO1xuICAgIGV4cG9ydHMuZmluZGluZ1BsYXllcnMgPSBmYWxzZTtcbiAgICBleHBvcnRzLnBsYXlpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5kR2FtZShpbnB1dCkge1xuICAgIGV4cG9ydHMuZ2FtZUVuZCA9IGZhbHNlO1xuICAgICgwLCByZW5kZXJfMS5yZXNldExvc3RTdG9ja1F1ZXVlKSgpO1xuICAgICgwLCBoaXREZXRlY3Rpb25fMS5zZXRQaGFudG9uUXVldWUpKFtdKTtcbiAgICAoMCwgYXJ0aWNsZV8xLnJlc2V0QUFydGljbGVzKSgpO1xuICAgIG11c2ljXzEuTXVzaWNNYW5hZ2VyLnN0b3BXaGF0aXNQbGF5aW5nKCk7XG4gICAgY2hhbmdlVm9sdW1lKG11c2ljXzEuTXVzaWNNYW5hZ2VyLCBhdWRpb21lbnVfMS5tYXN0ZXJWb2x1bWVbMV0sIDEpO1xuICAgIGV4cG9ydHMucGxheWluZyA9IGZhbHNlO1xuICAgIGNsZWFyU2NyZWVuKCk7XG4gICAgKDAsIHN0YWdlcmVuZGVyXzEuZHJhd1N0YWdlKSgpO1xuICAgICgwLCBjc3NfMi5zZXRUb2tlblBvc1NuYXBUb0NoYXIpKDApO1xuICAgICgwLCBjc3NfMi5zZXRUb2tlblBvc1NuYXBUb0NoYXIpKDEpO1xuICAgICgwLCBjc3NfMi5zZXRUb2tlblBvc1NuYXBUb0NoYXIpKDIpO1xuICAgICgwLCBjc3NfMi5zZXRUb2tlblBvc1NuYXBUb0NoYXIpKDMpO1xuICAgIGlmIChleHBvcnRzLmdhbWVNb2RlID09IDMpIHtcbiAgICAgICAgY2hhbmdlR2FtZW1vZGUoMik7XG4gICAgICAgIG11c2ljXzEuTXVzaWNNYW5hZ2VyLnBsYXlNZW51TG9vcCgpO1xuICAgICAgICBleHBvcnRzLnBhdXNlID0gW1t0cnVlLCB0cnVlXSwgW3RydWUsIHRydWVdLCBbdHJ1ZSwgdHJ1ZV0sIFt0cnVlLCB0cnVlXV07XG4gICAgICAgIGV4cG9ydHMuZnJhbWVBZHZhbmNlID0gW1xuICAgICAgICAgICAgW3RydWUsIHRydWVdLFxuICAgICAgICAgICAgW3RydWUsIHRydWVdLFxuICAgICAgICAgICAgW3RydWUsIHRydWVdLFxuICAgICAgICAgICAgW3RydWUsIHRydWVdXG4gICAgICAgIF07XG4gICAgICAgIGV4cG9ydHMuZmluZGluZ1BsYXllcnMgPSB0cnVlO1xuICAgICAgICBwb3NpdGlvblBsYXllcnNJbkNTUygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMucGxheWVyVHlwZVtpXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMucGxheWVyW2ldLmFjdGlvblN0YXRlID09IFwiRlVSQUZVUkFcIikge1xuICAgICAgICAgICAgICAgICAgICBzZnhfMS5zb3VuZHMuZnVyYWxvb3Auc3RvcChleHBvcnRzLnBsYXllcltpXS5mdXJhTG9vcElEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9pbnB1dFtpXVswXS5hID0gdHJ1ZTsgLy8gZG9cbiAgICAgICAgICAgICAgICAvL2lucHV0W2ldWzFdLmEgPSB0cnVlOyAvLyBub3RcbiAgICAgICAgICAgICAgICBleHBvcnRzLnBsYXllcltpXS5pbkNTUyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5wbGF5ZXJbaV0ucGh5cy5mYWNlID0gMTtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9IFwiV0FJVFwiO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMucGxheWVyW2ldLnRpbWVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaEdhbWUoaW5wdXQpIHtcbiAgICBleHBvcnRzLmdhbWVFbmQgPSB0cnVlO1xuICAgIGV4cG9ydHMucGxheWluZyA9IGZhbHNlO1xuICAgIGV4cG9ydHMuZmcyLnNhdmUoKTtcbiAgICBleHBvcnRzLmZnMi50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgIHZhciB0ZXh0ID0gXCJHYW1lIVwiO1xuICAgIHZhciBzaXplID0gMzAwO1xuICAgIHZhciB0ZXh0U2NhbGUgPSAxO1xuICAgIHZhciB0ZXh0R3JhZCA9IGV4cG9ydHMuZmcyLmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDIwMCwgMCwgNTIwKTtcbiAgICBpZiAoZXhwb3J0cy5tYXRjaFRpbWVyIDw9IDApIHtcbiAgICAgICAgdGV4dCA9IFwiVGltZSFcIjtcbiAgICAgICAgc2Z4XzEuc291bmRzLnRpbWUucGxheSgpO1xuICAgICAgICB0ZXh0R3JhZC5hZGRDb2xvclN0b3AoMCwgXCJibGFja1wiKTtcbiAgICAgICAgdGV4dEdyYWQuYWRkQ29sb3JTdG9wKDAuNSwgXCJibGFja1wiKTtcbiAgICAgICAgdGV4dEdyYWQuYWRkQ29sb3JTdG9wKDAuNywgXCJyZ2IoMjEsIDUxLCAxODApXCIpO1xuICAgICAgICB0ZXh0R3JhZC5hZGRDb2xvclN0b3AoMSwgXCJyZ2IoNzEsIDk0LCAyNTApXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2Z4XzEuc291bmRzLmdhbWUucGxheSgpO1xuICAgICAgICB0ZXh0R3JhZC5hZGRDb2xvclN0b3AoMCwgXCJibGFja1wiKTtcbiAgICAgICAgdGV4dEdyYWQuYWRkQ29sb3JTdG9wKDAuNCwgXCJibGFja1wiKTtcbiAgICAgICAgdGV4dEdyYWQuYWRkQ29sb3JTdG9wKDAuNywgXCJyZ2IoMTY3LCAyNywgNDApXCIpO1xuICAgICAgICB0ZXh0R3JhZC5hZGRDb2xvclN0b3AoMSwgXCJyZ2IoMjU1LCAzMSwgNTIpXCIpO1xuICAgIH1cbiAgICBleHBvcnRzLmZnMi5zY2FsZSgxLCB0ZXh0U2NhbGUpO1xuICAgIGV4cG9ydHMuZmcyLmZpbGxTdHlsZSA9IHRleHRHcmFkO1xuICAgIGV4cG9ydHMuZmcyLmxpbmVXaWR0aCA9IDQwO1xuICAgIGV4cG9ydHMuZmcyLnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xuICAgIGV4cG9ydHMuZmcyLmZvbnQgPSBcIjkwMCBcIiArIHNpemUgKyBcInB4IEFyaWFsXCI7XG4gICAgZXhwb3J0cy5mZzIuc3Ryb2tlVGV4dCh0ZXh0LCA2MDAsIDQ3MCAvIHRleHRTY2FsZSk7XG4gICAgZXhwb3J0cy5mZzIubGluZVdpZHRoID0gMjA7XG4gICAgZXhwb3J0cy5mZzIuc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgZXhwb3J0cy5mZzIuZm9udCA9IFwiOTAwIFwiICsgc2l6ZSArIFwicHggQXJpYWxcIjtcbiAgICBleHBvcnRzLmZnMi5zdHJva2VUZXh0KHRleHQsIDYwMCwgNDcwIC8gdGV4dFNjYWxlKTtcbiAgICBleHBvcnRzLmZnMi5mb250ID0gXCI5MDAgXCIgKyBzaXplICsgXCJweCBBcmlhbFwiO1xuICAgIGV4cG9ydHMuZmcyLmZpbGxUZXh0KHRleHQsIDYwMCwgNDcwIC8gdGV4dFNjYWxlKTtcbiAgICBleHBvcnRzLmZnMi5yZXN0b3JlKCk7XG4gICAgbXVzaWNfMS5NdXNpY01hbmFnZXIuc3RvcFdoYXRpc1BsYXlpbmcoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZW5kR2FtZShpbnB1dCk7XG4gICAgfSwgMjUwMCk7XG59XG5mdW5jdGlvbiBvbkZ1bGxTY3JlZW5DaGFuZ2UoKSB7XG4gICAgdmFyIGZ1bGxzY3JlZW5FbGVtZW50ID0gZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgLy8gaWYgaW4gZnVsbHNjcmVlbiBtb2RlIGZ1bGxzY3JlZW5FbGVtZW50IHdvbid0IGJlIG51bGxcbiAgICB2YXIgY29udCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG9wQnV0dG9uQ29udGFpbmVyXCIpO1xuICAgIHZhciBpY24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLnRvcEJ1dHRvblwiKTtcbiAgICBpZiAoZnVsbHNjcmVlbkVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBjb250LnN0eWxlLnRyYW5zaXRpb24gPSBcIm9wYWNpdHkgMC41cyBsaW5lYXIgMHNcIjtcbiAgICAgICAgY29udC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGljbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGljbltpXS5zdHlsZS5oZWlnaHQgPSBcIjVweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udC5zdHlsZS5oZWlnaHQgPSBcIjVweFwiO1xuICAgICAgICAgICAgcmVzaXplKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNrZXlib2FyZFByb21wdFwiKS5oaWRlKCk7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNrZXlib2FyZENvbnRyb2xzSW1nXCIpLmhpZGUoKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2NvbnRyb2xsZXJTdXBwb3J0Q29udGFpbmVyXCIpLmhpZGUoKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2RlYnVnQnV0dG9uRWRpdFwiKS5lbXB0eSgpLmFwcGVuZChcIk9GRlwiKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2RlYnVnXCIpLmhpZGUoKTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI3BsYXllcnNcIikuaGlkZSgpO1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCJib2R5XCIpLmNzcyhcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICBzaG93SGVhZGVyID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGljbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWNuW2ldLnN0eWxlLmhlaWdodCA9IFwiMjVweFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnQuc3R5bGUuaGVpZ2h0ID0gXCIzMXB4XCI7XG4gICAgICAgIGNvbnQuc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSAwLjVzIGxpbmVhciAwc1wiO1xuICAgICAgICBjb250LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIGlmIChleHBvcnRzLmhvbGlkYXkgPT09IDEpIHtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2xheWVyQnV0dG9uXCIpLmFmdGVyKCc8ZGl2IGlkPVwic25vd0J1dHRvblwiIGNsYXNzPVwiZ2FtZUJ1dHRvblwiIHN0eWxlPVwid2lkdGg6OTBweFwiPjxpbWcgc3JjPVwiYXNzZXRzL2NocmlzdG1hcy9zbm93Zmxha2UucG5nXCIgaGVpZ2h0PTE3IHdpZHRoPTE3IHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2tcIi8+PHAgc3R5bGU9XCJ3aWR0aDozMHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrXCI+PHNwYW4gaWQ9XCJzbm93QnV0dG9uRWRpdFwiPjE1MDwvc3Bhbj48L3A+PGRpdiBpZD1cInNub3dNaW51c1wiIGNsYXNzPVwic25vd0NvbnRyb2xcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6M3B4XCI+PHAgc3R5bGU9XCJwYWRkaW5nOjA7Zm9udC1zaXplOjIwcHhcIj4tPC9wPjwvZGl2PjxkaXYgaWQ9XCJzbm93UGx1c1wiIHN0eWxlPVwiZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzozcHhcIj48cCBzdHlsZT1cInBhZGRpbmc6MDtmb250LXNpemU6MTdweFwiPis8L3A+PC9kaXY+PC9kaXY+Jyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGJ1aWxkUGxheWVyT2JqZWN0KGkpO1xuICAgICAgICBleHBvcnRzLnBsYXllcltpXS5waHlzLmZhY2UgPSAxO1xuICAgICAgICBleHBvcnRzLnBsYXllcltpXS5hY3Rpb25TdGF0ZSA9IFwiV0FJVFwiO1xuICAgIH1cbiAgICBjYWNoZURvbSgpO1xuICAgICgwLCBrZXlib2FyZG1lbnVfMS5nZXRLZXlib2FyZENvb2tpZSkoKTtcbiAgICBnaXZlTWVkYWxzKCk7XG4gICAgKDAsIGF1ZGlvbWVudV8xLmdldEF1ZGlvQ29va2llcykoKTtcbiAgICAoMCwgZ2FtZXBsYXltZW51XzEuZ2V0R2FtZXBsYXlDb29raWVzKSgpO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNrZXlib2FyZEJ1dHRvblwiKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNrZXlib2FyZENvbnRyb2xzSW1nXCIpLnRvZ2dsZSgpO1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIja2V5Ym9hcmRQcm9tcHRcIikuaGlkZSgpO1xuICAgIH0pO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNjb250cm9sbGVyQnV0dG9uXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2NvbnRyb2xsZXJTdXBwb3J0Q29udGFpbmVyXCIpLnRvZ2dsZSgpO1xuICAgIH0pO1xuICAgIGV4cG9ydHMubGF5ZXJzLkJHMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmFja2dyb3VuZDFDYW52YXNcIik7XG4gICAgZXhwb3J0cy5iZzEgPSBleHBvcnRzLmxheWVycy5CRzEuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGV4cG9ydHMubGF5ZXJzLkJHMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmFja2dyb3VuZDJDYW52YXNcIik7XG4gICAgZXhwb3J0cy5iZzIgPSBleHBvcnRzLmxheWVycy5CRzIuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGV4cG9ydHMubGF5ZXJzLkZHMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZm9yZWdyb3VuZDFDYW52YXNcIik7XG4gICAgZXhwb3J0cy5mZzEgPSBleHBvcnRzLmxheWVycy5GRzEuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGV4cG9ydHMubGF5ZXJzLkZHMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZm9yZWdyb3VuZDJDYW52YXNcIik7XG4gICAgZXhwb3J0cy5mZzIgPSBleHBvcnRzLmxheWVycy5GRzIuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGV4cG9ydHMubGF5ZXJzLlVJID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1aUNhbnZhc1wiKTtcbiAgICBleHBvcnRzLnVpID0gZXhwb3J0cy5sYXllcnMuVUkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGV4cG9ydHMuYmcxLmZpbGxTdHlsZSA9IFwicmdiKDAsIDAsIDApXCI7XG4gICAgZXhwb3J0cy5iZzEuZmlsbFJlY3QoMCwgMCwgZXhwb3J0cy5sYXllcnMuQkcxLndpZHRoLCBleHBvcnRzLmxheWVycy5CRzEuaGVpZ2h0KTtcbiAgICBsZXQgbnVsbElucHV0QnVmZmVycyA9IFsoMCwgaW5wdXRfMS5udWxsSW5wdXRzKSgpLCAoMCwgaW5wdXRfMS5udWxsSW5wdXRzKSgpLCAoMCwgaW5wdXRfMS5udWxsSW5wdXRzKSgpLCAoMCwgaW5wdXRfMS5udWxsSW5wdXRzKSgpXTtcbiAgICBnYW1lVGljayhudWxsSW5wdXRCdWZmZXJzKTtcbiAgICByZW5kZXJUaWNrKCk7XG4gICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2VmZmVjdHNCdXR0b25cIikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoKDAsIHZmeF8xLmlzU2hvd1NGWCkoKSkge1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2VmZmVjdHNCdXR0b25FZGl0XCIpLmVtcHR5KCkuYXBwZW5kKFwiT0ZGXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2VmZmVjdHNCdXR0b25FZGl0XCIpLmVtcHR5KCkuYXBwZW5kKFwiT05cIik7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHZmeF8xLnRvZ2dsZVNob3dTRlgpKCk7XG4gICAgfSk7XG4gICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2Zwc0J1dHRvblwiKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmcHMzMCkge1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2Zwc0J1dHRvbkVkaXRcIikuZW1wdHkoKS5hcHBlbmQoXCI2MFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNmcHNCdXR0b25FZGl0XCIpLmVtcHR5KCkuYXBwZW5kKFwiMzBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnBzMzAgXj0gdHJ1ZTtcbiAgICB9KTtcbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjYWxwaGFCdXR0b25cIikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoKDAsIHRyYW5zcGFyZW5jeV8xLmdldFRyYW5zcGFyZW5jeSkoKSkge1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2FscGhhQnV0dG9uRWRpdFwiKS5lbXB0eSgpLmFwcGVuZChcIk9GRlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNhbHBoYUJ1dHRvbkVkaXRcIikuZW1wdHkoKS5hcHBlbmQoXCJPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdHJhbnNwYXJlbmN5XzEudG9nZ2xlVHJhbnNwYXJlbmN5KSgpO1xuICAgIH0pO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNsYXllckJ1dHRvblwiKS5ob3ZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNsYXllckRyb3Bkb3duXCIpLnRvZ2dsZSgpO1xuICAgIH0pO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIi5sYXllclwiKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZCA9ICgwLCBqcXVlcnlfMS5kZWZhdWx0KSh0aGlzKS5hdHRyKFwiaWRcIik7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsYXllcjFcIjpcbiAgICAgICAgICAgICAgICBleHBvcnRzLmxheWVyU3dpdGNoZXMuQkcxIF49IHRydWU7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2JhY2tncm91bmQxQ2FudmFzXCIpLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxheWVyMlwiOlxuICAgICAgICAgICAgICAgIGV4cG9ydHMubGF5ZXJTd2l0Y2hlcy5CRzIgXj0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjYmFja2dyb3VuZDJDYW52YXNcIikudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGF5ZXIzXCI6XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5sYXllclN3aXRjaGVzLkZHMSBePSB0cnVlO1xuICAgICAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNmb3JlZ3JvdW5kMUNhbnZhc1wiKS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsYXllcjRcIjpcbiAgICAgICAgICAgICAgICBleHBvcnRzLmxheWVyU3dpdGNoZXMuRkcyIF49IHRydWU7XG4gICAgICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2ZvcmVncm91bmQyQ2FudmFzXCIpLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxheWVyNVwiOlxuICAgICAgICAgICAgICAgIGV4cG9ydHMubGF5ZXJTd2l0Y2hlcy5VSSBePSB0cnVlO1xuICAgICAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiN1aUNhbnZhc1wiKS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKHRoaXMpLnRvZ2dsZUNsYXNzKFwibGF5ZXJPblwiKTtcbiAgICB9KTtcbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjZGVidWdCdXR0b25cIikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZXhwb3J0cy5zaG93RGVidWcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnYW1lcGFkU1ZHXCIgKyBpKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjZGVidWdCdXR0b25FZGl0XCIpLmVtcHR5KCkuYXBwZW5kKFwiT0ZGXCIpO1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2RlYnVnXCIpLmhpZGUoKTtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNwbGF5ZXJzXCIpLmhpZGUoKTtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcImJvZHlcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAvL3ZhciBtWSA9IE1hdGgubWF4KCgkKHdpbmRvdykuaGVpZ2h0KCktNzUwKS8yLDApO1xuICAgICAgICAgICAgLy8kKFwiI2Rpc3BsYXlcIikuY3NzKFwibWFyZ2luXCIsbVkrXCJweCAwcHggMHB4IFwiK21YK1wicHhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChleHBvcnRzLnBsYXllclR5cGVbaV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBkcmF3R2FtZXBhZF8xLnVwZGF0ZUdhbWVwYWRTVkdDb2xvdXIpKGksIFwiZ2FtZXBhZFNWR1wiICsgaSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZ2FtZXBhZFNWR1wiICsgaSkuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2RlYnVnQnV0dG9uRWRpdFwiKS5lbXB0eSgpLmFwcGVuZChcIk9OXCIpO1xuICAgICAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2RlYnVnXCIpLnNob3coKTtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNwbGF5ZXJzXCIpLnNob3coKTtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcImJvZHlcIikuY3NzKFwib3ZlcmZsb3dcIiwgXCJzY3JvbGxcIik7XG4gICAgICAgICAgICAvL3ZhciBtWSA9IE1hdGgubWF4KCgkKHdpbmRvdykuaGVpZ2h0KCktOTAwKS8yLDApO1xuICAgICAgICAgICAgLy8kKFwiI2Rpc3BsYXlcIikuY3NzKFwibWFyZ2luXCIsbVkrXCIgMHB4IDBweCBweCBcIittWCtcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuc2hvd0RlYnVnIF49IHRydWU7XG4gICAgICAgIHJlc2l6ZSgpO1xuICAgIH0pO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNoaWRlQnV0dG9uXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2hlYWRlclwiKS50b2dnbGUoKTtcbiAgICAgICAgc2hvd0hlYWRlciBePSB0cnVlO1xuICAgICAgICByZXNpemUoKTtcbiAgICB9KTtcbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjZnVsbHNjcmVlbkJ1dHRvblwiKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgoZG9jdW1lbnQuZnVsbFNjcmVlbkVsZW1lbnQgJiYgZG9jdW1lbnQuZnVsbFNjcmVlbkVsZW1lbnQgIT09IG51bGwpIHx8ICghZG9jdW1lbnQubW96RnVsbFNjcmVlbiAmJiAhZG9jdW1lbnQud2Via2l0SXNGdWxsU2NyZWVuKSkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuY2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0Q2FuY2VsRnVsbFNjcmVlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2l6ZSgpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmdWxsc2NyZWVuY2hhbmdlXCIsIG9uRnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsIG9uRnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsIG9uRnVsbFNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIi50b3BCdXR0b25cIikuaG92ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkodGhpcykuY2hpbGRyZW4oXCIuYnV0dG9uRGV0YWlsc1wiKS50b2dnbGUoKTtcbiAgICB9KTtcbiAgICBpZiAobW9iaWxlID09PSBmYWxzZSkge1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIuYnV0dG9uXCIpLmhvdmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KSh0aGlzKS50b2dnbGVDbGFzcyhcImJ1dHRvbmhpZ2hsaWdodGVkXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiLnNvY2lhbG1lZGlhXCIpLmhvdmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KSh0aGlzKS50b2dnbGVDbGFzcyhcInNvY2lhbG1lZGlhaGlnaGxpZ2h0XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiLnN1Z2J0blwiKS5ob3ZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkodGhpcykudG9nZ2xlQ2xhc3MoXCJzdWdidG5oaWdobGlnaHRcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjYXBwc0J1dHRvblwiKS5ob3ZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNhcHBzRHJvcGRvd25cIikuc2hvdygpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIGpxdWVyeV8xLmRlZmF1bHQpKFwiI2FwcHNEcm9wZG93blwiKS5oaWRlKCk7XG4gICAgfSk7XG4gICAgaWYgKGV4cG9ydHMuaG9saWRheSA9PT0gMSkge1xuICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjc25vd01pbnVzXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuc25vd0NvdW50IC09IDIwO1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuc25vd0NvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuc25vd0NvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNzbm93QnV0dG9uRWRpdFwiKS50ZXh0KGV4cG9ydHMuc25vd0NvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBqcXVlcnlfMS5kZWZhdWx0KShcIiNzbm93UGx1c1wiKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBleHBvcnRzLnNub3dDb3VudCArPSAyMDtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLnNub3dDb3VudCA+IDEyMDApIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLnNub3dDb3VudCA9IDEyMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjc25vd0J1dHRvbkVkaXRcIikudGV4dChleHBvcnRzLnNub3dDb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAoMCwganF1ZXJ5XzEuZGVmYXVsdCkoXCIjcmVwbGF5XCIpLmNoYW5nZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGdyYWIgdGhlIGZpcnN0IGltYWdlIGluIHRoZSBGaWxlTGlzdCBvYmplY3QgYW5kIHBhc3MgaXQgdG8gdGhlIGZ1bmN0aW9uXG4gICAgICAgICgwLCByZXBsYXlfMS5sb2FkUmVwbGF5KSh0aGlzLmZpbGVzWzBdKTtcbiAgICB9KTtcbiAgICByZXNpemUoKTtcbn1cbndpbmRvdy5zdGFydCA9IHN0YXJ0O1xuZnVuY3Rpb24gY3VzdG9tRGVhZHpvbmUoKSB7XG4gICAgdGhpcy5scyA9IG5ldyBWZWMyRF8xLlZlYzJEKDAsIDApO1xuICAgIHRoaXMuY3MgPSBuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKTtcbiAgICB0aGlzLmwgPSAwO1xuICAgIHRoaXMuciA9IDA7XG59XG5mdW5jdGlvbiBhZGRTaGluZSh2YWwpIHtcbiAgICBleHBvcnRzLnNoaW5lICs9IHZhbDtcbn1cbmZ1bmN0aW9uIHNldFNoaW5lKHZhbCkge1xuICAgIGV4cG9ydHMuc2hpbmUgPSB2YWw7XG59XG5mdW5jdGlvbiBzZXRGaW5kaW5nUGxheWVycyh2YWwpIHtcbiAgICBleHBvcnRzLmZpbmRpbmdQbGF5ZXJzID0gdmFsO1xufVxuZnVuY3Rpb24gc2V0UGxheWluZyh2YWwpIHtcbiAgICBleHBvcnRzLnBsYXlpbmcgPSB2YWw7XG59XG5mdW5jdGlvbiBzZXRDcmVkaXRzUGxheWVyKHZhbCkge1xuICAgIGV4cG9ydHMuY3JlZGl0c1BsYXllciA9IHZhbDtcbn1cbmZ1bmN0aW9uIHNldENhbGlicmF0aW9uUGxheWVyKHZhbCkge1xuICAgIGV4cG9ydHMuY2FsaWJyYXRpb25QbGF5ZXIgPSB2YWw7XG59XG5jb25zdCBkb20gPSB7fTtcbmZ1bmN0aW9uIGNhY2hlRG9tKCkge1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXG4gICAgICAgIFwibWF0Y2hNaW51dGVzXCIsXG4gICAgICAgIFwibWF0Y2hTZWNvbmRzXCIsXG4gICAgICAgIFwiZ2FtZWxvZ2ljQXZnXCIsXG4gICAgICAgIFwiZ2FtZWxvZ2ljSGlnaFwiLFxuICAgICAgICBcImdhbWVsb2dpY0xvd1wiLFxuICAgICAgICBcImdhbWVsb2dpY1BlYWtcIixcbiAgICAgICAgXCJyZW5kZXJBdmdcIixcbiAgICAgICAgXCJyZW5kZXJIaWdoXCIsXG4gICAgICAgIFwicmVuZGVyTG93XCIsXG4gICAgICAgIFwicmVuZGVyUGVha1wiLFxuICAgIF07XG4gICAgZWxlbWVudElkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBkb21baWRdID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIH0pO1xufVxuO1xuZnVuY3Rpb24gc2V0Q1MoaW5kZXgsIHZhbCkge1xuICAgIGV4cG9ydHMuY2hhcmFjdGVyU2VsZWN0aW9uc1tpbmRleF0gPSB2YWw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main/main.ts\n");

/***/ }),

/***/ "./src/physics/environmentalCollision.ts":
/*!***********************************************!*\
  !*** ./src/physics/environmentalCollision.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// @flow\n/*eslint indent:0*/ // get stuffed\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.smallestECBHeight = exports.smallestECBWidth = exports.additionalOffset = void 0;\nexports.hLineThrough = hLineThrough;\nexports.hLineAt = hLineAt;\nexports.vLineThrough = vLineThrough;\nexports.vLineAt = vLineAt;\nexports.lineThrough = lineThrough;\nexports.outwardsWallNormal = outwardsWallNormal;\nexports.coordinateInterceptParameter = coordinateInterceptParameter;\nexports.coordinateIntercept = coordinateIntercept;\nexports.findCollision = findCollision;\nexports.getSameAndOther = getSameAndOther;\nexports.moveAlongGround = moveAlongGround;\nexports.groundedECBSquashFactor = groundedECBSquashFactor;\nexports.runCollisionRoutine = runCollisionRoutine;\nconst Vec2D_1 = __webpack_require__(/*! ../main/util/Vec2D */ \"./src/main/util/Vec2D.ts\");\nconst linAlg_1 = __webpack_require__(/*! ../main/linAlg */ \"./src/main/linAlg.ts\");\nconst findSmallestWithin_1 = __webpack_require__(/*! ../main/util/findSmallestWithin */ \"./src/main/util/findSmallestWithin.ts\");\nconst solveQuadraticEquation_1 = __webpack_require__(/*! ../main/util/solveQuadraticEquation */ \"./src/main/util/solveQuadraticEquation.ts\");\nconst lineAngle_1 = __webpack_require__(/*! ../main/util/lineAngle */ \"./src/main/util/lineAngle.ts\");\nconst extremePoint_1 = __webpack_require__(/*! ../stages/util/extremePoint */ \"./src/stages/util/extremePoint.ts\");\nconst ecbTransform_1 = __webpack_require__(/*! ../main/util/ecbTransform */ \"./src/main/util/ecbTransform.ts\");\nconst zipLabels_1 = __webpack_require__(/*! ../main/util/zipLabels */ \"./src/main/util/zipLabels.ts\");\nconst drawECB_1 = __webpack_require__(/*! ../main/util/drawECB */ \"./src/main/util/drawECB.ts\");\nexports.additionalOffset = 0.00001;\nexports.smallestECBWidth = 1.95;\nexports.smallestECBHeight = 1.95;\nconst maxRecursion = 6;\n// -----------------------------------------------------\n// various utility functions\n// horizontal line through a point\nfunction hLineThrough(point) {\n    return [point, new Vec2D_1.Vec2D(point.x + 1, point.y)];\n}\n;\nfunction hLineAt(y) {\n    return hLineThrough(new Vec2D_1.Vec2D(0, y));\n}\n// vertical line through a point\nfunction vLineThrough(point) {\n    return [point, new Vec2D_1.Vec2D(point.x, point.y + 1)];\n}\n;\nfunction vLineAt(x) {\n    return vLineThrough(new Vec2D_1.Vec2D(x, 0));\n}\n// either horizontal or vertical line through a point\nfunction lineThrough(point, xOrY) {\n    if (xOrY === \"x\") {\n        return hLineThrough(point);\n    }\n    else {\n        return vLineThrough(point);\n    }\n}\n;\n// next ECB point index, counterclockwise or clockwise (with respect to the ECB)\nfunction turn(number, counterclockwise = true) {\n    if (counterclockwise) {\n        if (number === 3) {\n            return 0;\n        }\n        else {\n            return number + 1;\n        }\n    }\n    else {\n        if (number === 0) {\n            return 3;\n        }\n        else {\n            return number - 1;\n        }\n    }\n}\n;\nfunction outwardsWallNormal(wallBottomOrLeft, wallTopOrRight, wallType) {\n    let sign = 1;\n    switch (wallType) {\n        case \"l\": // left wall\n        case \"g\": // ground\n        case \"b\":\n        case \"d\":\n        case \"p\": // platform\n            sign = -1;\n            break;\n        default: // right wall, ceiling\n            break;\n    }\n    return new Vec2D_1.Vec2D(sign * (wallTopOrRight.y - wallBottomOrLeft.y), sign * (wallBottomOrLeft.x - wallTopOrRight.x));\n}\n// returns true if the vector is moving into the wall, false otherwise\n// need to be careful that arguments 2 and 3 are given in the correct order to get the expected result\nfunction movingInto(vec, wallTopOrRight, wallBottomOrLeft, wallType) {\n    return (0, linAlg_1.dotProd)(vec, outwardsWallNormal(wallBottomOrLeft, wallTopOrRight, wallType)) < 0;\n}\n;\n// returns true if point is to the right of a \"left\" wall, or to the left of a \"right\" wall,\n// and false otherwise\nfunction isOutside(point, wallTopOrRight, wallBottomOrLeft, wallType) {\n    //const vec = new Vec2D ( point.x - wallBottom.x, point.y - wallBottom.y );\n    //return ( !movingInto(vec, wallTop, wallBottom, wallType ) );\n    return !movingInto(new Vec2D_1.Vec2D(point.x - wallBottomOrLeft.x, point.y - wallBottomOrLeft.y), wallTopOrRight, wallBottomOrLeft, wallType);\n}\n;\n// say line1 passes through the two points p1 = (x1,y1), p2 = (x2,y2)\n// and line2 by the two points p3 = (x3,y3) and p4 = (x4,y4)\n// this function returns the parameter t, such that p3 + t*(p4-p3) is the intersection point of the two lines\n// please ensure this function is not called on parallel lines\nfunction coordinateInterceptParameter(line1, line2) {\n    // const x1 = line1[0].x;\n    // const x2 = line1[1].x;\n    // const x3 = line2[0].x;\n    // const x4 = line2[1].x;\n    // const y1 = line1[0].y;\n    // const y2 = line1[1].y;\n    // const y3 = line2[0].y;\n    // const y4 = line2[1].y;\n    // const t = ( (x1-x3)*(y2-y1) + (x1-x2)*(y1-y3) ) / ( (x4-x3)*(y2-y1) + (x2-x1)*(y3-y4) );\n    // return t;\n    return ((line1[0].x - line2[0].x) * (line1[1].y - line1[0].y)\n        + (line1[0].x - line1[1].x) * (line1[0].y - line2[0].y))\n        / ((line2[1].x - line2[0].x) * (line1[1].y - line1[0].y)\n            + (line1[1].x - line1[0].x) * (line2[0].y - line2[1].y));\n}\n;\n// find the intersection of two lines\n// please ensure this function is not called on parallel lines\nfunction coordinateIntercept(line1, line2) {\n    const t = coordinateInterceptParameter(line1, line2);\n    return (new Vec2D_1.Vec2D(line2[0].x + t * (line2[1].x - line2[0].x), line2[0].y + t * (line2[1].y - line2[0].y)));\n}\n;\n// finds whether the ECB impacted a surface on one of its vertices\nfunction runPointSweep(ecb1, ecbp, same, wall, wallType, wallIndex, wallBottomOrLeft, wallTopOrRight, xOrY) {\n    let result = null;\n    const wallAngle = (0, lineAngle_1.lineAngle)([wallBottomOrLeft, wallTopOrRight]);\n    if (wallType === \"l\" || wallType === \"r\") { // left or right wall, need to check top or bottom ECB vertex too\n        const sameResult = pointSweepingCheck(ecb1, ecbp, same, wall, wallType, wallIndex, wallTopOrRight, wallBottomOrLeft, xOrY);\n        const other = (wallType === \"l\" && wallAngle < Math.PI / 2) || (wallType === \"r\" && wallAngle > Math.PI / 2) ? 0 : 2;\n        const otherResult = pointSweepingCheck(ecb1, ecbp, other, wall, wallType, wallIndex, wallTopOrRight, wallBottomOrLeft, xOrY);\n        result = (0, findSmallestWithin_1.pickSmallestSweep)([sameResult, otherResult]);\n    }\n    else if (wallType === \"c\") { // for ceilings, need to check side ECB vertex too\n        const topResult = pointSweepingCheck(ecb1, ecbp, 2, wall, wallType, wallIndex, wallTopOrRight, wallBottomOrLeft, xOrY);\n        const side = wallAngle < Math.PI / 2 ? 3 : 1;\n        const sideResult = pointSweepingCheck(ecb1, ecbp, side, wall, wallType, wallIndex, wallTopOrRight, wallBottomOrLeft, xOrY);\n        result = (0, findSmallestWithin_1.pickSmallestSweep)([topResult, sideResult]);\n    }\n    else { // can only collide grounds on the bottom ECB vertex\n        result = pointSweepingCheck(ecb1, ecbp, same, wall, wallType, wallIndex, wallTopOrRight, wallBottomOrLeft, xOrY);\n    }\n    return result;\n}\n;\nfunction pointSweepingCheck(ecb1, ecbp, pt, wall, wallType, wallIndex, wallTopOrRight, wallBottomOrLeft, xOrY) {\n    let result = null;\n    if (isOutside(ecb1[pt], wallTopOrRight, wallBottomOrLeft, wallType) && !isOutside(ecbp[pt], wallTopOrRight, wallBottomOrLeft, wallType)) {\n        const s = coordinateInterceptParameter(wall, [ecb1[pt], ecbp[pt]]); // need to put wall first\n        if (!(isNaN(s) || s === Infinity || s > 1 || s < 0)) {\n            const intersection = new Vec2D_1.Vec2D((1 - s) * ecb1[pt].x + s * ecbp[pt].x, (1 - s) * ecb1[pt].y + s * ecbp[pt].y);\n            if ((0, Vec2D_1.getXOrYCoord)(intersection, xOrY) <= (0, Vec2D_1.getXOrYCoord)(wallTopOrRight, xOrY) && (0, Vec2D_1.getXOrYCoord)(intersection, xOrY) >= (0, Vec2D_1.getXOrYCoord)(wallBottomOrLeft, xOrY)) {\n                result = { sweep: s, kind: \"surface\", surface: wall, type: wallType, index: wallIndex, pt: pt };\n            }\n        }\n    }\n    return result;\n}\n;\n// second: edge sweeping functions\n// in this next function, we are considering a line that is sweeping,\n// from the initial line 'line1' passing through the two points p1 = (x1,y1), p2 = (x2,y2)\n// to the final line 'line2' passing through the two points p3 = (x3,y3) and p4 = (x4,y4)\n// there are two sweeping parameters: \n//   't', which indicates how far along each line we are\n//   's', which indicates how far we are sweeping between line1 and line2 (the main sweeping parameter)\n// for instance:\n//  s=0 means we are on line1,\n//  s=1 means we are on line2,\n//  t=0 means we are on the line between p1 and p3,\n//  t=1 means we are on the line between p2 and p4\n// this function returns a specific value for each of t and s,\n// which correspond to when the swept line hits the origin O (at coordinates (0,0))\n// if either of the parameters is not between 0 and 1, this function instead returns null\n// see '/doc/linesweep.png' for a visual representation of the situation\nfunction lineSweepParameters(line1, line2, flip = false) {\n    let sign = 1;\n    if (flip) {\n        sign = -1;\n    }\n    const x1 = line1[0].x;\n    const x2 = line1[1].x;\n    const x3 = line2[0].x;\n    const x4 = line2[1].x;\n    const y1 = line1[0].y;\n    const y2 = line1[1].y;\n    const y3 = line2[0].y;\n    const y4 = line2[1].y;\n    const a0 = x2 * y1 - x1 * y2;\n    const a1 = x4 * y1 - 2 * x2 * y1 + 2 * x1 * y2 - x3 * y2 + x2 * y3 - x1 * y4;\n    const a2 = x2 * y1 - x4 * y1 - x1 * y2 + x3 * y2 - x2 * y3 + x4 * y3 + x1 * y4 - x3 * y4;\n    // s satisfies the equation:   a0 + a1*s + a2*s^2 = 0\n    const s = (0, solveQuadraticEquation_1.solveQuadraticEquation)(a0, a1, a2, sign);\n    if (s === null || isNaN(s) || s === Infinity || s < 0 || s > 1) {\n        return null; // no real solution\n    }\n    else {\n        const t = (s * (x1 - x3) - x1) / (x2 - x1 + s * (x1 - x2 - x3 + x4));\n        if (isNaN(t) || t === Infinity || t < 0 || t > 1) {\n            return null;\n        }\n        else {\n            return [t, s];\n        }\n    }\n}\n;\n// finds whether the ECB impacted a surface on one of its edges\nfunction runEdgeSweep(ecb1, ecbp, same, wallType, wallLeft, wallRight, wallBottomOrLeft, wallTopOrRight, xOrY, damageType) {\n    let other = 0; // other ECB point\n    let counterclockwise = true; // whether (same ECB point -> other ECB point) is counterclockwise (w.r.t. the ECB)\n    let corner = null;\n    let otherCorner = null;\n    let edgeSweepResult = null;\n    let otherEdgeSweepResult = null;\n    const flip = wallType === \"r\" || wallType === \"c\" ? false : true;\n    // case 1\n    if ((0, Vec2D_1.getXOrYCoord)(ecb1[same], xOrY) > (0, Vec2D_1.getXOrYCoord)(wallTopOrRight, xOrY)) {\n        counterclockwise = !flip;\n        other = turn(same, counterclockwise);\n        if ((0, Vec2D_1.getXOrYCoord)(ecbp[other], xOrY) < (0, Vec2D_1.getXOrYCoord)(wallTopOrRight, xOrY)) {\n            corner = wallTopOrRight;\n        }\n    }\n    // case 2\n    else if ((0, Vec2D_1.getXOrYCoord)(ecb1[same], xOrY) < (0, Vec2D_1.getXOrYCoord)(wallBottomOrLeft, xOrY)) {\n        counterclockwise = flip;\n        other = turn(same, counterclockwise);\n        if ((0, Vec2D_1.getXOrYCoord)(ecbp[other], xOrY) > (0, Vec2D_1.getXOrYCoord)(wallBottomOrLeft, xOrY)) {\n            corner = wallBottomOrLeft;\n        }\n    }\n    if (corner !== null) {\n        // the relevant ECB edge, that might collide with the corner, is the edge between ECB points 'same' and 'other'\n        let interiorECBside = \"l\";\n        if (counterclockwise === false) {\n            interiorECBside = \"r\";\n        }\n        if (!isOutside(corner, ecbp[same], ecbp[other], interiorECBside) && isOutside(corner, ecb1[same], ecb1[other], interiorECBside)) {\n            edgeSweepResult = edgeSweepingCheck(ecb1, ecbp, same, other, counterclockwise, corner, damageType);\n        }\n    }\n    if ((wallType === \"l\" || wallType === \"r\") && (other === 0)) {\n        // if dealing with a wall, we might also want to check the top ECB point for collision if we aren't already doing so\n        let otherCounterclockwise = false; // whether ( same ECB point -> top ECB point) is counterclockwise\n        otherCorner = wallRight;\n        if (wallType === \"l\") {\n            otherCounterclockwise = true;\n            otherCorner = wallLeft;\n        }\n        let otherInteriorECBside = \"l\";\n        if (otherCounterclockwise === false) {\n            otherInteriorECBside = \"r\";\n        }\n        if (!isOutside(otherCorner, ecbp[same], ecbp[2], otherInteriorECBside)\n            && isOutside(otherCorner, ecb1[same], ecb1[2], otherInteriorECBside)) {\n            otherEdgeSweepResult = edgeSweepingCheck(ecb1, ecbp, same, 2, otherCounterclockwise, otherCorner, damageType);\n        }\n    }\n    return (0, findSmallestWithin_1.pickSmallestSweep)([edgeSweepResult, otherEdgeSweepResult]);\n}\n;\n// determines whether the given ECB edge (same--other) has collided with the corner, using the lineSweepParameters function\nfunction edgeSweepingCheck(ecb1, ecbp, same, other, counterclockwise, corner, damageType) {\n    let output = null;\n    // the relevant ECB edge, that might collide with the corner, is the edge between ECB points 'same' and 'other'\n    let interiorECBside = \"l\";\n    if (counterclockwise === false) {\n        interiorECBside = \"r\";\n    }\n    if (!isOutside(corner, ecbp[same], ecbp[other], interiorECBside) && isOutside(corner, ecb1[same], ecb1[other], interiorECBside)) {\n        // we sweep a line,\n        // starting from the relevant ECB1 edge, and ending at the relevant ECBp edge,\n        // and figure out where this would intersect the corner\n        // first we recenter everything around the corner,\n        // as the 'lineSweepParameters' function calculates collision with respect to the origin\n        const recenteredECB1Edge = [new Vec2D_1.Vec2D(ecb1[same].x - corner.x, ecb1[same].y - corner.y),\n            new Vec2D_1.Vec2D(ecb1[other].x - corner.x, ecb1[other].y - corner.y)];\n        const recenteredECBpEdge = [new Vec2D_1.Vec2D(ecbp[same].x - corner.x, ecbp[same].y - corner.y),\n            new Vec2D_1.Vec2D(ecbp[other].x - corner.x, ecbp[other].y - corner.y)];\n        // in the line sweeping, some tricky orientation checks show that a minus sign is required precisely in the counterclockwise case\n        // this is what the third argument to 'lineSweepParameters' corresponds to\n        const lineSweepResult = lineSweepParameters(recenteredECB1Edge, recenteredECBpEdge, counterclockwise);\n        if (lineSweepResult !== null) {\n            const [t, s] = lineSweepResult;\n            const angularParameter = getAngularParameter(t, same, other);\n            output = { kind: \"corner\", corner: corner, sweep: s, angular: angularParameter, damageType: damageType };\n        }\n    }\n    return output;\n}\n;\n// this function finds the first collision that happens as the old ECB moves to the projected ECB\n// the sweeping parameter s corresponds to the location of this first collision\n// terminology in the comments: a wall is a segment with an inside and an outside (could be a ground or ceiling )\n// which is contained in an infinite line, extending both ways, which also has an inside and an outside\nfunction findCollision(ecb1, ecbp, labelledSurface) {\n    // STANDING ASSUMPTIONS\n    // the ECB can only collide a ground/platform surface on its bottom point (or a bottom edge)\n    // the ECB can only collide a ceiling surface on a top or side point (or a top edge)\n    // the ECB cannot collide a left wall on its left vertex\n    // the ECB cannot collide a right wall on its right vertex\n    // walls and corners push out horizontally, grounds/ceilings/platforms push out vertically\n    const [wall, [wallType, wallIndex]] = labelledSurface;\n    const damageType = wall[2] !== undefined ? wall[2].damageType : null;\n    // start defining useful constants/variables\n    const wallTop = (0, extremePoint_1.extremePoint)(wall, \"t\");\n    const wallBottom = (0, extremePoint_1.extremePoint)(wall, \"b\");\n    const wallLeft = (0, extremePoint_1.extremePoint)(wall, \"l\");\n    const wallRight = (0, extremePoint_1.extremePoint)(wall, \"r\");\n    // right wall by default\n    let wallTopOrRight = wallTop;\n    let wallBottomOrLeft = wallBottom;\n    let same = 3;\n    let xOrY = \"y\";\n    let isPlatform = false;\n    switch (wallType) {\n        case \"l\": // left wall\n            same = 1;\n            break;\n        case \"p\": // platform\n            isPlatform = true;\n        case \"g\": // ground\n            same = 0;\n            wallTopOrRight = wallRight;\n            wallBottomOrLeft = wallLeft;\n            xOrY = \"x\";\n            break;\n        case \"c\": // ceiling\n            same = 2;\n            wallTopOrRight = wallRight;\n            wallBottomOrLeft = wallLeft;\n            xOrY = \"x\";\n            break;\n        default: // right wall by default\n            break;\n    }\n    // first check if player ECB was even near the wall\n    if ((ecbp[0].y > wallTop.y && ecb1[0].y > wallTop.y) // player ECB stayed above the wall\n        || (ecbp[2].y < wallBottom.y && ecb1[2].y < wallBottom.y) // played ECB stayed below the wall\n        || (ecbp[3].x > wallRight.x && ecb1[3].x > wallRight.x) // player ECB stayed to the right of the wall\n        || (ecbp[1].x < wallLeft.x && ecb1[1].x < wallLeft.x) // player ECB stayed to the left of the wall\n    ) {\n        return null;\n    }\n    else {\n        // if the surface is a platform, and the bottom ECB point is below the platform, we shouldn't do anything\n        if (isPlatform) {\n            if (!isOutside(ecb1[same], wallTopOrRight, wallBottomOrLeft, wallType)) {\n                return null;\n            }\n        }\n        const closestEdgeCollision = runEdgeSweep(ecb1, ecbp, same, wallType, wallLeft, wallRight, wallBottomOrLeft, wallTopOrRight, xOrY, damageType);\n        const closestPointCollision = runPointSweep(ecb1, ecbp, same, wall, wallType, wallIndex, wallBottomOrLeft, wallTopOrRight, xOrY, damageType);\n        let finalCollision = null;\n        // if we have only one collision type (point/edge), take that one\n        if (closestEdgeCollision === null) {\n            finalCollision = closestPointCollision;\n        }\n        else if (closestPointCollision === null) {\n            finalCollision = closestEdgeCollision;\n        }\n        // otherwise choose the collision with smallest sweeping parameter\n        else if (closestEdgeCollision.sweep > closestPointCollision.sweep) {\n            finalCollision = closestPointCollision;\n        }\n        else {\n            finalCollision = closestEdgeCollision;\n        }\n        return finalCollision;\n    }\n}\n;\n// this function finds the first (non-ignored) collision as the ECB1 moves to the ECBp\nfunction findClosestCollision(ecb1, ecbp, labelledSurfaces) {\n    const touchingData = [null]; // initialise list of new collisions\n    const collisionData = labelledSurfaces.map((labelledSurface) => findCollision(ecb1, ecbp, labelledSurface));\n    for (let i = 0; i < collisionData.length; i++) {\n        const collisionDatum = collisionData[i];\n        if (collisionDatum !== null) {\n            if (collisionDatum.kind === \"surface\") {\n                touchingData.push({\n                    sweep: collisionDatum.sweep, object: {\n                        kind: \"surface\",\n                        surface: collisionDatum.surface,\n                        type: collisionDatum.type,\n                        index: collisionDatum.index,\n                        pt: collisionDatum.pt\n                    }\n                });\n            }\n            else if (collisionDatum.kind === \"corner\") {\n                touchingData.push({\n                    sweep: collisionDatum.sweep, object: {\n                        kind: \"corner\",\n                        corner: collisionDatum.corner,\n                        angular: collisionDatum.angular,\n                        damageType: collisionDatum.damageType\n                    }\n                });\n            }\n        }\n    }\n    return (0, findSmallestWithin_1.pickSmallestSweep)(touchingData);\n}\n;\nfunction resolveECB(ecb1, ecbp, playerStatusInfo, labelledSurfaces) {\n    return runSlideRoutine(ecb1, ecbp, ecbp, playerStatusInfo, labelledSurfaces, null, {\n        type: null,\n        angular: null\n    }, false, true, 0);\n}\nfunction runSlideRoutine(srcECB, tgtECB, ecbp, playerStatusInfo, labelledSurfaces, oldTouchingDatum, slidingAgainst, squashed, final, recursionCounter) {\n    let output;\n    if (recursionCounter > maxRecursion) {\n        console.log(\"'runSlideRoutine': excessive recursion, aborting.\");\n        (0, drawECB_1.drawECB)(srcECB, \"#286ee0\");\n        (0, drawECB_1.drawECB)(tgtECB, \"#f49930\");\n        (0, drawECB_1.drawECB)(ecbp, \"#fff9ad\");\n        output = { ecb: srcECB, touching: null, squashed: squashed };\n    }\n    else {\n        const slideDatum = slideECB(srcECB, tgtECB, labelledSurfaces, slidingAgainst, playerStatusInfo);\n        let newECBp = ecbp;\n        if (slideDatum.event === \"end\") {\n            output = { ecb: slideDatum.finalECB, touching: slideDatum.touching, squashed: squashed };\n        }\n        else if (slideDatum.event === \"continue\") {\n            if (final) {\n                output = { ecb: tgtECB, touching: oldTouchingDatum, squashed: squashed };\n            }\n            else {\n                newECBp = updateECBp(srcECB, tgtECB, ecbp, slidingAgainst.type, 0);\n                output = runSlideRoutine(tgtECB, newECBp, newECBp, playerStatusInfo, labelledSurfaces, oldTouchingDatum, slidingAgainst, squashed, true, recursionCounter + 1);\n            }\n        }\n        else { // slideDatum.event === \"transfer\" || slideDatum.event === \"squash\"\n            const newSrcECB = slideDatum.midECB;\n            const slideObject = slideDatum.object;\n            let newTouchingDatum;\n            let angular;\n            let newFinal;\n            let newTgtECB;\n            let newSlidingType = null;\n            let same;\n            let other;\n            if (slideObject.kind === \"surface\") {\n                const surface = slideObject.surface;\n                const surfaceType = slideObject.type;\n                if (surfaceType === \"l\" || surfaceType === \"r\" || surfaceType === \"c\") {\n                    newSlidingType = surfaceType;\n                }\n                same = surfaceType === \"l\" ? 1 : 3;\n                angular = slideObject.pt;\n                newECBp = updateECBp(srcECB, slideDatum.midECB, ecbp, newSlidingType, same);\n                newTouchingDatum = { kind: \"surface\", type: surfaceType, index: slideObject.index, pt: angular };\n                [newTgtECB, newFinal] = findNextTargetFromSurface(newSrcECB, newECBp, surface, surfaceType, angular);\n            }\n            else {\n                const corner = slideObject.corner;\n                angular = slideObject.angular;\n                if (angular < 2 && angular > 0) {\n                    newSlidingType = \"l\";\n                }\n                else if (angular > 2) {\n                    newSlidingType = \"r\";\n                }\n                [same, other] = getSameAndOther(angular);\n                newECBp = updateECBp(srcECB, slideDatum.midECB, ecbp, newSlidingType, same);\n                [newTgtECB, newFinal] = findNextTargetFromCorner(newSrcECB, newECBp, corner, angular);\n                newTouchingDatum = { kind: \"corner\", angular: angular };\n            }\n            if (slideDatum.event === \"transfer\") {\n                output = runSlideRoutine(newSrcECB, newTgtECB, newECBp, playerStatusInfo, labelledSurfaces, newTouchingDatum, {\n                    type: newSlidingType,\n                    angular: angular\n                }, squashed, newFinal, recursionCounter + 1);\n            }\n            else {\n                const otherTgtECB = slideDatum.tgtECB;\n                const [squashTgtECB, abort] = agreeOnTargetECB(newSrcECB, otherTgtECB, newTgtECB, newECBp, same, playerStatusInfo.grounded);\n                if (abort) {\n                    output = { ecb: srcECB, touching: oldTouchingDatum, squashed: squashed };\n                }\n                else {\n                    output = runSlideRoutine(newSrcECB, squashTgtECB, newECBp, playerStatusInfo, labelledSurfaces, newTouchingDatum, {\n                        type: newSlidingType,\n                        angular: angular\n                    }, true, newFinal && final, recursionCounter + 1);\n                }\n            }\n        }\n    }\n    return output;\n}\n;\n// this function figures out if we can move the ECB, from the source ECB to the target ECB\nfunction slideECB(srcECB, tgtECB, labelledSurfaces, slidingAgainst, playerStatusInfo) {\n    let output;\n    // figure our whether a collision occured while moving srcECB -> tgtECB\n    const touchingDatum = findClosestCollision(srcECB, tgtECB, labelledSurfaces);\n    if (touchingDatum === null) {\n        //console.log(\"'slideECB': sliding.\");\n        output = { event: \"continue\" };\n    }\n    else {\n        const s = touchingDatum.sweep;\n        const r = Math.max(0, s - exports.additionalOffset / 10); // to account for floating point errors\n        const midECB = (0, ecbTransform_1.interpolateECB)(srcECB, tgtECB, r);\n        const collisionObject = touchingDatum.object;\n        // ------------------------------------------------------------------------------------------------------------------------------\n        // damaging objects cause premature end to sliding\n        let damageType = null;\n        if (!playerStatusInfo.immune) {\n            if (collisionObject.kind === \"surface\") {\n                const surfaceProperties = collisionObject.surface[2];\n                if (surfaceProperties !== null && surfaceProperties !== undefined) {\n                    damageType = surfaceProperties.damageType;\n                }\n            }\n            else if (collisionObject.kind === \"corner\") {\n                damageType = collisionObject.damageType;\n            }\n        }\n        if (damageType !== null && damageType !== undefined) {\n            if (collisionObject.kind === \"surface\") {\n                //console.log(\"'slideECB': sliding interrupted by collision with damaging surface.\");\n                output = {\n                    event: \"end\",\n                    finalECB: midECB,\n                    touching: {\n                        kind: \"surface\",\n                        type: collisionObject.type,\n                        index: collisionObject.index,\n                        pt: collisionObject.pt,\n                        damageType: damageType\n                    }\n                };\n            }\n            else {\n                //console.log(\"'slideECB': sliding interrupted by collision with damaging corner.\");\n                output = {\n                    event: \"end\",\n                    finalECB: midECB,\n                    touching: {\n                        kind: \"corner\",\n                        angular: collisionObject.angular,\n                        damageType: damageType\n                    }\n                };\n            }\n        }\n        // ------------------------------------------------------------------------------------------------------------------------------\n        else if (slidingAgainst.type === null) {\n            if (collisionObject.kind === \"surface\") {\n                if (collisionObject.type === \"g\" || collisionObject.type === \"p\") {\n                    //console.log(\"'slideECB': sliding interrupted by landing.\");\n                    output = {\n                        event: \"end\",\n                        finalECB: midECB,\n                        touching: {\n                            kind: \"surface\",\n                            type: collisionObject.type,\n                            index: collisionObject.index,\n                            pt: collisionObject.pt\n                        }\n                    };\n                }\n                else {\n                    //console.log(\"'slideECB': beginning slide on surface.\");\n                    output = {\n                        event: \"transfer\",\n                        midECB: midECB,\n                        object: {\n                            kind: \"surface\",\n                            surface: collisionObject.surface,\n                            type: collisionObject.type,\n                            pt: collisionObject.pt,\n                            index: collisionObject.index\n                        }\n                    };\n                }\n            }\n            else {\n                //console.log(\"'slideECB': beginning slide on corner.\");\n                output = {\n                    event: \"transfer\",\n                    midECB: midECB,\n                    object: {\n                        kind: \"corner\",\n                        corner: collisionObject.corner,\n                        angular: collisionObject.angular\n                    }\n                };\n            }\n        }\n        else {\n            const slidingType = slidingAgainst.type;\n            if (collisionObject.kind === \"surface\") {\n                const surfaceType = collisionObject.type;\n                if (surfaceType === slidingType) {\n                    //console.log(\"'slideECB': transferring slide to new surface.\");\n                    output = {\n                        event: \"transfer\",\n                        midECB: midECB,\n                        object: {\n                            kind: \"surface\",\n                            surface: collisionObject.surface,\n                            type: collisionObject.type,\n                            pt: collisionObject.pt,\n                            index: collisionObject.index\n                        }\n                    };\n                }\n                else if (slidingType === \"c\" || surfaceType === \"c\" || surfaceType === \"g\" || surfaceType === \"p\") {\n                    // no way to continue when one of the involved surfaces is a ceiling or a ground\n                    //console.log(\"'slideECB': interrupting sliding because of conflicting surface collision.\");\n                    output = {\n                        event: \"end\",\n                        finalECB: midECB,\n                        touching: {\n                            kind: \"surface\",\n                            type: collisionObject.type,\n                            index: collisionObject.index,\n                            pt: collisionObject.pt\n                        }\n                    };\n                }\n                else {\n                    //console.log(\"'slideECB': beginning ECB squashing because of conflicting horizontal surface pushout.\");\n                    output = {\n                        event: \"squash\",\n                        midECB: midECB,\n                        tgtECB: tgtECB,\n                        object: collisionObject,\n                        pt: collisionObject.pt\n                    };\n                }\n            }\n            else {\n                const angularParameter = collisionObject.angular;\n                const side = getSameAndOther(angularParameter)[0];\n                if (slidingType === \"c\") {\n                    //console.log(\"'slideECB': interrupting sliding because of conflicting corner collision.\");\n                    output = {\n                        event: \"end\",\n                        finalECB: midECB,\n                        touching: {\n                            kind: \"corner\",\n                            angular: angularParameter\n                        }\n                    };\n                }\n                else if (slidingType === null\n                    || (side === 3 && slidingType === \"r\")\n                    || (side === 1 && slidingType === \"l\")) {\n                    //console.log(\"'slideECB': transferring slide to new corner.\");\n                    output = {\n                        event: \"transfer\",\n                        midECB: midECB, object: {\n                            kind: \"corner\",\n                            corner: collisionObject.corner,\n                            angular: angularParameter\n                        }\n                    };\n                }\n                else {\n                    //console.log(\"'slideECB': beginning ECB squashing because of conflicting horizontal corner pushout.\");\n                    output = {\n                        event: \"squash\",\n                        midECB: midECB,\n                        tgtECB: tgtECB,\n                        side: side,\n                        object: collisionObject\n                    };\n                }\n            }\n        }\n    }\n    return output;\n}\n;\nfunction findNextTargetFromSurface(srcECB, ecbp, wall, wallType, pt) {\n    let wallForward;\n    let s = 1;\n    let tgtECB = ecbp;\n    let pushout = 0;\n    let final = true;\n    const sign = (wallType === \"l\" || wallType === \"c\") ? -1 : 1;\n    const additionalPushout = sign * exports.additionalOffset;\n    const xOrY = (wallType === \"l\" || wallType === \"r\") ? \"x\" : \"y\";\n    if (wallType === \"c\") {\n        const wallLeft = (0, extremePoint_1.extremePoint)(wall, \"l\");\n        const wallRight = (0, extremePoint_1.extremePoint)(wall, \"r\");\n        if (ecbp[pt].x <= wallRight.x && ecbp[pt].x >= wallLeft.x) {\n            const intercept = coordinateIntercept(vLineThrough(ecbp[pt]), wall);\n            pushout = intercept.y - ecbp[pt].y;\n        }\n        else {\n            wallForward = ecbp[pt].x < srcECB[pt].x ? wallLeft : wallRight;\n            s = (wallForward.x - srcECB[pt].x) / (ecbp[pt].x - srcECB[pt].x);\n            s = Math.min(Math.max(s, 0), 1);\n            tgtECB = (0, ecbTransform_1.interpolateECB)(srcECB, ecbp, s);\n            pushout = wallForward.y - tgtECB[pt].y;\n        }\n    }\n    else {\n        const wallBottom = (0, extremePoint_1.extremePoint)(wall, \"b\");\n        const wallTop = (0, extremePoint_1.extremePoint)(wall, \"t\");\n        if (ecbp[pt].y <= wallTop.y && ecbp[pt].y >= wallBottom.y) {\n            const intercept = coordinateIntercept(hLineThrough(ecbp[pt]), wall);\n            pushout = intercept.x - ecbp[pt].x;\n        }\n        else {\n            wallForward = ecbp[pt].y < srcECB[pt].y ? wallBottom : wallTop;\n            s = (wallForward.y - srcECB[pt].y) / (ecbp[pt].y - srcECB[pt].y);\n            s = Math.min(Math.max(s, 0), 1);\n            tgtECB = (0, ecbTransform_1.interpolateECB)(srcECB, ecbp, s);\n            pushout = wallForward.x - tgtECB[pt].x;\n        }\n    }\n    if (s < 1 || sign * pushout < 0) {\n        final = false;\n    }\n    tgtECB = (0, ecbTransform_1.moveECB)(tgtECB, (0, Vec2D_1.putXOrYCoord)(pushout + additionalPushout, xOrY));\n    (0, drawECB_1.drawECB)(ecbp, \"#8f54ff\");\n    (0, drawECB_1.drawECB)(tgtECB, \"#35f4ab\");\n    return [tgtECB, final];\n}\n;\nfunction findNextTargetFromCorner(srcECB, ecbp, corner, angularParameter) {\n    const [same, other] = getSameAndOther(angularParameter);\n    const LRSign = (same === 1) ? -1 : 1;\n    const UDSign = (other === 2) ? -1 : 1;\n    const additionalPushout = LRSign * exports.additionalOffset;\n    let tgtECB = ecbp;\n    let s = 1;\n    let pushout = 0;\n    let final = true;\n    if (UDSign * ecbp[same].y < UDSign * corner.y) {\n        s = (corner.y - srcECB[same].y) / (ecbp[same].y - srcECB[same].y);\n        s = Math.min(Math.max(s, 0), 1);\n        tgtECB = (0, ecbTransform_1.interpolateECB)(srcECB, ecbp, s);\n        pushout = corner.x - tgtECB[same].x;\n    }\n    else if (UDSign * ecbp[other].y < UDSign * corner.y) {\n        const intercept = coordinateIntercept(hLineThrough(corner), [ecbp[same], ecbp[other]]);\n        pushout = corner.x - intercept.x + additionalPushout;\n    }\n    else {\n        s = (corner.y - srcECB[other].y) / (ecbp[other].y - srcECB[other].y);\n        s = Math.min(Math.max(s, 0), 1);\n        tgtECB = (0, ecbTransform_1.interpolateECB)(srcECB, ecbp, s);\n        pushout = corner.x - tgtECB[other].x;\n    }\n    if (s < 1 || LRSign * pushout < 0) {\n        final = false;\n    }\n    tgtECB = (0, ecbTransform_1.moveECB)(tgtECB, (0, Vec2D_1.putXOrYCoord)(pushout + additionalPushout, \"x\"));\n    (0, drawECB_1.drawECB)(ecbp, \"#1098c9\");\n    (0, drawECB_1.drawECB)(tgtECB, \"#5cbc12\");\n    return [tgtECB, final];\n}\n;\nfunction updateECBp(startECB, endECB, ecbp, slidingType, pt) {\n    if (slidingType === null) {\n        return ecbp;\n    }\n    else {\n        let xOrY = (slidingType === \"l\" || slidingType === \"r\") ? \"y\" : \"x\";\n        let t;\n        if ((0, Vec2D_1.getXOrYCoord)(ecbp[pt], xOrY) - (0, Vec2D_1.getXOrYCoord)(startECB[pt], xOrY) === 0) {\n            xOrY = xOrY === \"x\" ? \"y\" : \"x\";\n            if ((0, Vec2D_1.getXOrYCoord)(ecbp[pt], xOrY) - (0, Vec2D_1.getXOrYCoord)(startECB[pt], xOrY) === 0) {\n                t = 1;\n            }\n            else {\n                t = ((0, Vec2D_1.getXOrYCoord)(endECB[pt], xOrY) - (0, Vec2D_1.getXOrYCoord)(startECB[pt], xOrY))\n                    / ((0, Vec2D_1.getXOrYCoord)(ecbp[pt], xOrY) - (0, Vec2D_1.getXOrYCoord)(startECB[pt], xOrY));\n            }\n        }\n        else {\n            t = ((0, Vec2D_1.getXOrYCoord)(endECB[pt], xOrY) - (0, Vec2D_1.getXOrYCoord)(startECB[pt], xOrY))\n                / ((0, Vec2D_1.getXOrYCoord)(ecbp[pt], xOrY) - (0, Vec2D_1.getXOrYCoord)(startECB[pt], xOrY));\n        }\n        let midECB;\n        if (t <= 0) {\n            midECB = startECB;\n        }\n        else if (t >= 1) {\n            midECB = ecbp;\n        }\n        else {\n            midECB = (0, ecbTransform_1.interpolateECB)(startECB, ecbp, t);\n        }\n        return [(0, linAlg_1.add)(ecbp[0], (0, linAlg_1.subtract)(endECB[0], midECB[0])),\n            (0, linAlg_1.add)(ecbp[1], (0, linAlg_1.subtract)(endECB[1], midECB[1])),\n            (0, linAlg_1.add)(ecbp[2], (0, linAlg_1.subtract)(endECB[2], midECB[2])),\n            (0, linAlg_1.add)(ecbp[3], (0, linAlg_1.subtract)(endECB[3], midECB[3]))\n        ];\n    }\n}\n;\n// this function gets called when two walls (or corners) are trying to push horizontally in opposite directions\n// this function computes a squashed ECB that will fit in between the two objects that are squeezing it\nfunction agreeOnTargetECB(srcECB, fstTgtECB, sndTgtECB, ecbp, pt, grounded) {\n    let output;\n    const flipPt = pt === 1 ? 3 : 1;\n    const [closestTgtECB, furthestTgtECB, same] = (Math.abs(fstTgtECB[pt].y - srcECB[pt].y) < Math.abs(sndTgtECB[flipPt].y - srcECB[flipPt].y))\n        ? ([fstTgtECB, sndTgtECB, pt])\n        : ([sndTgtECB, fstTgtECB, flipPt]);\n    const diff = same === 1 ? 3 : 1;\n    let otherTgtECB;\n    if (furthestTgtECB[diff].y === srcECB[diff].y) {\n        otherTgtECB = furthestTgtECB;\n    }\n    else {\n        const t = (closestTgtECB[same].y - srcECB[same].y) / (furthestTgtECB[diff].y - srcECB[diff].y);\n        if (t <= 0) {\n            otherTgtECB = srcECB;\n        }\n        else if (t >= 1) {\n            otherTgtECB = furthestTgtECB;\n        }\n        else {\n            otherTgtECB = (0, ecbTransform_1.interpolateECB)(srcECB, furthestTgtECB, t);\n        }\n    }\n    const tgtECB = [new Vec2D_1.Vec2D(0, 0), new Vec2D_1.Vec2D(0, 0), new Vec2D_1.Vec2D(0, 0), new Vec2D_1.Vec2D(0, 0)]; // initialising\n    let abort;\n    let squashFactor = 1;\n    const sign = Math.sign(closestTgtECB[same].x - closestTgtECB[diff].x);\n    // ideally we would now squash the ECB, so that it has side points otherTgtECB[same] and closestTgtECB[diff]\n    // however we can't do that if these points are too close together, or, even worse, have moved past eachother\n    if (Math.abs(otherTgtECB[same].x - closestTgtECB[diff].x) > exports.smallestECBWidth\n        && Math.sign(otherTgtECB[same].x - closestTgtECB[diff].x) === sign) {\n        if (Math.abs(otherTgtECB[same].x - closestTgtECB[diff].x) > Math.abs(closestTgtECB[same].x - closestTgtECB[diff].x)) {\n            abort = false;\n            console.log(\"'agreeOnTargetECB' warning: function called when no squashing was required.\");\n            output = [closestTgtECB, abort];\n        }\n        else {\n            abort = false;\n            squashFactor = (otherTgtECB[same].x - closestTgtECB[diff].x) / (closestTgtECB[same].x - closestTgtECB[diff].x);\n            tgtECB[same] = new Vec2D_1.Vec2D(otherTgtECB[same].x - sign * exports.additionalOffset, otherTgtECB[same].y);\n            tgtECB[diff] = new Vec2D_1.Vec2D(closestTgtECB[diff].x + sign * exports.additionalOffset, closestTgtECB[diff].y);\n            tgtECB[2].y = tgtECB[same].y + squashFactor * (closestTgtECB[2].y - closestTgtECB[same].y);\n            tgtECB[0].y = grounded ? srcECB[0].y : tgtECB[same].y + squashFactor * (closestTgtECB[0].y - closestTgtECB[same].y);\n            tgtECB[2].x = (tgtECB[1].x + tgtECB[3].x) / 2;\n            tgtECB[0].x = (tgtECB[1].x + tgtECB[3].x) / 2;\n            output = [tgtECB, abort];\n        }\n    }\n    else {\n        // can't directly squash, so we need to find the closest allowable height\n        const sameLine = [srcECB[same], otherTgtECB[same]];\n        const diffLine = [srcECB[diff], closestTgtECB[diff]];\n        const offsetDiffLine = [(0, linAlg_1.add)(diffLine[0], new Vec2D_1.Vec2D(sign * exports.smallestECBWidth, 0)),\n            (0, linAlg_1.add)(diffLine[1], new Vec2D_1.Vec2D(sign * exports.smallestECBWidth, 0))];\n        const intercept = coordinateIntercept(sameLine, offsetDiffLine);\n        if (Math.abs(closestTgtECB[same].y - srcECB[same].y) >= Math.abs(intercept.y - srcECB[same].y)) {\n            abort = true;\n            tgtECB[same] = new Vec2D_1.Vec2D(intercept.x + sign * exports.additionalOffset, intercept.y);\n            tgtECB[diff] = new Vec2D_1.Vec2D(intercept.x - sign * exports.smallestECBWidth - sign * exports.additionalOffset, intercept.y);\n            squashFactor = (tgtECB[same].x - tgtECB[diff].x) / (closestTgtECB[same].x - closestTgtECB[diff].x);\n            tgtECB[2].y = tgtECB[same].y + squashFactor * (closestTgtECB[2].y - closestTgtECB[same].y);\n            tgtECB[0].y = grounded ? srcECB[0].y : tgtECB[same].y + squashFactor * (closestTgtECB[0].y - closestTgtECB[same].y);\n            tgtECB[2].x = (tgtECB[1].x + tgtECB[3].x) / 2;\n            tgtECB[0].x = (tgtECB[1].x + tgtECB[3].x) / 2;\n            output = [tgtECB, abort];\n        }\n        else {\n            abort = false;\n            squashFactor = (otherTgtECB[same].x - closestTgtECB[diff].x - 2 * sign * exports.additionalOffset) / (closestTgtECB[same].x - closestTgtECB[diff].x);\n            if (squashFactor >= 1) {\n                output = [closestTgtECB, abort];\n            }\n            else {\n                tgtECB[same] = new Vec2D_1.Vec2D(otherTgtECB[same].x - sign * exports.additionalOffset, otherTgtECB[same].y);\n                tgtECB[diff] = new Vec2D_1.Vec2D(closestTgtECB[diff].x + sign * exports.additionalOffset, closestTgtECB[diff].y);\n                tgtECB[2].y = tgtECB[same].y + squashFactor * (closestTgtECB[2].y - closestTgtECB[same].y);\n                tgtECB[0].y = grounded ? srcECB[0].y : tgtECB[same].y + squashFactor * (closestTgtECB[0].y - closestTgtECB[same].y);\n                tgtECB[2].x = (tgtECB[1].x + tgtECB[3].x) / 2;\n                tgtECB[0].x = (tgtECB[1].x + tgtECB[3].x) / 2;\n                output = [tgtECB, abort];\n            }\n        }\n    }\n    (0, drawECB_1.drawECB)(tgtECB, \"#f9482c\");\n    return output;\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n// convert between angular parameters and \"same/other\" data\nfunction getAngularParameter(t, same, other) {\n    if (same === 3 && other === 0) {\n        return ((1 - t) * 3 + t * 4);\n    }\n    else if (same === 0 && other === 3) {\n        return ((1 - t) * 4 + t * 3);\n    }\n    else {\n        return ((1 - t) * same + t * other);\n    }\n}\n;\nfunction getSameAndOther(a) {\n    if (a < 1) {\n        return [1, 0];\n    }\n    else if (a < 2) {\n        return [1, 2];\n    }\n    else if (a < 3) {\n        return [3, 2];\n    }\n    else {\n        return [3, 0];\n    }\n}\n;\n// ----------------------------------------------------------------------------------------------------------------------------------\n// function to check whether grounded movement is permissible (no low ceilings)\nfunction moveAlongGround(pos, posNext, ecbHeight, ground, ceilings) {\n    if (pos.x === posNext.x) {\n        return null;\n    }\n    else {\n        const dir = posNext.x < pos.x ? \"l\" : \"r\";\n        const groundLeft = (0, extremePoint_1.extremePoint)(ground, \"l\");\n        const groundRight = (0, extremePoint_1.extremePoint)(ground, \"r\");\n        if ((dir === \"l\" && pos.x < groundLeft.x)\n            || (dir === \"r\" && pos.x > groundRight.x)) {\n            return null;\n        }\n        else {\n            const start = dir === \"l\" ? Math.min(pos.x, groundRight.x) : Math.max(pos.x, groundLeft.x);\n            const end = dir === \"l\" ? Math.max(posNext.x, groundLeft.x) : Math.min(posNext.x, groundRight.x);\n            const groundStart = coordinateIntercept(ground, vLineAt(start));\n            const groundEnd = coordinateIntercept(ground, vLineAt(end));\n            let startECB = (0, ecbTransform_1.makeECB)(groundStart, exports.additionalOffset, exports.smallestECBHeight);\n            let endECB = (0, ecbTransform_1.makeECB)(groundEnd, exports.additionalOffset, exports.smallestECBHeight);\n            const labelledCeilings = (0, zipLabels_1.zipLabels)(ceilings, \"c\"); // should not recalculate this every time...\n            let firstCeilingCollision = findClosestCollision(startECB, endECB, labelledCeilings);\n            if (firstCeilingCollision === null) {\n                if (ecbHeight > exports.smallestECBHeight) {\n                    return null;\n                }\n                else {\n                    // do a second collision check, in case the player squeezed themselves into a location they should not have\n                    startECB = (0, ecbTransform_1.makeECB)(groundStart, exports.additionalOffset / 10, ecbHeight);\n                    endECB = (0, ecbTransform_1.makeECB)(groundEnd, exports.additionalOffset / 10, ecbHeight);\n                    firstCeilingCollision = findClosestCollision(startECB, endECB, labelledCeilings);\n                    if (firstCeilingCollision === null || firstCeilingCollision.object.kind === \"corner\") {\n                        return null;\n                    }\n                    else {\n                        const ceiling = firstCeilingCollision.object.surface;\n                        // find where to reposition the player by intersecting the offset ground with the ceiling\n                        const intercept = coordinateIntercept(ceiling, [(0, linAlg_1.add)(groundStart, new Vec2D_1.Vec2D(0, exports.smallestECBHeight)), (0, linAlg_1.add)(groundEnd, new Vec2D_1.Vec2D(0, exports.smallestECBHeight))]);\n                        /*\n                         if ((dir === \"l\" && intercept.x > pos.x) || (dir === \"r\" && intercept.x < pos.x)) {\n                         return pos.x;\n                         }\n                         else {\n                         return intercept.x;\n                         }\n                         */\n                        return intercept.x + (dir === \"l\" ? exports.additionalOffset : -exports.additionalOffset);\n                    }\n                }\n            }\n            else {\n                const s = firstCeilingCollision.sweep;\n                return (1 - s) * pos.x + s * posNext.x + (dir === \"l\" ? exports.additionalOffset : -exports.additionalOffset);\n            }\n        }\n    }\n}\n// ----------------------------------------------------------------------------------------------------------------------------------\n// ECB squashing and re-inflating\n// finds the ECB squash factor for a grounded ECB\nfunction groundedECBSquashFactor(ecbTop, ecbBottom, ceilings) {\n    const ceilingYValues = ceilings.map((ceil) => {\n        if (ecbTop.x < (0, extremePoint_1.extremePoint)(ceil, \"l\").x || ecbTop.x > (0, extremePoint_1.extremePoint)(ceil, \"r\").x) {\n            return null;\n        }\n        else {\n            return coordinateIntercept([ecbBottom, ecbTop], ceil).y;\n        }\n    });\n    const lowestCeilingYValue = (0, findSmallestWithin_1.findSmallestWithin)(ceilingYValues, ecbBottom.y, ecbTop.y);\n    const offset = exports.additionalOffset / 10;\n    if (lowestCeilingYValue === null) {\n        return null;\n    }\n    else {\n        return (Math.max(offset, (lowestCeilingYValue - ecbBottom.y) / (ecbTop.y - ecbBottom.y) - offset));\n    }\n}\n;\n// finds the ECB squash factor by inflating the ECB from the point on the ECB given by the angular parameter t\n// if angular parameter is null, instead inflates the ECB from its center\nfunction inflateECB(ecb, t, focus, relevantSurfaces) {\n    const offset = exports.additionalOffset / 10;\n    const pointlikeECB = [new Vec2D_1.Vec2D(focus.x, focus.y - offset),\n        new Vec2D_1.Vec2D(focus.x + offset, focus.y),\n        new Vec2D_1.Vec2D(focus.x, focus.y + offset),\n        new Vec2D_1.Vec2D(focus.x - offset, focus.y)\n    ];\n    const closestCollision = findClosestCollision(pointlikeECB, ecb, relevantSurfaces);\n    if (closestCollision === null) {\n        return { location: t, factor: 1 };\n    }\n    else {\n        const newLocation = t === null\n            ? closestCollision.object.kind === \"surface\"\n                ? closestCollision.object.pt\n                : closestCollision.object.angular\n            : t;\n        return { location: newLocation, factor: Math.max(exports.additionalOffset, closestCollision.sweep - exports.additionalOffset) }; // ECB angular parameter, sweeping parameter\n    }\n}\nfunction reinflateECB(ecb, position, relevantSurfaces, oldecbSquashDatum, grounded) {\n    let q = 1;\n    const angularParameter = oldecbSquashDatum.location;\n    if (oldecbSquashDatum.factor < 1) {\n        q = 1 / oldecbSquashDatum.factor + exports.additionalOffset / 20;\n        const focus = (0, ecbTransform_1.ecbFocusFromAngularParameter)(ecb, angularParameter);\n        const fullsizeecb = [new Vec2D_1.Vec2D(q * ecb[0].x + (1 - q) * focus.x, q * ecb[0].y + (1 - q) * focus.y),\n            new Vec2D_1.Vec2D(q * ecb[1].x + (1 - q) * focus.x, q * ecb[1].y + (1 - q) * focus.y),\n            new Vec2D_1.Vec2D(q * ecb[2].x + (1 - q) * focus.x, q * ecb[2].y + (1 - q) * focus.y),\n            new Vec2D_1.Vec2D(q * ecb[3].x + (1 - q) * focus.x, q * ecb[3].y + (1 - q) * focus.y)\n        ];\n        const ecbSquashDatum = inflateECB(fullsizeecb, angularParameter, focus, relevantSurfaces);\n        const squashedecb = (0, ecbTransform_1.squashECBAt)(fullsizeecb, { factor: ecbSquashDatum.factor, location: angularParameter });\n        const newPosition = new Vec2D_1.Vec2D(position.x + squashedecb[0].x - ecb[0].x, grounded ? position.y : position.y + squashedecb[0].y - ecb[0].y);\n        const newAngular = ecbSquashDatum.location;\n        (0, drawECB_1.drawECB)(squashedecb, \"#ffff00\");\n        return [newPosition, ecbSquashDatum, squashedecb];\n    }\n    else {\n        return [position, { location: angularParameter, factor: 1 }, ecb];\n    }\n}\n;\n// recall: type PlayerStatusInfo = { grounded :boolean, ignoringPlatforms :boolean, immune :boolean };\n// this function initialises necessary data and then calls the main collision routine loop\nfunction runCollisionRoutine(ecb1, ecbp, position, ecbSquashDatum, playerStatusInfo, stage) {\n    // --------------------------------------------------------------\n    // BELOW: this is recomputed every frame and should be avoided\n    const stageWalls = (0, zipLabels_1.zipLabels)(stage.wallL, \"l\").concat((0, zipLabels_1.zipLabels)(stage.wallR, \"r\"));\n    const stageGrounds = (0, zipLabels_1.zipLabels)(stage.ground, \"g\");\n    const stageCeilings = (0, zipLabels_1.zipLabels)(stage.ceiling, \"c\");\n    const stagePlatforms = (0, zipLabels_1.zipLabels)(stage.platform, \"p\");\n    // ABOVE: this is recomputed every frame and should be avoided\n    // --------------------------------------------------------------\n    const grounded = playerStatusInfo.grounded;\n    let horizIgnore = \"none\"; // ignore no horizontal surfaces by default\n    if (grounded) {\n        horizIgnore = \"all\"; // ignore all horizontal surfaces when grounded\n    }\n    else {\n        horizIgnore = playerStatusInfo.ignoringPlatforms ? \"platforms\" : \"none\";\n    }\n    const allSurfacesMinusPlatforms = stageWalls.concat(stageGrounds).concat(stageCeilings);\n    let relevantSurfaces = [];\n    switch (horizIgnore) {\n        case \"platforms\":\n            relevantSurfaces = stageWalls.concat(stageGrounds).concat(stageCeilings);\n            break;\n        case \"none\":\n        default:\n            relevantSurfaces = stageWalls.concat(stageGrounds).concat(stageCeilings).concat(stagePlatforms);\n            break;\n        case \"all\":\n            relevantSurfaces = stageWalls;\n            break;\n    }\n    const resolution = resolveECB(ecb1, ecbp, playerStatusInfo, relevantSurfaces);\n    const newTouching = resolution.touching;\n    let newECBp = resolution.ecb;\n    const newSquashFactor = resolution.squashed ? Math.min(1, (newECBp[1].x - newECBp[3].x) / (ecbp[1].x - ecbp[3].x))\n        : 1;\n    let newSquashLocation = null;\n    if (newTouching !== null) {\n        if (newTouching.kind === \"surface\") {\n            newSquashLocation = newTouching.pt;\n        }\n        else {\n            newSquashLocation = newTouching.angular;\n        }\n    }\n    let newSquashDatum = { location: newSquashLocation, factor: newSquashFactor };\n    newSquashDatum.factor *= ecbSquashDatum.factor;\n    let newPosition = (0, linAlg_1.subtract)((0, linAlg_1.add)(position, newECBp[0]), ecbp[0]);\n    if (newSquashDatum.factor < 1) {\n        let squashingLocation = null;\n        if (grounded) {\n            squashingLocation = 0;\n        }\n        [newPosition,\n            newSquashDatum,\n            newECBp] = reinflateECB(newECBp, newPosition, allSurfacesMinusPlatforms, { factor: newSquashDatum.factor, location: squashingLocation }, grounded);\n        if (!grounded && newSquashDatum.factor < 1) {\n            // reinflate a second time if it might help\n            [newPosition,\n                newSquashDatum,\n                newECBp] = reinflateECB(newECBp, newPosition, allSurfacesMinusPlatforms, newSquashDatum, false);\n        }\n    }\n    return { position: newPosition, touching: newTouching, squashDatum: newSquashDatum, ecb: newECBp };\n}\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGh5c2ljcy9lbnZpcm9ubWVudGFsQ29sbGlzaW9uLnRzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDL0Usb0JBQW9CO0FBQ3BCLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsb0NBQW9DO0FBQ3BDLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QiwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLG9EQUFvQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyw0Q0FBZ0I7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsOEVBQWlDO0FBQ3RFLGlDQUFpQyxtQkFBTyxDQUFDLHNGQUFxQztBQUM5RSxvQkFBb0IsbUJBQU8sQ0FBQyw0REFBd0I7QUFDcEQsdUJBQXVCLG1CQUFPLENBQUMsc0VBQTZCO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLGtFQUEyQjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQyw0REFBd0I7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsd0RBQXNCO0FBQ2hELHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0hBQXdIO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsMkRBQTJEO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsNERBQTREO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWxlZWxpZ2h0Ly4vc3JjL3BoeXNpY3MvZW52aXJvbm1lbnRhbENvbGxpc2lvbi50cz85MmUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQGZsb3dcbi8qZXNsaW50IGluZGVudDowKi8gLy8gZ2V0IHN0dWZmZWRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc21hbGxlc3RFQ0JIZWlnaHQgPSBleHBvcnRzLnNtYWxsZXN0RUNCV2lkdGggPSBleHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQgPSB2b2lkIDA7XG5leHBvcnRzLmhMaW5lVGhyb3VnaCA9IGhMaW5lVGhyb3VnaDtcbmV4cG9ydHMuaExpbmVBdCA9IGhMaW5lQXQ7XG5leHBvcnRzLnZMaW5lVGhyb3VnaCA9IHZMaW5lVGhyb3VnaDtcbmV4cG9ydHMudkxpbmVBdCA9IHZMaW5lQXQ7XG5leHBvcnRzLmxpbmVUaHJvdWdoID0gbGluZVRocm91Z2g7XG5leHBvcnRzLm91dHdhcmRzV2FsbE5vcm1hbCA9IG91dHdhcmRzV2FsbE5vcm1hbDtcbmV4cG9ydHMuY29vcmRpbmF0ZUludGVyY2VwdFBhcmFtZXRlciA9IGNvb3JkaW5hdGVJbnRlcmNlcHRQYXJhbWV0ZXI7XG5leHBvcnRzLmNvb3JkaW5hdGVJbnRlcmNlcHQgPSBjb29yZGluYXRlSW50ZXJjZXB0O1xuZXhwb3J0cy5maW5kQ29sbGlzaW9uID0gZmluZENvbGxpc2lvbjtcbmV4cG9ydHMuZ2V0U2FtZUFuZE90aGVyID0gZ2V0U2FtZUFuZE90aGVyO1xuZXhwb3J0cy5tb3ZlQWxvbmdHcm91bmQgPSBtb3ZlQWxvbmdHcm91bmQ7XG5leHBvcnRzLmdyb3VuZGVkRUNCU3F1YXNoRmFjdG9yID0gZ3JvdW5kZWRFQ0JTcXVhc2hGYWN0b3I7XG5leHBvcnRzLnJ1bkNvbGxpc2lvblJvdXRpbmUgPSBydW5Db2xsaXNpb25Sb3V0aW5lO1xuY29uc3QgVmVjMkRfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3V0aWwvVmVjMkRcIik7XG5jb25zdCBsaW5BbGdfMSA9IHJlcXVpcmUoXCIuLi9tYWluL2xpbkFsZ1wiKTtcbmNvbnN0IGZpbmRTbWFsbGVzdFdpdGhpbl8xID0gcmVxdWlyZShcIi4uL21haW4vdXRpbC9maW5kU21hbGxlc3RXaXRoaW5cIik7XG5jb25zdCBzb2x2ZVF1YWRyYXRpY0VxdWF0aW9uXzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL3NvbHZlUXVhZHJhdGljRXF1YXRpb25cIik7XG5jb25zdCBsaW5lQW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9tYWluL3V0aWwvbGluZUFuZ2xlXCIpO1xuY29uc3QgZXh0cmVtZVBvaW50XzEgPSByZXF1aXJlKFwiLi4vc3RhZ2VzL3V0aWwvZXh0cmVtZVBvaW50XCIpO1xuY29uc3QgZWNiVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL2VjYlRyYW5zZm9ybVwiKTtcbmNvbnN0IHppcExhYmVsc18xID0gcmVxdWlyZShcIi4uL21haW4vdXRpbC96aXBMYWJlbHNcIik7XG5jb25zdCBkcmF3RUNCXzEgPSByZXF1aXJlKFwiLi4vbWFpbi91dGlsL2RyYXdFQ0JcIik7XG5leHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQgPSAwLjAwMDAxO1xuZXhwb3J0cy5zbWFsbGVzdEVDQldpZHRoID0gMS45NTtcbmV4cG9ydHMuc21hbGxlc3RFQ0JIZWlnaHQgPSAxLjk1O1xuY29uc3QgbWF4UmVjdXJzaW9uID0gNjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2YXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zXG4vLyBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBhIHBvaW50XG5mdW5jdGlvbiBoTGluZVRocm91Z2gocG9pbnQpIHtcbiAgICByZXR1cm4gW3BvaW50LCBuZXcgVmVjMkRfMS5WZWMyRChwb2ludC54ICsgMSwgcG9pbnQueSldO1xufVxuO1xuZnVuY3Rpb24gaExpbmVBdCh5KSB7XG4gICAgcmV0dXJuIGhMaW5lVGhyb3VnaChuZXcgVmVjMkRfMS5WZWMyRCgwLCB5KSk7XG59XG4vLyB2ZXJ0aWNhbCBsaW5lIHRocm91Z2ggYSBwb2ludFxuZnVuY3Rpb24gdkxpbmVUaHJvdWdoKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludCwgbmV3IFZlYzJEXzEuVmVjMkQocG9pbnQueCwgcG9pbnQueSArIDEpXTtcbn1cbjtcbmZ1bmN0aW9uIHZMaW5lQXQoeCkge1xuICAgIHJldHVybiB2TGluZVRocm91Z2gobmV3IFZlYzJEXzEuVmVjMkQoeCwgMCkpO1xufVxuLy8gZWl0aGVyIGhvcml6b250YWwgb3IgdmVydGljYWwgbGluZSB0aHJvdWdoIGEgcG9pbnRcbmZ1bmN0aW9uIGxpbmVUaHJvdWdoKHBvaW50LCB4T3JZKSB7XG4gICAgaWYgKHhPclkgPT09IFwieFwiKSB7XG4gICAgICAgIHJldHVybiBoTGluZVRocm91Z2gocG9pbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZMaW5lVGhyb3VnaChwb2ludCk7XG4gICAgfVxufVxuO1xuLy8gbmV4dCBFQ0IgcG9pbnQgaW5kZXgsIGNvdW50ZXJjbG9ja3dpc2Ugb3IgY2xvY2t3aXNlICh3aXRoIHJlc3BlY3QgdG8gdGhlIEVDQilcbmZ1bmN0aW9uIHR1cm4obnVtYmVyLCBjb3VudGVyY2xvY2t3aXNlID0gdHJ1ZSkge1xuICAgIGlmIChjb3VudGVyY2xvY2t3aXNlKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciAtIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG47XG5mdW5jdGlvbiBvdXR3YXJkc1dhbGxOb3JtYWwod2FsbEJvdHRvbU9yTGVmdCwgd2FsbFRvcE9yUmlnaHQsIHdhbGxUeXBlKSB7XG4gICAgbGV0IHNpZ24gPSAxO1xuICAgIHN3aXRjaCAod2FsbFR5cGUpIHtcbiAgICAgICAgY2FzZSBcImxcIjogLy8gbGVmdCB3YWxsXG4gICAgICAgIGNhc2UgXCJnXCI6IC8vIGdyb3VuZFxuICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICBjYXNlIFwicFwiOiAvLyBwbGF0Zm9ybVxuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIHJpZ2h0IHdhbGwsIGNlaWxpbmdcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZlYzJEXzEuVmVjMkQoc2lnbiAqICh3YWxsVG9wT3JSaWdodC55IC0gd2FsbEJvdHRvbU9yTGVmdC55KSwgc2lnbiAqICh3YWxsQm90dG9tT3JMZWZ0LnggLSB3YWxsVG9wT3JSaWdodC54KSk7XG59XG4vLyByZXR1cm5zIHRydWUgaWYgdGhlIHZlY3RvciBpcyBtb3ZpbmcgaW50byB0aGUgd2FsbCwgZmFsc2Ugb3RoZXJ3aXNlXG4vLyBuZWVkIHRvIGJlIGNhcmVmdWwgdGhhdCBhcmd1bWVudHMgMiBhbmQgMyBhcmUgZ2l2ZW4gaW4gdGhlIGNvcnJlY3Qgb3JkZXIgdG8gZ2V0IHRoZSBleHBlY3RlZCByZXN1bHRcbmZ1bmN0aW9uIG1vdmluZ0ludG8odmVjLCB3YWxsVG9wT3JSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgd2FsbFR5cGUpIHtcbiAgICByZXR1cm4gKDAsIGxpbkFsZ18xLmRvdFByb2QpKHZlYywgb3V0d2FyZHNXYWxsTm9ybWFsKHdhbGxCb3R0b21PckxlZnQsIHdhbGxUb3BPclJpZ2h0LCB3YWxsVHlwZSkpIDwgMDtcbn1cbjtcbi8vIHJldHVybnMgdHJ1ZSBpZiBwb2ludCBpcyB0byB0aGUgcmlnaHQgb2YgYSBcImxlZnRcIiB3YWxsLCBvciB0byB0aGUgbGVmdCBvZiBhIFwicmlnaHRcIiB3YWxsLFxuLy8gYW5kIGZhbHNlIG90aGVyd2lzZVxuZnVuY3Rpb24gaXNPdXRzaWRlKHBvaW50LCB3YWxsVG9wT3JSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgd2FsbFR5cGUpIHtcbiAgICAvL2NvbnN0IHZlYyA9IG5ldyBWZWMyRCAoIHBvaW50LnggLSB3YWxsQm90dG9tLngsIHBvaW50LnkgLSB3YWxsQm90dG9tLnkgKTtcbiAgICAvL3JldHVybiAoICFtb3ZpbmdJbnRvKHZlYywgd2FsbFRvcCwgd2FsbEJvdHRvbSwgd2FsbFR5cGUgKSApO1xuICAgIHJldHVybiAhbW92aW5nSW50byhuZXcgVmVjMkRfMS5WZWMyRChwb2ludC54IC0gd2FsbEJvdHRvbU9yTGVmdC54LCBwb2ludC55IC0gd2FsbEJvdHRvbU9yTGVmdC55KSwgd2FsbFRvcE9yUmlnaHQsIHdhbGxCb3R0b21PckxlZnQsIHdhbGxUeXBlKTtcbn1cbjtcbi8vIHNheSBsaW5lMSBwYXNzZXMgdGhyb3VnaCB0aGUgdHdvIHBvaW50cyBwMSA9ICh4MSx5MSksIHAyID0gKHgyLHkyKVxuLy8gYW5kIGxpbmUyIGJ5IHRoZSB0d28gcG9pbnRzIHAzID0gKHgzLHkzKSBhbmQgcDQgPSAoeDQseTQpXG4vLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBhcmFtZXRlciB0LCBzdWNoIHRoYXQgcDMgKyB0KihwNC1wMykgaXMgdGhlIGludGVyc2VjdGlvbiBwb2ludCBvZiB0aGUgdHdvIGxpbmVzXG4vLyBwbGVhc2UgZW5zdXJlIHRoaXMgZnVuY3Rpb24gaXMgbm90IGNhbGxlZCBvbiBwYXJhbGxlbCBsaW5lc1xuZnVuY3Rpb24gY29vcmRpbmF0ZUludGVyY2VwdFBhcmFtZXRlcihsaW5lMSwgbGluZTIpIHtcbiAgICAvLyBjb25zdCB4MSA9IGxpbmUxWzBdLng7XG4gICAgLy8gY29uc3QgeDIgPSBsaW5lMVsxXS54O1xuICAgIC8vIGNvbnN0IHgzID0gbGluZTJbMF0ueDtcbiAgICAvLyBjb25zdCB4NCA9IGxpbmUyWzFdLng7XG4gICAgLy8gY29uc3QgeTEgPSBsaW5lMVswXS55O1xuICAgIC8vIGNvbnN0IHkyID0gbGluZTFbMV0ueTtcbiAgICAvLyBjb25zdCB5MyA9IGxpbmUyWzBdLnk7XG4gICAgLy8gY29uc3QgeTQgPSBsaW5lMlsxXS55O1xuICAgIC8vIGNvbnN0IHQgPSAoICh4MS14MykqKHkyLXkxKSArICh4MS14MikqKHkxLXkzKSApIC8gKCAoeDQteDMpKih5Mi15MSkgKyAoeDIteDEpKih5My15NCkgKTtcbiAgICAvLyByZXR1cm4gdDtcbiAgICByZXR1cm4gKChsaW5lMVswXS54IC0gbGluZTJbMF0ueCkgKiAobGluZTFbMV0ueSAtIGxpbmUxWzBdLnkpXG4gICAgICAgICsgKGxpbmUxWzBdLnggLSBsaW5lMVsxXS54KSAqIChsaW5lMVswXS55IC0gbGluZTJbMF0ueSkpXG4gICAgICAgIC8gKChsaW5lMlsxXS54IC0gbGluZTJbMF0ueCkgKiAobGluZTFbMV0ueSAtIGxpbmUxWzBdLnkpXG4gICAgICAgICAgICArIChsaW5lMVsxXS54IC0gbGluZTFbMF0ueCkgKiAobGluZTJbMF0ueSAtIGxpbmUyWzFdLnkpKTtcbn1cbjtcbi8vIGZpbmQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gbGluZXNcbi8vIHBsZWFzZSBlbnN1cmUgdGhpcyBmdW5jdGlvbiBpcyBub3QgY2FsbGVkIG9uIHBhcmFsbGVsIGxpbmVzXG5mdW5jdGlvbiBjb29yZGluYXRlSW50ZXJjZXB0KGxpbmUxLCBsaW5lMikge1xuICAgIGNvbnN0IHQgPSBjb29yZGluYXRlSW50ZXJjZXB0UGFyYW1ldGVyKGxpbmUxLCBsaW5lMik7XG4gICAgcmV0dXJuIChuZXcgVmVjMkRfMS5WZWMyRChsaW5lMlswXS54ICsgdCAqIChsaW5lMlsxXS54IC0gbGluZTJbMF0ueCksIGxpbmUyWzBdLnkgKyB0ICogKGxpbmUyWzFdLnkgLSBsaW5lMlswXS55KSkpO1xufVxuO1xuLy8gZmluZHMgd2hldGhlciB0aGUgRUNCIGltcGFjdGVkIGEgc3VyZmFjZSBvbiBvbmUgb2YgaXRzIHZlcnRpY2VzXG5mdW5jdGlvbiBydW5Qb2ludFN3ZWVwKGVjYjEsIGVjYnAsIHNhbWUsIHdhbGwsIHdhbGxUeXBlLCB3YWxsSW5kZXgsIHdhbGxCb3R0b21PckxlZnQsIHdhbGxUb3BPclJpZ2h0LCB4T3JZKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgY29uc3Qgd2FsbEFuZ2xlID0gKDAsIGxpbmVBbmdsZV8xLmxpbmVBbmdsZSkoW3dhbGxCb3R0b21PckxlZnQsIHdhbGxUb3BPclJpZ2h0XSk7XG4gICAgaWYgKHdhbGxUeXBlID09PSBcImxcIiB8fCB3YWxsVHlwZSA9PT0gXCJyXCIpIHsgLy8gbGVmdCBvciByaWdodCB3YWxsLCBuZWVkIHRvIGNoZWNrIHRvcCBvciBib3R0b20gRUNCIHZlcnRleCB0b29cbiAgICAgICAgY29uc3Qgc2FtZVJlc3VsdCA9IHBvaW50U3dlZXBpbmdDaGVjayhlY2IxLCBlY2JwLCBzYW1lLCB3YWxsLCB3YWxsVHlwZSwgd2FsbEluZGV4LCB3YWxsVG9wT3JSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgeE9yWSk7XG4gICAgICAgIGNvbnN0IG90aGVyID0gKHdhbGxUeXBlID09PSBcImxcIiAmJiB3YWxsQW5nbGUgPCBNYXRoLlBJIC8gMikgfHwgKHdhbGxUeXBlID09PSBcInJcIiAmJiB3YWxsQW5nbGUgPiBNYXRoLlBJIC8gMikgPyAwIDogMjtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXN1bHQgPSBwb2ludFN3ZWVwaW5nQ2hlY2soZWNiMSwgZWNicCwgb3RoZXIsIHdhbGwsIHdhbGxUeXBlLCB3YWxsSW5kZXgsIHdhbGxUb3BPclJpZ2h0LCB3YWxsQm90dG9tT3JMZWZ0LCB4T3JZKTtcbiAgICAgICAgcmVzdWx0ID0gKDAsIGZpbmRTbWFsbGVzdFdpdGhpbl8xLnBpY2tTbWFsbGVzdFN3ZWVwKShbc2FtZVJlc3VsdCwgb3RoZXJSZXN1bHRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2FsbFR5cGUgPT09IFwiY1wiKSB7IC8vIGZvciBjZWlsaW5ncywgbmVlZCB0byBjaGVjayBzaWRlIEVDQiB2ZXJ0ZXggdG9vXG4gICAgICAgIGNvbnN0IHRvcFJlc3VsdCA9IHBvaW50U3dlZXBpbmdDaGVjayhlY2IxLCBlY2JwLCAyLCB3YWxsLCB3YWxsVHlwZSwgd2FsbEluZGV4LCB3YWxsVG9wT3JSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgeE9yWSk7XG4gICAgICAgIGNvbnN0IHNpZGUgPSB3YWxsQW5nbGUgPCBNYXRoLlBJIC8gMiA/IDMgOiAxO1xuICAgICAgICBjb25zdCBzaWRlUmVzdWx0ID0gcG9pbnRTd2VlcGluZ0NoZWNrKGVjYjEsIGVjYnAsIHNpZGUsIHdhbGwsIHdhbGxUeXBlLCB3YWxsSW5kZXgsIHdhbGxUb3BPclJpZ2h0LCB3YWxsQm90dG9tT3JMZWZ0LCB4T3JZKTtcbiAgICAgICAgcmVzdWx0ID0gKDAsIGZpbmRTbWFsbGVzdFdpdGhpbl8xLnBpY2tTbWFsbGVzdFN3ZWVwKShbdG9wUmVzdWx0LCBzaWRlUmVzdWx0XSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBjYW4gb25seSBjb2xsaWRlIGdyb3VuZHMgb24gdGhlIGJvdHRvbSBFQ0IgdmVydGV4XG4gICAgICAgIHJlc3VsdCA9IHBvaW50U3dlZXBpbmdDaGVjayhlY2IxLCBlY2JwLCBzYW1lLCB3YWxsLCB3YWxsVHlwZSwgd2FsbEluZGV4LCB3YWxsVG9wT3JSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgeE9yWSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG47XG5mdW5jdGlvbiBwb2ludFN3ZWVwaW5nQ2hlY2soZWNiMSwgZWNicCwgcHQsIHdhbGwsIHdhbGxUeXBlLCB3YWxsSW5kZXgsIHdhbGxUb3BPclJpZ2h0LCB3YWxsQm90dG9tT3JMZWZ0LCB4T3JZKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGlzT3V0c2lkZShlY2IxW3B0XSwgd2FsbFRvcE9yUmlnaHQsIHdhbGxCb3R0b21PckxlZnQsIHdhbGxUeXBlKSAmJiAhaXNPdXRzaWRlKGVjYnBbcHRdLCB3YWxsVG9wT3JSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgd2FsbFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHMgPSBjb29yZGluYXRlSW50ZXJjZXB0UGFyYW1ldGVyKHdhbGwsIFtlY2IxW3B0XSwgZWNicFtwdF1dKTsgLy8gbmVlZCB0byBwdXQgd2FsbCBmaXJzdFxuICAgICAgICBpZiAoIShpc05hTihzKSB8fCBzID09PSBJbmZpbml0eSB8fCBzID4gMSB8fCBzIDwgMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IG5ldyBWZWMyRF8xLlZlYzJEKCgxIC0gcykgKiBlY2IxW3B0XS54ICsgcyAqIGVjYnBbcHRdLngsICgxIC0gcykgKiBlY2IxW3B0XS55ICsgcyAqIGVjYnBbcHRdLnkpO1xuICAgICAgICAgICAgaWYgKCgwLCBWZWMyRF8xLmdldFhPcllDb29yZCkoaW50ZXJzZWN0aW9uLCB4T3JZKSA8PSAoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKHdhbGxUb3BPclJpZ2h0LCB4T3JZKSAmJiAoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGludGVyc2VjdGlvbiwgeE9yWSkgPj0gKDAsIFZlYzJEXzEuZ2V0WE9yWUNvb3JkKSh3YWxsQm90dG9tT3JMZWZ0LCB4T3JZKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHsgc3dlZXA6IHMsIGtpbmQ6IFwic3VyZmFjZVwiLCBzdXJmYWNlOiB3YWxsLCB0eXBlOiB3YWxsVHlwZSwgaW5kZXg6IHdhbGxJbmRleCwgcHQ6IHB0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbjtcbi8vIHNlY29uZDogZWRnZSBzd2VlcGluZyBmdW5jdGlvbnNcbi8vIGluIHRoaXMgbmV4dCBmdW5jdGlvbiwgd2UgYXJlIGNvbnNpZGVyaW5nIGEgbGluZSB0aGF0IGlzIHN3ZWVwaW5nLFxuLy8gZnJvbSB0aGUgaW5pdGlhbCBsaW5lICdsaW5lMScgcGFzc2luZyB0aHJvdWdoIHRoZSB0d28gcG9pbnRzIHAxID0gKHgxLHkxKSwgcDIgPSAoeDIseTIpXG4vLyB0byB0aGUgZmluYWwgbGluZSAnbGluZTInIHBhc3NpbmcgdGhyb3VnaCB0aGUgdHdvIHBvaW50cyBwMyA9ICh4Myx5MykgYW5kIHA0ID0gKHg0LHk0KVxuLy8gdGhlcmUgYXJlIHR3byBzd2VlcGluZyBwYXJhbWV0ZXJzOiBcbi8vICAgJ3QnLCB3aGljaCBpbmRpY2F0ZXMgaG93IGZhciBhbG9uZyBlYWNoIGxpbmUgd2UgYXJlXG4vLyAgICdzJywgd2hpY2ggaW5kaWNhdGVzIGhvdyBmYXIgd2UgYXJlIHN3ZWVwaW5nIGJldHdlZW4gbGluZTEgYW5kIGxpbmUyICh0aGUgbWFpbiBzd2VlcGluZyBwYXJhbWV0ZXIpXG4vLyBmb3IgaW5zdGFuY2U6XG4vLyAgcz0wIG1lYW5zIHdlIGFyZSBvbiBsaW5lMSxcbi8vICBzPTEgbWVhbnMgd2UgYXJlIG9uIGxpbmUyLFxuLy8gIHQ9MCBtZWFucyB3ZSBhcmUgb24gdGhlIGxpbmUgYmV0d2VlbiBwMSBhbmQgcDMsXG4vLyAgdD0xIG1lYW5zIHdlIGFyZSBvbiB0aGUgbGluZSBiZXR3ZWVuIHAyIGFuZCBwNFxuLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgc3BlY2lmaWMgdmFsdWUgZm9yIGVhY2ggb2YgdCBhbmQgcyxcbi8vIHdoaWNoIGNvcnJlc3BvbmQgdG8gd2hlbiB0aGUgc3dlcHQgbGluZSBoaXRzIHRoZSBvcmlnaW4gTyAoYXQgY29vcmRpbmF0ZXMgKDAsMCkpXG4vLyBpZiBlaXRoZXIgb2YgdGhlIHBhcmFtZXRlcnMgaXMgbm90IGJldHdlZW4gMCBhbmQgMSwgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIHJldHVybnMgbnVsbFxuLy8gc2VlICcvZG9jL2xpbmVzd2VlcC5wbmcnIGZvciBhIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2l0dWF0aW9uXG5mdW5jdGlvbiBsaW5lU3dlZXBQYXJhbWV0ZXJzKGxpbmUxLCBsaW5lMiwgZmxpcCA9IGZhbHNlKSB7XG4gICAgbGV0IHNpZ24gPSAxO1xuICAgIGlmIChmbGlwKSB7XG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICB9XG4gICAgY29uc3QgeDEgPSBsaW5lMVswXS54O1xuICAgIGNvbnN0IHgyID0gbGluZTFbMV0ueDtcbiAgICBjb25zdCB4MyA9IGxpbmUyWzBdLng7XG4gICAgY29uc3QgeDQgPSBsaW5lMlsxXS54O1xuICAgIGNvbnN0IHkxID0gbGluZTFbMF0ueTtcbiAgICBjb25zdCB5MiA9IGxpbmUxWzFdLnk7XG4gICAgY29uc3QgeTMgPSBsaW5lMlswXS55O1xuICAgIGNvbnN0IHk0ID0gbGluZTJbMV0ueTtcbiAgICBjb25zdCBhMCA9IHgyICogeTEgLSB4MSAqIHkyO1xuICAgIGNvbnN0IGExID0geDQgKiB5MSAtIDIgKiB4MiAqIHkxICsgMiAqIHgxICogeTIgLSB4MyAqIHkyICsgeDIgKiB5MyAtIHgxICogeTQ7XG4gICAgY29uc3QgYTIgPSB4MiAqIHkxIC0geDQgKiB5MSAtIHgxICogeTIgKyB4MyAqIHkyIC0geDIgKiB5MyArIHg0ICogeTMgKyB4MSAqIHk0IC0geDMgKiB5NDtcbiAgICAvLyBzIHNhdGlzZmllcyB0aGUgZXF1YXRpb246ICAgYTAgKyBhMSpzICsgYTIqc14yID0gMFxuICAgIGNvbnN0IHMgPSAoMCwgc29sdmVRdWFkcmF0aWNFcXVhdGlvbl8xLnNvbHZlUXVhZHJhdGljRXF1YXRpb24pKGEwLCBhMSwgYTIsIHNpZ24pO1xuICAgIGlmIChzID09PSBudWxsIHx8IGlzTmFOKHMpIHx8IHMgPT09IEluZmluaXR5IHx8IHMgPCAwIHx8IHMgPiAxKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBubyByZWFsIHNvbHV0aW9uXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0ID0gKHMgKiAoeDEgLSB4MykgLSB4MSkgLyAoeDIgLSB4MSArIHMgKiAoeDEgLSB4MiAtIHgzICsgeDQpKTtcbiAgICAgICAgaWYgKGlzTmFOKHQpIHx8IHQgPT09IEluZmluaXR5IHx8IHQgPCAwIHx8IHQgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbdCwgc107XG4gICAgICAgIH1cbiAgICB9XG59XG47XG4vLyBmaW5kcyB3aGV0aGVyIHRoZSBFQ0IgaW1wYWN0ZWQgYSBzdXJmYWNlIG9uIG9uZSBvZiBpdHMgZWRnZXNcbmZ1bmN0aW9uIHJ1bkVkZ2VTd2VlcChlY2IxLCBlY2JwLCBzYW1lLCB3YWxsVHlwZSwgd2FsbExlZnQsIHdhbGxSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgd2FsbFRvcE9yUmlnaHQsIHhPclksIGRhbWFnZVR5cGUpIHtcbiAgICBsZXQgb3RoZXIgPSAwOyAvLyBvdGhlciBFQ0IgcG9pbnRcbiAgICBsZXQgY291bnRlcmNsb2Nrd2lzZSA9IHRydWU7IC8vIHdoZXRoZXIgKHNhbWUgRUNCIHBvaW50IC0+IG90aGVyIEVDQiBwb2ludCkgaXMgY291bnRlcmNsb2Nrd2lzZSAody5yLnQuIHRoZSBFQ0IpXG4gICAgbGV0IGNvcm5lciA9IG51bGw7XG4gICAgbGV0IG90aGVyQ29ybmVyID0gbnVsbDtcbiAgICBsZXQgZWRnZVN3ZWVwUmVzdWx0ID0gbnVsbDtcbiAgICBsZXQgb3RoZXJFZGdlU3dlZXBSZXN1bHQgPSBudWxsO1xuICAgIGNvbnN0IGZsaXAgPSB3YWxsVHlwZSA9PT0gXCJyXCIgfHwgd2FsbFR5cGUgPT09IFwiY1wiID8gZmFsc2UgOiB0cnVlO1xuICAgIC8vIGNhc2UgMVxuICAgIGlmICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVjYjFbc2FtZV0sIHhPclkpID4gKDAsIFZlYzJEXzEuZ2V0WE9yWUNvb3JkKSh3YWxsVG9wT3JSaWdodCwgeE9yWSkpIHtcbiAgICAgICAgY291bnRlcmNsb2Nrd2lzZSA9ICFmbGlwO1xuICAgICAgICBvdGhlciA9IHR1cm4oc2FtZSwgY291bnRlcmNsb2Nrd2lzZSk7XG4gICAgICAgIGlmICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVjYnBbb3RoZXJdLCB4T3JZKSA8ICgwLCBWZWMyRF8xLmdldFhPcllDb29yZCkod2FsbFRvcE9yUmlnaHQsIHhPclkpKSB7XG4gICAgICAgICAgICBjb3JuZXIgPSB3YWxsVG9wT3JSaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjYXNlIDJcbiAgICBlbHNlIGlmICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVjYjFbc2FtZV0sIHhPclkpIDwgKDAsIFZlYzJEXzEuZ2V0WE9yWUNvb3JkKSh3YWxsQm90dG9tT3JMZWZ0LCB4T3JZKSkge1xuICAgICAgICBjb3VudGVyY2xvY2t3aXNlID0gZmxpcDtcbiAgICAgICAgb3RoZXIgPSB0dXJuKHNhbWUsIGNvdW50ZXJjbG9ja3dpc2UpO1xuICAgICAgICBpZiAoKDAsIFZlYzJEXzEuZ2V0WE9yWUNvb3JkKShlY2JwW290aGVyXSwgeE9yWSkgPiAoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKHdhbGxCb3R0b21PckxlZnQsIHhPclkpKSB7XG4gICAgICAgICAgICBjb3JuZXIgPSB3YWxsQm90dG9tT3JMZWZ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb3JuZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gdGhlIHJlbGV2YW50IEVDQiBlZGdlLCB0aGF0IG1pZ2h0IGNvbGxpZGUgd2l0aCB0aGUgY29ybmVyLCBpcyB0aGUgZWRnZSBiZXR3ZWVuIEVDQiBwb2ludHMgJ3NhbWUnIGFuZCAnb3RoZXInXG4gICAgICAgIGxldCBpbnRlcmlvckVDQnNpZGUgPSBcImxcIjtcbiAgICAgICAgaWYgKGNvdW50ZXJjbG9ja3dpc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpbnRlcmlvckVDQnNpZGUgPSBcInJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT3V0c2lkZShjb3JuZXIsIGVjYnBbc2FtZV0sIGVjYnBbb3RoZXJdLCBpbnRlcmlvckVDQnNpZGUpICYmIGlzT3V0c2lkZShjb3JuZXIsIGVjYjFbc2FtZV0sIGVjYjFbb3RoZXJdLCBpbnRlcmlvckVDQnNpZGUpKSB7XG4gICAgICAgICAgICBlZGdlU3dlZXBSZXN1bHQgPSBlZGdlU3dlZXBpbmdDaGVjayhlY2IxLCBlY2JwLCBzYW1lLCBvdGhlciwgY291bnRlcmNsb2Nrd2lzZSwgY29ybmVyLCBkYW1hZ2VUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHdhbGxUeXBlID09PSBcImxcIiB8fCB3YWxsVHlwZSA9PT0gXCJyXCIpICYmIChvdGhlciA9PT0gMCkpIHtcbiAgICAgICAgLy8gaWYgZGVhbGluZyB3aXRoIGEgd2FsbCwgd2UgbWlnaHQgYWxzbyB3YW50IHRvIGNoZWNrIHRoZSB0b3AgRUNCIHBvaW50IGZvciBjb2xsaXNpb24gaWYgd2UgYXJlbid0IGFscmVhZHkgZG9pbmcgc29cbiAgICAgICAgbGV0IG90aGVyQ291bnRlcmNsb2Nrd2lzZSA9IGZhbHNlOyAvLyB3aGV0aGVyICggc2FtZSBFQ0IgcG9pbnQgLT4gdG9wIEVDQiBwb2ludCkgaXMgY291bnRlcmNsb2Nrd2lzZVxuICAgICAgICBvdGhlckNvcm5lciA9IHdhbGxSaWdodDtcbiAgICAgICAgaWYgKHdhbGxUeXBlID09PSBcImxcIikge1xuICAgICAgICAgICAgb3RoZXJDb3VudGVyY2xvY2t3aXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIG90aGVyQ29ybmVyID0gd2FsbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG90aGVySW50ZXJpb3JFQ0JzaWRlID0gXCJsXCI7XG4gICAgICAgIGlmIChvdGhlckNvdW50ZXJjbG9ja3dpc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdGhlckludGVyaW9yRUNCc2lkZSA9IFwiclwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNPdXRzaWRlKG90aGVyQ29ybmVyLCBlY2JwW3NhbWVdLCBlY2JwWzJdLCBvdGhlckludGVyaW9yRUNCc2lkZSlcbiAgICAgICAgICAgICYmIGlzT3V0c2lkZShvdGhlckNvcm5lciwgZWNiMVtzYW1lXSwgZWNiMVsyXSwgb3RoZXJJbnRlcmlvckVDQnNpZGUpKSB7XG4gICAgICAgICAgICBvdGhlckVkZ2VTd2VlcFJlc3VsdCA9IGVkZ2VTd2VlcGluZ0NoZWNrKGVjYjEsIGVjYnAsIHNhbWUsIDIsIG90aGVyQ291bnRlcmNsb2Nrd2lzZSwgb3RoZXJDb3JuZXIsIGRhbWFnZVR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgZmluZFNtYWxsZXN0V2l0aGluXzEucGlja1NtYWxsZXN0U3dlZXApKFtlZGdlU3dlZXBSZXN1bHQsIG90aGVyRWRnZVN3ZWVwUmVzdWx0XSk7XG59XG47XG4vLyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIEVDQiBlZGdlIChzYW1lLS1vdGhlcikgaGFzIGNvbGxpZGVkIHdpdGggdGhlIGNvcm5lciwgdXNpbmcgdGhlIGxpbmVTd2VlcFBhcmFtZXRlcnMgZnVuY3Rpb25cbmZ1bmN0aW9uIGVkZ2VTd2VlcGluZ0NoZWNrKGVjYjEsIGVjYnAsIHNhbWUsIG90aGVyLCBjb3VudGVyY2xvY2t3aXNlLCBjb3JuZXIsIGRhbWFnZVR5cGUpIHtcbiAgICBsZXQgb3V0cHV0ID0gbnVsbDtcbiAgICAvLyB0aGUgcmVsZXZhbnQgRUNCIGVkZ2UsIHRoYXQgbWlnaHQgY29sbGlkZSB3aXRoIHRoZSBjb3JuZXIsIGlzIHRoZSBlZGdlIGJldHdlZW4gRUNCIHBvaW50cyAnc2FtZScgYW5kICdvdGhlcidcbiAgICBsZXQgaW50ZXJpb3JFQ0JzaWRlID0gXCJsXCI7XG4gICAgaWYgKGNvdW50ZXJjbG9ja3dpc2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGludGVyaW9yRUNCc2lkZSA9IFwiclwiO1xuICAgIH1cbiAgICBpZiAoIWlzT3V0c2lkZShjb3JuZXIsIGVjYnBbc2FtZV0sIGVjYnBbb3RoZXJdLCBpbnRlcmlvckVDQnNpZGUpICYmIGlzT3V0c2lkZShjb3JuZXIsIGVjYjFbc2FtZV0sIGVjYjFbb3RoZXJdLCBpbnRlcmlvckVDQnNpZGUpKSB7XG4gICAgICAgIC8vIHdlIHN3ZWVwIGEgbGluZSxcbiAgICAgICAgLy8gc3RhcnRpbmcgZnJvbSB0aGUgcmVsZXZhbnQgRUNCMSBlZGdlLCBhbmQgZW5kaW5nIGF0IHRoZSByZWxldmFudCBFQ0JwIGVkZ2UsXG4gICAgICAgIC8vIGFuZCBmaWd1cmUgb3V0IHdoZXJlIHRoaXMgd291bGQgaW50ZXJzZWN0IHRoZSBjb3JuZXJcbiAgICAgICAgLy8gZmlyc3Qgd2UgcmVjZW50ZXIgZXZlcnl0aGluZyBhcm91bmQgdGhlIGNvcm5lcixcbiAgICAgICAgLy8gYXMgdGhlICdsaW5lU3dlZXBQYXJhbWV0ZXJzJyBmdW5jdGlvbiBjYWxjdWxhdGVzIGNvbGxpc2lvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG9yaWdpblxuICAgICAgICBjb25zdCByZWNlbnRlcmVkRUNCMUVkZ2UgPSBbbmV3IFZlYzJEXzEuVmVjMkQoZWNiMVtzYW1lXS54IC0gY29ybmVyLngsIGVjYjFbc2FtZV0ueSAtIGNvcm5lci55KSxcbiAgICAgICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKGVjYjFbb3RoZXJdLnggLSBjb3JuZXIueCwgZWNiMVtvdGhlcl0ueSAtIGNvcm5lci55KV07XG4gICAgICAgIGNvbnN0IHJlY2VudGVyZWRFQ0JwRWRnZSA9IFtuZXcgVmVjMkRfMS5WZWMyRChlY2JwW3NhbWVdLnggLSBjb3JuZXIueCwgZWNicFtzYW1lXS55IC0gY29ybmVyLnkpLFxuICAgICAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQoZWNicFtvdGhlcl0ueCAtIGNvcm5lci54LCBlY2JwW290aGVyXS55IC0gY29ybmVyLnkpXTtcbiAgICAgICAgLy8gaW4gdGhlIGxpbmUgc3dlZXBpbmcsIHNvbWUgdHJpY2t5IG9yaWVudGF0aW9uIGNoZWNrcyBzaG93IHRoYXQgYSBtaW51cyBzaWduIGlzIHJlcXVpcmVkIHByZWNpc2VseSBpbiB0aGUgY291bnRlcmNsb2Nrd2lzZSBjYXNlXG4gICAgICAgIC8vIHRoaXMgaXMgd2hhdCB0aGUgdGhpcmQgYXJndW1lbnQgdG8gJ2xpbmVTd2VlcFBhcmFtZXRlcnMnIGNvcnJlc3BvbmRzIHRvXG4gICAgICAgIGNvbnN0IGxpbmVTd2VlcFJlc3VsdCA9IGxpbmVTd2VlcFBhcmFtZXRlcnMocmVjZW50ZXJlZEVDQjFFZGdlLCByZWNlbnRlcmVkRUNCcEVkZ2UsIGNvdW50ZXJjbG9ja3dpc2UpO1xuICAgICAgICBpZiAobGluZVN3ZWVwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBbdCwgc10gPSBsaW5lU3dlZXBSZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBhbmd1bGFyUGFyYW1ldGVyID0gZ2V0QW5ndWxhclBhcmFtZXRlcih0LCBzYW1lLCBvdGhlcik7XG4gICAgICAgICAgICBvdXRwdXQgPSB7IGtpbmQ6IFwiY29ybmVyXCIsIGNvcm5lcjogY29ybmVyLCBzd2VlcDogcywgYW5ndWxhcjogYW5ndWxhclBhcmFtZXRlciwgZGFtYWdlVHlwZTogZGFtYWdlVHlwZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG47XG4vLyB0aGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBmaXJzdCBjb2xsaXNpb24gdGhhdCBoYXBwZW5zIGFzIHRoZSBvbGQgRUNCIG1vdmVzIHRvIHRoZSBwcm9qZWN0ZWQgRUNCXG4vLyB0aGUgc3dlZXBpbmcgcGFyYW1ldGVyIHMgY29ycmVzcG9uZHMgdG8gdGhlIGxvY2F0aW9uIG9mIHRoaXMgZmlyc3QgY29sbGlzaW9uXG4vLyB0ZXJtaW5vbG9neSBpbiB0aGUgY29tbWVudHM6IGEgd2FsbCBpcyBhIHNlZ21lbnQgd2l0aCBhbiBpbnNpZGUgYW5kIGFuIG91dHNpZGUgKGNvdWxkIGJlIGEgZ3JvdW5kIG9yIGNlaWxpbmcgKVxuLy8gd2hpY2ggaXMgY29udGFpbmVkIGluIGFuIGluZmluaXRlIGxpbmUsIGV4dGVuZGluZyBib3RoIHdheXMsIHdoaWNoIGFsc28gaGFzIGFuIGluc2lkZSBhbmQgYW4gb3V0c2lkZVxuZnVuY3Rpb24gZmluZENvbGxpc2lvbihlY2IxLCBlY2JwLCBsYWJlbGxlZFN1cmZhY2UpIHtcbiAgICAvLyBTVEFORElORyBBU1NVTVBUSU9OU1xuICAgIC8vIHRoZSBFQ0IgY2FuIG9ubHkgY29sbGlkZSBhIGdyb3VuZC9wbGF0Zm9ybSBzdXJmYWNlIG9uIGl0cyBib3R0b20gcG9pbnQgKG9yIGEgYm90dG9tIGVkZ2UpXG4gICAgLy8gdGhlIEVDQiBjYW4gb25seSBjb2xsaWRlIGEgY2VpbGluZyBzdXJmYWNlIG9uIGEgdG9wIG9yIHNpZGUgcG9pbnQgKG9yIGEgdG9wIGVkZ2UpXG4gICAgLy8gdGhlIEVDQiBjYW5ub3QgY29sbGlkZSBhIGxlZnQgd2FsbCBvbiBpdHMgbGVmdCB2ZXJ0ZXhcbiAgICAvLyB0aGUgRUNCIGNhbm5vdCBjb2xsaWRlIGEgcmlnaHQgd2FsbCBvbiBpdHMgcmlnaHQgdmVydGV4XG4gICAgLy8gd2FsbHMgYW5kIGNvcm5lcnMgcHVzaCBvdXQgaG9yaXpvbnRhbGx5LCBncm91bmRzL2NlaWxpbmdzL3BsYXRmb3JtcyBwdXNoIG91dCB2ZXJ0aWNhbGx5XG4gICAgY29uc3QgW3dhbGwsIFt3YWxsVHlwZSwgd2FsbEluZGV4XV0gPSBsYWJlbGxlZFN1cmZhY2U7XG4gICAgY29uc3QgZGFtYWdlVHlwZSA9IHdhbGxbMl0gIT09IHVuZGVmaW5lZCA/IHdhbGxbMl0uZGFtYWdlVHlwZSA6IG51bGw7XG4gICAgLy8gc3RhcnQgZGVmaW5pbmcgdXNlZnVsIGNvbnN0YW50cy92YXJpYWJsZXNcbiAgICBjb25zdCB3YWxsVG9wID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkod2FsbCwgXCJ0XCIpO1xuICAgIGNvbnN0IHdhbGxCb3R0b20gPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KSh3YWxsLCBcImJcIik7XG4gICAgY29uc3Qgd2FsbExlZnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KSh3YWxsLCBcImxcIik7XG4gICAgY29uc3Qgd2FsbFJpZ2h0ID0gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkod2FsbCwgXCJyXCIpO1xuICAgIC8vIHJpZ2h0IHdhbGwgYnkgZGVmYXVsdFxuICAgIGxldCB3YWxsVG9wT3JSaWdodCA9IHdhbGxUb3A7XG4gICAgbGV0IHdhbGxCb3R0b21PckxlZnQgPSB3YWxsQm90dG9tO1xuICAgIGxldCBzYW1lID0gMztcbiAgICBsZXQgeE9yWSA9IFwieVwiO1xuICAgIGxldCBpc1BsYXRmb3JtID0gZmFsc2U7XG4gICAgc3dpdGNoICh3YWxsVHlwZSkge1xuICAgICAgICBjYXNlIFwibFwiOiAvLyBsZWZ0IHdhbGxcbiAgICAgICAgICAgIHNhbWUgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwXCI6IC8vIHBsYXRmb3JtXG4gICAgICAgICAgICBpc1BsYXRmb3JtID0gdHJ1ZTtcbiAgICAgICAgY2FzZSBcImdcIjogLy8gZ3JvdW5kXG4gICAgICAgICAgICBzYW1lID0gMDtcbiAgICAgICAgICAgIHdhbGxUb3BPclJpZ2h0ID0gd2FsbFJpZ2h0O1xuICAgICAgICAgICAgd2FsbEJvdHRvbU9yTGVmdCA9IHdhbGxMZWZ0O1xuICAgICAgICAgICAgeE9yWSA9IFwieFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjXCI6IC8vIGNlaWxpbmdcbiAgICAgICAgICAgIHNhbWUgPSAyO1xuICAgICAgICAgICAgd2FsbFRvcE9yUmlnaHQgPSB3YWxsUmlnaHQ7XG4gICAgICAgICAgICB3YWxsQm90dG9tT3JMZWZ0ID0gd2FsbExlZnQ7XG4gICAgICAgICAgICB4T3JZID0gXCJ4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gcmlnaHQgd2FsbCBieSBkZWZhdWx0XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gZmlyc3QgY2hlY2sgaWYgcGxheWVyIEVDQiB3YXMgZXZlbiBuZWFyIHRoZSB3YWxsXG4gICAgaWYgKChlY2JwWzBdLnkgPiB3YWxsVG9wLnkgJiYgZWNiMVswXS55ID4gd2FsbFRvcC55KSAvLyBwbGF5ZXIgRUNCIHN0YXllZCBhYm92ZSB0aGUgd2FsbFxuICAgICAgICB8fCAoZWNicFsyXS55IDwgd2FsbEJvdHRvbS55ICYmIGVjYjFbMl0ueSA8IHdhbGxCb3R0b20ueSkgLy8gcGxheWVkIEVDQiBzdGF5ZWQgYmVsb3cgdGhlIHdhbGxcbiAgICAgICAgfHwgKGVjYnBbM10ueCA+IHdhbGxSaWdodC54ICYmIGVjYjFbM10ueCA+IHdhbGxSaWdodC54KSAvLyBwbGF5ZXIgRUNCIHN0YXllZCB0byB0aGUgcmlnaHQgb2YgdGhlIHdhbGxcbiAgICAgICAgfHwgKGVjYnBbMV0ueCA8IHdhbGxMZWZ0LnggJiYgZWNiMVsxXS54IDwgd2FsbExlZnQueCkgLy8gcGxheWVyIEVDQiBzdGF5ZWQgdG8gdGhlIGxlZnQgb2YgdGhlIHdhbGxcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgc3VyZmFjZSBpcyBhIHBsYXRmb3JtLCBhbmQgdGhlIGJvdHRvbSBFQ0IgcG9pbnQgaXMgYmVsb3cgdGhlIHBsYXRmb3JtLCB3ZSBzaG91bGRuJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGlzUGxhdGZvcm0pIHtcbiAgICAgICAgICAgIGlmICghaXNPdXRzaWRlKGVjYjFbc2FtZV0sIHdhbGxUb3BPclJpZ2h0LCB3YWxsQm90dG9tT3JMZWZ0LCB3YWxsVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zZXN0RWRnZUNvbGxpc2lvbiA9IHJ1bkVkZ2VTd2VlcChlY2IxLCBlY2JwLCBzYW1lLCB3YWxsVHlwZSwgd2FsbExlZnQsIHdhbGxSaWdodCwgd2FsbEJvdHRvbU9yTGVmdCwgd2FsbFRvcE9yUmlnaHQsIHhPclksIGRhbWFnZVR5cGUpO1xuICAgICAgICBjb25zdCBjbG9zZXN0UG9pbnRDb2xsaXNpb24gPSBydW5Qb2ludFN3ZWVwKGVjYjEsIGVjYnAsIHNhbWUsIHdhbGwsIHdhbGxUeXBlLCB3YWxsSW5kZXgsIHdhbGxCb3R0b21PckxlZnQsIHdhbGxUb3BPclJpZ2h0LCB4T3JZLCBkYW1hZ2VUeXBlKTtcbiAgICAgICAgbGV0IGZpbmFsQ29sbGlzaW9uID0gbnVsbDtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBvbmx5IG9uZSBjb2xsaXNpb24gdHlwZSAocG9pbnQvZWRnZSksIHRha2UgdGhhdCBvbmVcbiAgICAgICAgaWYgKGNsb3Nlc3RFZGdlQ29sbGlzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5hbENvbGxpc2lvbiA9IGNsb3Nlc3RQb2ludENvbGxpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZXN0UG9pbnRDb2xsaXNpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbmFsQ29sbGlzaW9uID0gY2xvc2VzdEVkZ2VDb2xsaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgY29sbGlzaW9uIHdpdGggc21hbGxlc3Qgc3dlZXBpbmcgcGFyYW1ldGVyXG4gICAgICAgIGVsc2UgaWYgKGNsb3Nlc3RFZGdlQ29sbGlzaW9uLnN3ZWVwID4gY2xvc2VzdFBvaW50Q29sbGlzaW9uLnN3ZWVwKSB7XG4gICAgICAgICAgICBmaW5hbENvbGxpc2lvbiA9IGNsb3Nlc3RQb2ludENvbGxpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsQ29sbGlzaW9uID0gY2xvc2VzdEVkZ2VDb2xsaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmFsQ29sbGlzaW9uO1xuICAgIH1cbn1cbjtcbi8vIHRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGZpcnN0IChub24taWdub3JlZCkgY29sbGlzaW9uIGFzIHRoZSBFQ0IxIG1vdmVzIHRvIHRoZSBFQ0JwXG5mdW5jdGlvbiBmaW5kQ2xvc2VzdENvbGxpc2lvbihlY2IxLCBlY2JwLCBsYWJlbGxlZFN1cmZhY2VzKSB7XG4gICAgY29uc3QgdG91Y2hpbmdEYXRhID0gW251bGxdOyAvLyBpbml0aWFsaXNlIGxpc3Qgb2YgbmV3IGNvbGxpc2lvbnNcbiAgICBjb25zdCBjb2xsaXNpb25EYXRhID0gbGFiZWxsZWRTdXJmYWNlcy5tYXAoKGxhYmVsbGVkU3VyZmFjZSkgPT4gZmluZENvbGxpc2lvbihlY2IxLCBlY2JwLCBsYWJlbGxlZFN1cmZhY2UpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxpc2lvbkRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29sbGlzaW9uRGF0dW0gPSBjb2xsaXNpb25EYXRhW2ldO1xuICAgICAgICBpZiAoY29sbGlzaW9uRGF0dW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb25EYXR1bS5raW5kID09PSBcInN1cmZhY2VcIikge1xuICAgICAgICAgICAgICAgIHRvdWNoaW5nRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3dlZXA6IGNvbGxpc2lvbkRhdHVtLnN3ZWVwLCBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3VyZmFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VyZmFjZTogY29sbGlzaW9uRGF0dW0uc3VyZmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbGxpc2lvbkRhdHVtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sbGlzaW9uRGF0dW0uaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdDogY29sbGlzaW9uRGF0dW0ucHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sbGlzaW9uRGF0dW0ua2luZCA9PT0gXCJjb3JuZXJcIikge1xuICAgICAgICAgICAgICAgIHRvdWNoaW5nRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3dlZXA6IGNvbGxpc2lvbkRhdHVtLnN3ZWVwLCBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiY29ybmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXI6IGNvbGxpc2lvbkRhdHVtLmNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXI6IGNvbGxpc2lvbkRhdHVtLmFuZ3VsYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1hZ2VUeXBlOiBjb2xsaXNpb25EYXR1bS5kYW1hZ2VUeXBlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIGZpbmRTbWFsbGVzdFdpdGhpbl8xLnBpY2tTbWFsbGVzdFN3ZWVwKSh0b3VjaGluZ0RhdGEpO1xufVxuO1xuZnVuY3Rpb24gcmVzb2x2ZUVDQihlY2IxLCBlY2JwLCBwbGF5ZXJTdGF0dXNJbmZvLCBsYWJlbGxlZFN1cmZhY2VzKSB7XG4gICAgcmV0dXJuIHJ1blNsaWRlUm91dGluZShlY2IxLCBlY2JwLCBlY2JwLCBwbGF5ZXJTdGF0dXNJbmZvLCBsYWJlbGxlZFN1cmZhY2VzLCBudWxsLCB7XG4gICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgIGFuZ3VsYXI6IG51bGxcbiAgICB9LCBmYWxzZSwgdHJ1ZSwgMCk7XG59XG5mdW5jdGlvbiBydW5TbGlkZVJvdXRpbmUoc3JjRUNCLCB0Z3RFQ0IsIGVjYnAsIHBsYXllclN0YXR1c0luZm8sIGxhYmVsbGVkU3VyZmFjZXMsIG9sZFRvdWNoaW5nRGF0dW0sIHNsaWRpbmdBZ2FpbnN0LCBzcXVhc2hlZCwgZmluYWwsIHJlY3Vyc2lvbkNvdW50ZXIpIHtcbiAgICBsZXQgb3V0cHV0O1xuICAgIGlmIChyZWN1cnNpb25Db3VudGVyID4gbWF4UmVjdXJzaW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJ3J1blNsaWRlUm91dGluZSc6IGV4Y2Vzc2l2ZSByZWN1cnNpb24sIGFib3J0aW5nLlwiKTtcbiAgICAgICAgKDAsIGRyYXdFQ0JfMS5kcmF3RUNCKShzcmNFQ0IsIFwiIzI4NmVlMFwiKTtcbiAgICAgICAgKDAsIGRyYXdFQ0JfMS5kcmF3RUNCKSh0Z3RFQ0IsIFwiI2Y0OTkzMFwiKTtcbiAgICAgICAgKDAsIGRyYXdFQ0JfMS5kcmF3RUNCKShlY2JwLCBcIiNmZmY5YWRcIik7XG4gICAgICAgIG91dHB1dCA9IHsgZWNiOiBzcmNFQ0IsIHRvdWNoaW5nOiBudWxsLCBzcXVhc2hlZDogc3F1YXNoZWQgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNsaWRlRGF0dW0gPSBzbGlkZUVDQihzcmNFQ0IsIHRndEVDQiwgbGFiZWxsZWRTdXJmYWNlcywgc2xpZGluZ0FnYWluc3QsIHBsYXllclN0YXR1c0luZm8pO1xuICAgICAgICBsZXQgbmV3RUNCcCA9IGVjYnA7XG4gICAgICAgIGlmIChzbGlkZURhdHVtLmV2ZW50ID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB7IGVjYjogc2xpZGVEYXR1bS5maW5hbEVDQiwgdG91Y2hpbmc6IHNsaWRlRGF0dW0udG91Y2hpbmcsIHNxdWFzaGVkOiBzcXVhc2hlZCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNsaWRlRGF0dW0uZXZlbnQgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyBlY2I6IHRndEVDQiwgdG91Y2hpbmc6IG9sZFRvdWNoaW5nRGF0dW0sIHNxdWFzaGVkOiBzcXVhc2hlZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RUNCcCA9IHVwZGF0ZUVDQnAoc3JjRUNCLCB0Z3RFQ0IsIGVjYnAsIHNsaWRpbmdBZ2FpbnN0LnR5cGUsIDApO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHJ1blNsaWRlUm91dGluZSh0Z3RFQ0IsIG5ld0VDQnAsIG5ld0VDQnAsIHBsYXllclN0YXR1c0luZm8sIGxhYmVsbGVkU3VyZmFjZXMsIG9sZFRvdWNoaW5nRGF0dW0sIHNsaWRpbmdBZ2FpbnN0LCBzcXVhc2hlZCwgdHJ1ZSwgcmVjdXJzaW9uQ291bnRlciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBzbGlkZURhdHVtLmV2ZW50ID09PSBcInRyYW5zZmVyXCIgfHwgc2xpZGVEYXR1bS5ldmVudCA9PT0gXCJzcXVhc2hcIlxuICAgICAgICAgICAgY29uc3QgbmV3U3JjRUNCID0gc2xpZGVEYXR1bS5taWRFQ0I7XG4gICAgICAgICAgICBjb25zdCBzbGlkZU9iamVjdCA9IHNsaWRlRGF0dW0ub2JqZWN0O1xuICAgICAgICAgICAgbGV0IG5ld1RvdWNoaW5nRGF0dW07XG4gICAgICAgICAgICBsZXQgYW5ndWxhcjtcbiAgICAgICAgICAgIGxldCBuZXdGaW5hbDtcbiAgICAgICAgICAgIGxldCBuZXdUZ3RFQ0I7XG4gICAgICAgICAgICBsZXQgbmV3U2xpZGluZ1R5cGUgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHNhbWU7XG4gICAgICAgICAgICBsZXQgb3RoZXI7XG4gICAgICAgICAgICBpZiAoc2xpZGVPYmplY3Qua2luZCA9PT0gXCJzdXJmYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdXJmYWNlID0gc2xpZGVPYmplY3Quc3VyZmFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdXJmYWNlVHlwZSA9IHNsaWRlT2JqZWN0LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHN1cmZhY2VUeXBlID09PSBcImxcIiB8fCBzdXJmYWNlVHlwZSA9PT0gXCJyXCIgfHwgc3VyZmFjZVR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NsaWRpbmdUeXBlID0gc3VyZmFjZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhbWUgPSBzdXJmYWNlVHlwZSA9PT0gXCJsXCIgPyAxIDogMztcbiAgICAgICAgICAgICAgICBhbmd1bGFyID0gc2xpZGVPYmplY3QucHQ7XG4gICAgICAgICAgICAgICAgbmV3RUNCcCA9IHVwZGF0ZUVDQnAoc3JjRUNCLCBzbGlkZURhdHVtLm1pZEVDQiwgZWNicCwgbmV3U2xpZGluZ1R5cGUsIHNhbWUpO1xuICAgICAgICAgICAgICAgIG5ld1RvdWNoaW5nRGF0dW0gPSB7IGtpbmQ6IFwic3VyZmFjZVwiLCB0eXBlOiBzdXJmYWNlVHlwZSwgaW5kZXg6IHNsaWRlT2JqZWN0LmluZGV4LCBwdDogYW5ndWxhciB9O1xuICAgICAgICAgICAgICAgIFtuZXdUZ3RFQ0IsIG5ld0ZpbmFsXSA9IGZpbmROZXh0VGFyZ2V0RnJvbVN1cmZhY2UobmV3U3JjRUNCLCBuZXdFQ0JwLCBzdXJmYWNlLCBzdXJmYWNlVHlwZSwgYW5ndWxhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3JuZXIgPSBzbGlkZU9iamVjdC5jb3JuZXI7XG4gICAgICAgICAgICAgICAgYW5ndWxhciA9IHNsaWRlT2JqZWN0LmFuZ3VsYXI7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIgPCAyICYmIGFuZ3VsYXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NsaWRpbmdUeXBlID0gXCJsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuZ3VsYXIgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NsaWRpbmdUeXBlID0gXCJyXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFtzYW1lLCBvdGhlcl0gPSBnZXRTYW1lQW5kT3RoZXIoYW5ndWxhcik7XG4gICAgICAgICAgICAgICAgbmV3RUNCcCA9IHVwZGF0ZUVDQnAoc3JjRUNCLCBzbGlkZURhdHVtLm1pZEVDQiwgZWNicCwgbmV3U2xpZGluZ1R5cGUsIHNhbWUpO1xuICAgICAgICAgICAgICAgIFtuZXdUZ3RFQ0IsIG5ld0ZpbmFsXSA9IGZpbmROZXh0VGFyZ2V0RnJvbUNvcm5lcihuZXdTcmNFQ0IsIG5ld0VDQnAsIGNvcm5lciwgYW5ndWxhcik7XG4gICAgICAgICAgICAgICAgbmV3VG91Y2hpbmdEYXR1bSA9IHsga2luZDogXCJjb3JuZXJcIiwgYW5ndWxhcjogYW5ndWxhciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsaWRlRGF0dW0uZXZlbnQgPT09IFwidHJhbnNmZXJcIikge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHJ1blNsaWRlUm91dGluZShuZXdTcmNFQ0IsIG5ld1RndEVDQiwgbmV3RUNCcCwgcGxheWVyU3RhdHVzSW5mbywgbGFiZWxsZWRTdXJmYWNlcywgbmV3VG91Y2hpbmdEYXR1bSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXdTbGlkaW5nVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhcjogYW5ndWxhclxuICAgICAgICAgICAgICAgIH0sIHNxdWFzaGVkLCBuZXdGaW5hbCwgcmVjdXJzaW9uQ291bnRlciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJUZ3RFQ0IgPSBzbGlkZURhdHVtLnRndEVDQjtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3F1YXNoVGd0RUNCLCBhYm9ydF0gPSBhZ3JlZU9uVGFyZ2V0RUNCKG5ld1NyY0VDQiwgb3RoZXJUZ3RFQ0IsIG5ld1RndEVDQiwgbmV3RUNCcCwgc2FtZSwgcGxheWVyU3RhdHVzSW5mby5ncm91bmRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKGFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgZWNiOiBzcmNFQ0IsIHRvdWNoaW5nOiBvbGRUb3VjaGluZ0RhdHVtLCBzcXVhc2hlZDogc3F1YXNoZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHJ1blNsaWRlUm91dGluZShuZXdTcmNFQ0IsIHNxdWFzaFRndEVDQiwgbmV3RUNCcCwgcGxheWVyU3RhdHVzSW5mbywgbGFiZWxsZWRTdXJmYWNlcywgbmV3VG91Y2hpbmdEYXR1bSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbmV3U2xpZGluZ1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyOiBhbmd1bGFyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUsIG5ld0ZpbmFsICYmIGZpbmFsLCByZWN1cnNpb25Db3VudGVyICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG47XG4vLyB0aGlzIGZ1bmN0aW9uIGZpZ3VyZXMgb3V0IGlmIHdlIGNhbiBtb3ZlIHRoZSBFQ0IsIGZyb20gdGhlIHNvdXJjZSBFQ0IgdG8gdGhlIHRhcmdldCBFQ0JcbmZ1bmN0aW9uIHNsaWRlRUNCKHNyY0VDQiwgdGd0RUNCLCBsYWJlbGxlZFN1cmZhY2VzLCBzbGlkaW5nQWdhaW5zdCwgcGxheWVyU3RhdHVzSW5mbykge1xuICAgIGxldCBvdXRwdXQ7XG4gICAgLy8gZmlndXJlIG91ciB3aGV0aGVyIGEgY29sbGlzaW9uIG9jY3VyZWQgd2hpbGUgbW92aW5nIHNyY0VDQiAtPiB0Z3RFQ0JcbiAgICBjb25zdCB0b3VjaGluZ0RhdHVtID0gZmluZENsb3Nlc3RDb2xsaXNpb24oc3JjRUNCLCB0Z3RFQ0IsIGxhYmVsbGVkU3VyZmFjZXMpO1xuICAgIGlmICh0b3VjaGluZ0RhdHVtID09PSBudWxsKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCInc2xpZGVFQ0InOiBzbGlkaW5nLlwiKTtcbiAgICAgICAgb3V0cHV0ID0geyBldmVudDogXCJjb250aW51ZVwiIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzID0gdG91Y2hpbmdEYXR1bS5zd2VlcDtcbiAgICAgICAgY29uc3QgciA9IE1hdGgubWF4KDAsIHMgLSBleHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQgLyAxMCk7IC8vIHRvIGFjY291bnQgZm9yIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICAgICAgICBjb25zdCBtaWRFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEuaW50ZXJwb2xhdGVFQ0IpKHNyY0VDQiwgdGd0RUNCLCByKTtcbiAgICAgICAgY29uc3QgY29sbGlzaW9uT2JqZWN0ID0gdG91Y2hpbmdEYXR1bS5vYmplY3Q7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBkYW1hZ2luZyBvYmplY3RzIGNhdXNlIHByZW1hdHVyZSBlbmQgdG8gc2xpZGluZ1xuICAgICAgICBsZXQgZGFtYWdlVHlwZSA9IG51bGw7XG4gICAgICAgIGlmICghcGxheWVyU3RhdHVzSW5mby5pbW11bmUpIHtcbiAgICAgICAgICAgIGlmIChjb2xsaXNpb25PYmplY3Qua2luZCA9PT0gXCJzdXJmYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdXJmYWNlUHJvcGVydGllcyA9IGNvbGxpc2lvbk9iamVjdC5zdXJmYWNlWzJdO1xuICAgICAgICAgICAgICAgIGlmIChzdXJmYWNlUHJvcGVydGllcyAhPT0gbnVsbCAmJiBzdXJmYWNlUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhbWFnZVR5cGUgPSBzdXJmYWNlUHJvcGVydGllcy5kYW1hZ2VUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbGxpc2lvbk9iamVjdC5raW5kID09PSBcImNvcm5lclwiKSB7XG4gICAgICAgICAgICAgICAgZGFtYWdlVHlwZSA9IGNvbGxpc2lvbk9iamVjdC5kYW1hZ2VUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYW1hZ2VUeXBlICE9PSBudWxsICYmIGRhbWFnZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbk9iamVjdC5raW5kID09PSBcInN1cmZhY2VcIikge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCInc2xpZGVFQ0InOiBzbGlkaW5nIGludGVycnVwdGVkIGJ5IGNvbGxpc2lvbiB3aXRoIGRhbWFnaW5nIHN1cmZhY2UuXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRUNCOiBtaWRFQ0IsXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBcInN1cmZhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbGxpc2lvbk9iamVjdC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbGxpc2lvbk9iamVjdC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB0OiBjb2xsaXNpb25PYmplY3QucHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1hZ2VUeXBlOiBkYW1hZ2VUeXBlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIidzbGlkZUVDQic6IHNsaWRpbmcgaW50ZXJydXB0ZWQgYnkgY29sbGlzaW9uIHdpdGggZGFtYWdpbmcgY29ybmVyLlwiKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImVuZFwiLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbEVDQjogbWlkRUNCLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJjb3JuZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXI6IGNvbGxpc2lvbk9iamVjdC5hbmd1bGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGFtYWdlVHlwZTogZGFtYWdlVHlwZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZWxzZSBpZiAoc2xpZGluZ0FnYWluc3QudHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbk9iamVjdC5raW5kID09PSBcInN1cmZhY2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb2xsaXNpb25PYmplY3QudHlwZSA9PT0gXCJnXCIgfHwgY29sbGlzaW9uT2JqZWN0LnR5cGUgPT09IFwicFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCInc2xpZGVFQ0InOiBzbGlkaW5nIGludGVycnVwdGVkIGJ5IGxhbmRpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJlbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsRUNCOiBtaWRFQ0IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGluZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwic3VyZmFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbGxpc2lvbk9iamVjdC50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjb2xsaXNpb25PYmplY3QuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQ6IGNvbGxpc2lvbk9iamVjdC5wdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIidzbGlkZUVDQic6IGJlZ2lubmluZyBzbGlkZSBvbiBzdXJmYWNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwidHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZEVDQjogbWlkRUNCLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdXJmYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VyZmFjZTogY29sbGlzaW9uT2JqZWN0LnN1cmZhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29sbGlzaW9uT2JqZWN0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQ6IGNvbGxpc2lvbk9iamVjdC5wdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sbGlzaW9uT2JqZWN0LmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIidzbGlkZUVDQic6IGJlZ2lubmluZyBzbGlkZSBvbiBjb3JuZXIuXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwidHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgbWlkRUNCOiBtaWRFQ0IsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJjb3JuZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcjogY29sbGlzaW9uT2JqZWN0LmNvcm5lcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXI6IGNvbGxpc2lvbk9iamVjdC5hbmd1bGFyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGluZ1R5cGUgPSBzbGlkaW5nQWdhaW5zdC50eXBlO1xuICAgICAgICAgICAgaWYgKGNvbGxpc2lvbk9iamVjdC5raW5kID09PSBcInN1cmZhY2VcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1cmZhY2VUeXBlID0gY29sbGlzaW9uT2JqZWN0LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHN1cmZhY2VUeXBlID09PSBzbGlkaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiJ3NsaWRlRUNCJzogdHJhbnNmZXJyaW5nIHNsaWRlIHRvIG5ldyBzdXJmYWNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwidHJhbnNmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZEVDQjogbWlkRUNCLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdXJmYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VyZmFjZTogY29sbGlzaW9uT2JqZWN0LnN1cmZhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29sbGlzaW9uT2JqZWN0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQ6IGNvbGxpc2lvbk9iamVjdC5wdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogY29sbGlzaW9uT2JqZWN0LmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsaWRpbmdUeXBlID09PSBcImNcIiB8fCBzdXJmYWNlVHlwZSA9PT0gXCJjXCIgfHwgc3VyZmFjZVR5cGUgPT09IFwiZ1wiIHx8IHN1cmZhY2VUeXBlID09PSBcInBcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyB3YXkgdG8gY29udGludWUgd2hlbiBvbmUgb2YgdGhlIGludm9sdmVkIHN1cmZhY2VzIGlzIGEgY2VpbGluZyBvciBhIGdyb3VuZFxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiJ3NsaWRlRUNCJzogaW50ZXJydXB0aW5nIHNsaWRpbmcgYmVjYXVzZSBvZiBjb25mbGljdGluZyBzdXJmYWNlIGNvbGxpc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxFQ0I6IG1pZEVDQixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJzdXJmYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29sbGlzaW9uT2JqZWN0LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGNvbGxpc2lvbk9iamVjdC5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdDogY29sbGlzaW9uT2JqZWN0LnB0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiJ3NsaWRlRUNCJzogYmVnaW5uaW5nIEVDQiBzcXVhc2hpbmcgYmVjYXVzZSBvZiBjb25mbGljdGluZyBob3Jpem9udGFsIHN1cmZhY2UgcHVzaG91dC5cIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcInNxdWFzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRUNCOiBtaWRFQ0IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0Z3RFQ0I6IHRndEVDQixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogY29sbGlzaW9uT2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHQ6IGNvbGxpc2lvbk9iamVjdC5wdFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ3VsYXJQYXJhbWV0ZXIgPSBjb2xsaXNpb25PYmplY3QuYW5ndWxhcjtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWRlID0gZ2V0U2FtZUFuZE90aGVyKGFuZ3VsYXJQYXJhbWV0ZXIpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChzbGlkaW5nVHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIidzbGlkZUVDQic6IGludGVycnVwdGluZyBzbGlkaW5nIGJlY2F1c2Ugb2YgY29uZmxpY3RpbmcgY29ybmVyIGNvbGxpc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImVuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxFQ0I6IG1pZEVDQixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogXCJjb3JuZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyOiBhbmd1bGFyUGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsaWRpbmdUeXBlID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgIHx8IChzaWRlID09PSAzICYmIHNsaWRpbmdUeXBlID09PSBcInJcIilcbiAgICAgICAgICAgICAgICAgICAgfHwgKHNpZGUgPT09IDEgJiYgc2xpZGluZ1R5cGUgPT09IFwibFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiJ3NsaWRlRUNCJzogdHJhbnNmZXJyaW5nIHNsaWRlIHRvIG5ldyBjb3JuZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJ0cmFuc2ZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRUNCOiBtaWRFQ0IsIG9iamVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwiY29ybmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyOiBjb2xsaXNpb25PYmplY3QuY29ybmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXI6IGFuZ3VsYXJQYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCInc2xpZGVFQ0InOiBiZWdpbm5pbmcgRUNCIHNxdWFzaGluZyBiZWNhdXNlIG9mIGNvbmZsaWN0aW5nIGhvcml6b250YWwgY29ybmVyIHB1c2hvdXQuXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJzcXVhc2hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZEVDQjogbWlkRUNCLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGd0RUNCOiB0Z3RFQ0IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlOiBzaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBjb2xsaXNpb25PYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbjtcbmZ1bmN0aW9uIGZpbmROZXh0VGFyZ2V0RnJvbVN1cmZhY2Uoc3JjRUNCLCBlY2JwLCB3YWxsLCB3YWxsVHlwZSwgcHQpIHtcbiAgICBsZXQgd2FsbEZvcndhcmQ7XG4gICAgbGV0IHMgPSAxO1xuICAgIGxldCB0Z3RFQ0IgPSBlY2JwO1xuICAgIGxldCBwdXNob3V0ID0gMDtcbiAgICBsZXQgZmluYWwgPSB0cnVlO1xuICAgIGNvbnN0IHNpZ24gPSAod2FsbFR5cGUgPT09IFwibFwiIHx8IHdhbGxUeXBlID09PSBcImNcIikgPyAtMSA6IDE7XG4gICAgY29uc3QgYWRkaXRpb25hbFB1c2hvdXQgPSBzaWduICogZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0O1xuICAgIGNvbnN0IHhPclkgPSAod2FsbFR5cGUgPT09IFwibFwiIHx8IHdhbGxUeXBlID09PSBcInJcIikgPyBcInhcIiA6IFwieVwiO1xuICAgIGlmICh3YWxsVHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgY29uc3Qgd2FsbExlZnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KSh3YWxsLCBcImxcIik7XG4gICAgICAgIGNvbnN0IHdhbGxSaWdodCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKHdhbGwsIFwiclwiKTtcbiAgICAgICAgaWYgKGVjYnBbcHRdLnggPD0gd2FsbFJpZ2h0LnggJiYgZWNicFtwdF0ueCA+PSB3YWxsTGVmdC54KSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcmNlcHQgPSBjb29yZGluYXRlSW50ZXJjZXB0KHZMaW5lVGhyb3VnaChlY2JwW3B0XSksIHdhbGwpO1xuICAgICAgICAgICAgcHVzaG91dCA9IGludGVyY2VwdC55IC0gZWNicFtwdF0ueTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhbGxGb3J3YXJkID0gZWNicFtwdF0ueCA8IHNyY0VDQltwdF0ueCA/IHdhbGxMZWZ0IDogd2FsbFJpZ2h0O1xuICAgICAgICAgICAgcyA9ICh3YWxsRm9yd2FyZC54IC0gc3JjRUNCW3B0XS54KSAvIChlY2JwW3B0XS54IC0gc3JjRUNCW3B0XS54KTtcbiAgICAgICAgICAgIHMgPSBNYXRoLm1pbihNYXRoLm1heChzLCAwKSwgMSk7XG4gICAgICAgICAgICB0Z3RFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEuaW50ZXJwb2xhdGVFQ0IpKHNyY0VDQiwgZWNicCwgcyk7XG4gICAgICAgICAgICBwdXNob3V0ID0gd2FsbEZvcndhcmQueSAtIHRndEVDQltwdF0ueTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2FsbEJvdHRvbSA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKHdhbGwsIFwiYlwiKTtcbiAgICAgICAgY29uc3Qgd2FsbFRvcCA9ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKHdhbGwsIFwidFwiKTtcbiAgICAgICAgaWYgKGVjYnBbcHRdLnkgPD0gd2FsbFRvcC55ICYmIGVjYnBbcHRdLnkgPj0gd2FsbEJvdHRvbS55KSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcmNlcHQgPSBjb29yZGluYXRlSW50ZXJjZXB0KGhMaW5lVGhyb3VnaChlY2JwW3B0XSksIHdhbGwpO1xuICAgICAgICAgICAgcHVzaG91dCA9IGludGVyY2VwdC54IC0gZWNicFtwdF0ueDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhbGxGb3J3YXJkID0gZWNicFtwdF0ueSA8IHNyY0VDQltwdF0ueSA/IHdhbGxCb3R0b20gOiB3YWxsVG9wO1xuICAgICAgICAgICAgcyA9ICh3YWxsRm9yd2FyZC55IC0gc3JjRUNCW3B0XS55KSAvIChlY2JwW3B0XS55IC0gc3JjRUNCW3B0XS55KTtcbiAgICAgICAgICAgIHMgPSBNYXRoLm1pbihNYXRoLm1heChzLCAwKSwgMSk7XG4gICAgICAgICAgICB0Z3RFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEuaW50ZXJwb2xhdGVFQ0IpKHNyY0VDQiwgZWNicCwgcyk7XG4gICAgICAgICAgICBwdXNob3V0ID0gd2FsbEZvcndhcmQueCAtIHRndEVDQltwdF0ueDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA8IDEgfHwgc2lnbiAqIHB1c2hvdXQgPCAwKSB7XG4gICAgICAgIGZpbmFsID0gZmFsc2U7XG4gICAgfVxuICAgIHRndEVDQiA9ICgwLCBlY2JUcmFuc2Zvcm1fMS5tb3ZlRUNCKSh0Z3RFQ0IsICgwLCBWZWMyRF8xLnB1dFhPcllDb29yZCkocHVzaG91dCArIGFkZGl0aW9uYWxQdXNob3V0LCB4T3JZKSk7XG4gICAgKDAsIGRyYXdFQ0JfMS5kcmF3RUNCKShlY2JwLCBcIiM4ZjU0ZmZcIik7XG4gICAgKDAsIGRyYXdFQ0JfMS5kcmF3RUNCKSh0Z3RFQ0IsIFwiIzM1ZjRhYlwiKTtcbiAgICByZXR1cm4gW3RndEVDQiwgZmluYWxdO1xufVxuO1xuZnVuY3Rpb24gZmluZE5leHRUYXJnZXRGcm9tQ29ybmVyKHNyY0VDQiwgZWNicCwgY29ybmVyLCBhbmd1bGFyUGFyYW1ldGVyKSB7XG4gICAgY29uc3QgW3NhbWUsIG90aGVyXSA9IGdldFNhbWVBbmRPdGhlcihhbmd1bGFyUGFyYW1ldGVyKTtcbiAgICBjb25zdCBMUlNpZ24gPSAoc2FtZSA9PT0gMSkgPyAtMSA6IDE7XG4gICAgY29uc3QgVURTaWduID0gKG90aGVyID09PSAyKSA/IC0xIDogMTtcbiAgICBjb25zdCBhZGRpdGlvbmFsUHVzaG91dCA9IExSU2lnbiAqIGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldDtcbiAgICBsZXQgdGd0RUNCID0gZWNicDtcbiAgICBsZXQgcyA9IDE7XG4gICAgbGV0IHB1c2hvdXQgPSAwO1xuICAgIGxldCBmaW5hbCA9IHRydWU7XG4gICAgaWYgKFVEU2lnbiAqIGVjYnBbc2FtZV0ueSA8IFVEU2lnbiAqIGNvcm5lci55KSB7XG4gICAgICAgIHMgPSAoY29ybmVyLnkgLSBzcmNFQ0Jbc2FtZV0ueSkgLyAoZWNicFtzYW1lXS55IC0gc3JjRUNCW3NhbWVdLnkpO1xuICAgICAgICBzID0gTWF0aC5taW4oTWF0aC5tYXgocywgMCksIDEpO1xuICAgICAgICB0Z3RFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEuaW50ZXJwb2xhdGVFQ0IpKHNyY0VDQiwgZWNicCwgcyk7XG4gICAgICAgIHB1c2hvdXQgPSBjb3JuZXIueCAtIHRndEVDQltzYW1lXS54O1xuICAgIH1cbiAgICBlbHNlIGlmIChVRFNpZ24gKiBlY2JwW290aGVyXS55IDwgVURTaWduICogY29ybmVyLnkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0ID0gY29vcmRpbmF0ZUludGVyY2VwdChoTGluZVRocm91Z2goY29ybmVyKSwgW2VjYnBbc2FtZV0sIGVjYnBbb3RoZXJdXSk7XG4gICAgICAgIHB1c2hvdXQgPSBjb3JuZXIueCAtIGludGVyY2VwdC54ICsgYWRkaXRpb25hbFB1c2hvdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzID0gKGNvcm5lci55IC0gc3JjRUNCW290aGVyXS55KSAvIChlY2JwW290aGVyXS55IC0gc3JjRUNCW290aGVyXS55KTtcbiAgICAgICAgcyA9IE1hdGgubWluKE1hdGgubWF4KHMsIDApLCAxKTtcbiAgICAgICAgdGd0RUNCID0gKDAsIGVjYlRyYW5zZm9ybV8xLmludGVycG9sYXRlRUNCKShzcmNFQ0IsIGVjYnAsIHMpO1xuICAgICAgICBwdXNob3V0ID0gY29ybmVyLnggLSB0Z3RFQ0Jbb3RoZXJdLng7XG4gICAgfVxuICAgIGlmIChzIDwgMSB8fCBMUlNpZ24gKiBwdXNob3V0IDwgMCkge1xuICAgICAgICBmaW5hbCA9IGZhbHNlO1xuICAgIH1cbiAgICB0Z3RFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEubW92ZUVDQikodGd0RUNCLCAoMCwgVmVjMkRfMS5wdXRYT3JZQ29vcmQpKHB1c2hvdXQgKyBhZGRpdGlvbmFsUHVzaG91dCwgXCJ4XCIpKTtcbiAgICAoMCwgZHJhd0VDQl8xLmRyYXdFQ0IpKGVjYnAsIFwiIzEwOThjOVwiKTtcbiAgICAoMCwgZHJhd0VDQl8xLmRyYXdFQ0IpKHRndEVDQiwgXCIjNWNiYzEyXCIpO1xuICAgIHJldHVybiBbdGd0RUNCLCBmaW5hbF07XG59XG47XG5mdW5jdGlvbiB1cGRhdGVFQ0JwKHN0YXJ0RUNCLCBlbmRFQ0IsIGVjYnAsIHNsaWRpbmdUeXBlLCBwdCkge1xuICAgIGlmIChzbGlkaW5nVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZWNicDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB4T3JZID0gKHNsaWRpbmdUeXBlID09PSBcImxcIiB8fCBzbGlkaW5nVHlwZSA9PT0gXCJyXCIpID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGlmICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVjYnBbcHRdLCB4T3JZKSAtICgwLCBWZWMyRF8xLmdldFhPcllDb29yZCkoc3RhcnRFQ0JbcHRdLCB4T3JZKSA9PT0gMCkge1xuICAgICAgICAgICAgeE9yWSA9IHhPclkgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICAgICAgIGlmICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVjYnBbcHRdLCB4T3JZKSAtICgwLCBWZWMyRF8xLmdldFhPcllDb29yZCkoc3RhcnRFQ0JbcHRdLCB4T3JZKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9ICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVuZEVDQltwdF0sIHhPclkpIC0gKDAsIFZlYzJEXzEuZ2V0WE9yWUNvb3JkKShzdGFydEVDQltwdF0sIHhPclkpKVxuICAgICAgICAgICAgICAgICAgICAvICgoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKGVjYnBbcHRdLCB4T3JZKSAtICgwLCBWZWMyRF8xLmdldFhPcllDb29yZCkoc3RhcnRFQ0JbcHRdLCB4T3JZKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ID0gKCgwLCBWZWMyRF8xLmdldFhPcllDb29yZCkoZW5kRUNCW3B0XSwgeE9yWSkgLSAoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKHN0YXJ0RUNCW3B0XSwgeE9yWSkpXG4gICAgICAgICAgICAgICAgLyAoKDAsIFZlYzJEXzEuZ2V0WE9yWUNvb3JkKShlY2JwW3B0XSwgeE9yWSkgLSAoMCwgVmVjMkRfMS5nZXRYT3JZQ29vcmQpKHN0YXJ0RUNCW3B0XSwgeE9yWSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaWRFQ0I7XG4gICAgICAgIGlmICh0IDw9IDApIHtcbiAgICAgICAgICAgIG1pZEVDQiA9IHN0YXJ0RUNCO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgPj0gMSkge1xuICAgICAgICAgICAgbWlkRUNCID0gZWNicDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pZEVDQiA9ICgwLCBlY2JUcmFuc2Zvcm1fMS5pbnRlcnBvbGF0ZUVDQikoc3RhcnRFQ0IsIGVjYnAsIHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbKDAsIGxpbkFsZ18xLmFkZCkoZWNicFswXSwgKDAsIGxpbkFsZ18xLnN1YnRyYWN0KShlbmRFQ0JbMF0sIG1pZEVDQlswXSkpLFxuICAgICAgICAgICAgKDAsIGxpbkFsZ18xLmFkZCkoZWNicFsxXSwgKDAsIGxpbkFsZ18xLnN1YnRyYWN0KShlbmRFQ0JbMV0sIG1pZEVDQlsxXSkpLFxuICAgICAgICAgICAgKDAsIGxpbkFsZ18xLmFkZCkoZWNicFsyXSwgKDAsIGxpbkFsZ18xLnN1YnRyYWN0KShlbmRFQ0JbMl0sIG1pZEVDQlsyXSkpLFxuICAgICAgICAgICAgKDAsIGxpbkFsZ18xLmFkZCkoZWNicFszXSwgKDAsIGxpbkFsZ18xLnN1YnRyYWN0KShlbmRFQ0JbM10sIG1pZEVDQlszXSkpXG4gICAgICAgIF07XG4gICAgfVxufVxuO1xuLy8gdGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCB3aGVuIHR3byB3YWxscyAob3IgY29ybmVycykgYXJlIHRyeWluZyB0byBwdXNoIGhvcml6b250YWxseSBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXG4vLyB0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIGEgc3F1YXNoZWQgRUNCIHRoYXQgd2lsbCBmaXQgaW4gYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMgdGhhdCBhcmUgc3F1ZWV6aW5nIGl0XG5mdW5jdGlvbiBhZ3JlZU9uVGFyZ2V0RUNCKHNyY0VDQiwgZnN0VGd0RUNCLCBzbmRUZ3RFQ0IsIGVjYnAsIHB0LCBncm91bmRlZCkge1xuICAgIGxldCBvdXRwdXQ7XG4gICAgY29uc3QgZmxpcFB0ID0gcHQgPT09IDEgPyAzIDogMTtcbiAgICBjb25zdCBbY2xvc2VzdFRndEVDQiwgZnVydGhlc3RUZ3RFQ0IsIHNhbWVdID0gKE1hdGguYWJzKGZzdFRndEVDQltwdF0ueSAtIHNyY0VDQltwdF0ueSkgPCBNYXRoLmFicyhzbmRUZ3RFQ0JbZmxpcFB0XS55IC0gc3JjRUNCW2ZsaXBQdF0ueSkpXG4gICAgICAgID8gKFtmc3RUZ3RFQ0IsIHNuZFRndEVDQiwgcHRdKVxuICAgICAgICA6IChbc25kVGd0RUNCLCBmc3RUZ3RFQ0IsIGZsaXBQdF0pO1xuICAgIGNvbnN0IGRpZmYgPSBzYW1lID09PSAxID8gMyA6IDE7XG4gICAgbGV0IG90aGVyVGd0RUNCO1xuICAgIGlmIChmdXJ0aGVzdFRndEVDQltkaWZmXS55ID09PSBzcmNFQ0JbZGlmZl0ueSkge1xuICAgICAgICBvdGhlclRndEVDQiA9IGZ1cnRoZXN0VGd0RUNCO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdCA9IChjbG9zZXN0VGd0RUNCW3NhbWVdLnkgLSBzcmNFQ0Jbc2FtZV0ueSkgLyAoZnVydGhlc3RUZ3RFQ0JbZGlmZl0ueSAtIHNyY0VDQltkaWZmXS55KTtcbiAgICAgICAgaWYgKHQgPD0gMCkge1xuICAgICAgICAgICAgb3RoZXJUZ3RFQ0IgPSBzcmNFQ0I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodCA+PSAxKSB7XG4gICAgICAgICAgICBvdGhlclRndEVDQiA9IGZ1cnRoZXN0VGd0RUNCO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3RoZXJUZ3RFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEuaW50ZXJwb2xhdGVFQ0IpKHNyY0VDQiwgZnVydGhlc3RUZ3RFQ0IsIHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRndEVDQiA9IFtuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKSwgbmV3IFZlYzJEXzEuVmVjMkQoMCwgMCksIG5ldyBWZWMyRF8xLlZlYzJEKDAsIDApLCBuZXcgVmVjMkRfMS5WZWMyRCgwLCAwKV07IC8vIGluaXRpYWxpc2luZ1xuICAgIGxldCBhYm9ydDtcbiAgICBsZXQgc3F1YXNoRmFjdG9yID0gMTtcbiAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKGNsb3Nlc3RUZ3RFQ0Jbc2FtZV0ueCAtIGNsb3Nlc3RUZ3RFQ0JbZGlmZl0ueCk7XG4gICAgLy8gaWRlYWxseSB3ZSB3b3VsZCBub3cgc3F1YXNoIHRoZSBFQ0IsIHNvIHRoYXQgaXQgaGFzIHNpZGUgcG9pbnRzIG90aGVyVGd0RUNCW3NhbWVdIGFuZCBjbG9zZXN0VGd0RUNCW2RpZmZdXG4gICAgLy8gaG93ZXZlciB3ZSBjYW4ndCBkbyB0aGF0IGlmIHRoZXNlIHBvaW50cyBhcmUgdG9vIGNsb3NlIHRvZ2V0aGVyLCBvciwgZXZlbiB3b3JzZSwgaGF2ZSBtb3ZlZCBwYXN0IGVhY2hvdGhlclxuICAgIGlmIChNYXRoLmFicyhvdGhlclRndEVDQltzYW1lXS54IC0gY2xvc2VzdFRndEVDQltkaWZmXS54KSA+IGV4cG9ydHMuc21hbGxlc3RFQ0JXaWR0aFxuICAgICAgICAmJiBNYXRoLnNpZ24ob3RoZXJUZ3RFQ0Jbc2FtZV0ueCAtIGNsb3Nlc3RUZ3RFQ0JbZGlmZl0ueCkgPT09IHNpZ24pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKG90aGVyVGd0RUNCW3NhbWVdLnggLSBjbG9zZXN0VGd0RUNCW2RpZmZdLngpID4gTWF0aC5hYnMoY2xvc2VzdFRndEVDQltzYW1lXS54IC0gY2xvc2VzdFRndEVDQltkaWZmXS54KSkge1xuICAgICAgICAgICAgYWJvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJ2FncmVlT25UYXJnZXRFQ0InIHdhcm5pbmc6IGZ1bmN0aW9uIGNhbGxlZCB3aGVuIG5vIHNxdWFzaGluZyB3YXMgcmVxdWlyZWQuXCIpO1xuICAgICAgICAgICAgb3V0cHV0ID0gW2Nsb3Nlc3RUZ3RFQ0IsIGFib3J0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFib3J0ID0gZmFsc2U7XG4gICAgICAgICAgICBzcXVhc2hGYWN0b3IgPSAob3RoZXJUZ3RFQ0Jbc2FtZV0ueCAtIGNsb3Nlc3RUZ3RFQ0JbZGlmZl0ueCkgLyAoY2xvc2VzdFRndEVDQltzYW1lXS54IC0gY2xvc2VzdFRndEVDQltkaWZmXS54KTtcbiAgICAgICAgICAgIHRndEVDQltzYW1lXSA9IG5ldyBWZWMyRF8xLlZlYzJEKG90aGVyVGd0RUNCW3NhbWVdLnggLSBzaWduICogZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0LCBvdGhlclRndEVDQltzYW1lXS55KTtcbiAgICAgICAgICAgIHRndEVDQltkaWZmXSA9IG5ldyBWZWMyRF8xLlZlYzJEKGNsb3Nlc3RUZ3RFQ0JbZGlmZl0ueCArIHNpZ24gKiBleHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQsIGNsb3Nlc3RUZ3RFQ0JbZGlmZl0ueSk7XG4gICAgICAgICAgICB0Z3RFQ0JbMl0ueSA9IHRndEVDQltzYW1lXS55ICsgc3F1YXNoRmFjdG9yICogKGNsb3Nlc3RUZ3RFQ0JbMl0ueSAtIGNsb3Nlc3RUZ3RFQ0Jbc2FtZV0ueSk7XG4gICAgICAgICAgICB0Z3RFQ0JbMF0ueSA9IGdyb3VuZGVkID8gc3JjRUNCWzBdLnkgOiB0Z3RFQ0Jbc2FtZV0ueSArIHNxdWFzaEZhY3RvciAqIChjbG9zZXN0VGd0RUNCWzBdLnkgLSBjbG9zZXN0VGd0RUNCW3NhbWVdLnkpO1xuICAgICAgICAgICAgdGd0RUNCWzJdLnggPSAodGd0RUNCWzFdLnggKyB0Z3RFQ0JbM10ueCkgLyAyO1xuICAgICAgICAgICAgdGd0RUNCWzBdLnggPSAodGd0RUNCWzFdLnggKyB0Z3RFQ0JbM10ueCkgLyAyO1xuICAgICAgICAgICAgb3V0cHV0ID0gW3RndEVDQiwgYWJvcnRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBjYW4ndCBkaXJlY3RseSBzcXVhc2gsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBhbGxvd2FibGUgaGVpZ2h0XG4gICAgICAgIGNvbnN0IHNhbWVMaW5lID0gW3NyY0VDQltzYW1lXSwgb3RoZXJUZ3RFQ0Jbc2FtZV1dO1xuICAgICAgICBjb25zdCBkaWZmTGluZSA9IFtzcmNFQ0JbZGlmZl0sIGNsb3Nlc3RUZ3RFQ0JbZGlmZl1dO1xuICAgICAgICBjb25zdCBvZmZzZXREaWZmTGluZSA9IFsoMCwgbGluQWxnXzEuYWRkKShkaWZmTGluZVswXSwgbmV3IFZlYzJEXzEuVmVjMkQoc2lnbiAqIGV4cG9ydHMuc21hbGxlc3RFQ0JXaWR0aCwgMCkpLFxuICAgICAgICAgICAgKDAsIGxpbkFsZ18xLmFkZCkoZGlmZkxpbmVbMV0sIG5ldyBWZWMyRF8xLlZlYzJEKHNpZ24gKiBleHBvcnRzLnNtYWxsZXN0RUNCV2lkdGgsIDApKV07XG4gICAgICAgIGNvbnN0IGludGVyY2VwdCA9IGNvb3JkaW5hdGVJbnRlcmNlcHQoc2FtZUxpbmUsIG9mZnNldERpZmZMaW5lKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGNsb3Nlc3RUZ3RFQ0Jbc2FtZV0ueSAtIHNyY0VDQltzYW1lXS55KSA+PSBNYXRoLmFicyhpbnRlcmNlcHQueSAtIHNyY0VDQltzYW1lXS55KSkge1xuICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgdGd0RUNCW3NhbWVdID0gbmV3IFZlYzJEXzEuVmVjMkQoaW50ZXJjZXB0LnggKyBzaWduICogZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0LCBpbnRlcmNlcHQueSk7XG4gICAgICAgICAgICB0Z3RFQ0JbZGlmZl0gPSBuZXcgVmVjMkRfMS5WZWMyRChpbnRlcmNlcHQueCAtIHNpZ24gKiBleHBvcnRzLnNtYWxsZXN0RUNCV2lkdGggLSBzaWduICogZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0LCBpbnRlcmNlcHQueSk7XG4gICAgICAgICAgICBzcXVhc2hGYWN0b3IgPSAodGd0RUNCW3NhbWVdLnggLSB0Z3RFQ0JbZGlmZl0ueCkgLyAoY2xvc2VzdFRndEVDQltzYW1lXS54IC0gY2xvc2VzdFRndEVDQltkaWZmXS54KTtcbiAgICAgICAgICAgIHRndEVDQlsyXS55ID0gdGd0RUNCW3NhbWVdLnkgKyBzcXVhc2hGYWN0b3IgKiAoY2xvc2VzdFRndEVDQlsyXS55IC0gY2xvc2VzdFRndEVDQltzYW1lXS55KTtcbiAgICAgICAgICAgIHRndEVDQlswXS55ID0gZ3JvdW5kZWQgPyBzcmNFQ0JbMF0ueSA6IHRndEVDQltzYW1lXS55ICsgc3F1YXNoRmFjdG9yICogKGNsb3Nlc3RUZ3RFQ0JbMF0ueSAtIGNsb3Nlc3RUZ3RFQ0Jbc2FtZV0ueSk7XG4gICAgICAgICAgICB0Z3RFQ0JbMl0ueCA9ICh0Z3RFQ0JbMV0ueCArIHRndEVDQlszXS54KSAvIDI7XG4gICAgICAgICAgICB0Z3RFQ0JbMF0ueCA9ICh0Z3RFQ0JbMV0ueCArIHRndEVDQlszXS54KSAvIDI7XG4gICAgICAgICAgICBvdXRwdXQgPSBbdGd0RUNCLCBhYm9ydF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYm9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgc3F1YXNoRmFjdG9yID0gKG90aGVyVGd0RUNCW3NhbWVdLnggLSBjbG9zZXN0VGd0RUNCW2RpZmZdLnggLSAyICogc2lnbiAqIGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCkgLyAoY2xvc2VzdFRndEVDQltzYW1lXS54IC0gY2xvc2VzdFRndEVDQltkaWZmXS54KTtcbiAgICAgICAgICAgIGlmIChzcXVhc2hGYWN0b3IgPj0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtjbG9zZXN0VGd0RUNCLCBhYm9ydF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0Z3RFQ0Jbc2FtZV0gPSBuZXcgVmVjMkRfMS5WZWMyRChvdGhlclRndEVDQltzYW1lXS54IC0gc2lnbiAqIGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCwgb3RoZXJUZ3RFQ0Jbc2FtZV0ueSk7XG4gICAgICAgICAgICAgICAgdGd0RUNCW2RpZmZdID0gbmV3IFZlYzJEXzEuVmVjMkQoY2xvc2VzdFRndEVDQltkaWZmXS54ICsgc2lnbiAqIGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCwgY2xvc2VzdFRndEVDQltkaWZmXS55KTtcbiAgICAgICAgICAgICAgICB0Z3RFQ0JbMl0ueSA9IHRndEVDQltzYW1lXS55ICsgc3F1YXNoRmFjdG9yICogKGNsb3Nlc3RUZ3RFQ0JbMl0ueSAtIGNsb3Nlc3RUZ3RFQ0Jbc2FtZV0ueSk7XG4gICAgICAgICAgICAgICAgdGd0RUNCWzBdLnkgPSBncm91bmRlZCA/IHNyY0VDQlswXS55IDogdGd0RUNCW3NhbWVdLnkgKyBzcXVhc2hGYWN0b3IgKiAoY2xvc2VzdFRndEVDQlswXS55IC0gY2xvc2VzdFRndEVDQltzYW1lXS55KTtcbiAgICAgICAgICAgICAgICB0Z3RFQ0JbMl0ueCA9ICh0Z3RFQ0JbMV0ueCArIHRndEVDQlszXS54KSAvIDI7XG4gICAgICAgICAgICAgICAgdGd0RUNCWzBdLnggPSAodGd0RUNCWzFdLnggKyB0Z3RFQ0JbM10ueCkgLyAyO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFt0Z3RFQ0IsIGFib3J0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgZHJhd0VDQl8xLmRyYXdFQ0IpKHRndEVDQiwgXCIjZjk0ODJjXCIpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjb252ZXJ0IGJldHdlZW4gYW5ndWxhciBwYXJhbWV0ZXJzIGFuZCBcInNhbWUvb3RoZXJcIiBkYXRhXG5mdW5jdGlvbiBnZXRBbmd1bGFyUGFyYW1ldGVyKHQsIHNhbWUsIG90aGVyKSB7XG4gICAgaWYgKHNhbWUgPT09IDMgJiYgb3RoZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICgoMSAtIHQpICogMyArIHQgKiA0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2FtZSA9PT0gMCAmJiBvdGhlciA9PT0gMykge1xuICAgICAgICByZXR1cm4gKCgxIC0gdCkgKiA0ICsgdCAqIDMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICgoMSAtIHQpICogc2FtZSArIHQgKiBvdGhlcik7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gZ2V0U2FtZUFuZE90aGVyKGEpIHtcbiAgICBpZiAoYSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAwXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA8IDIpIHtcbiAgICAgICAgcmV0dXJuIFsxLCAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA8IDMpIHtcbiAgICAgICAgcmV0dXJuIFszLCAyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbMywgMF07XG4gICAgfVxufVxuO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZnVuY3Rpb24gdG8gY2hlY2sgd2hldGhlciBncm91bmRlZCBtb3ZlbWVudCBpcyBwZXJtaXNzaWJsZSAobm8gbG93IGNlaWxpbmdzKVxuZnVuY3Rpb24gbW92ZUFsb25nR3JvdW5kKHBvcywgcG9zTmV4dCwgZWNiSGVpZ2h0LCBncm91bmQsIGNlaWxpbmdzKSB7XG4gICAgaWYgKHBvcy54ID09PSBwb3NOZXh0LngpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkaXIgPSBwb3NOZXh0LnggPCBwb3MueCA/IFwibFwiIDogXCJyXCI7XG4gICAgICAgIGNvbnN0IGdyb3VuZExlZnQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShncm91bmQsIFwibFwiKTtcbiAgICAgICAgY29uc3QgZ3JvdW5kUmlnaHQgPSAoMCwgZXh0cmVtZVBvaW50XzEuZXh0cmVtZVBvaW50KShncm91bmQsIFwiclwiKTtcbiAgICAgICAgaWYgKChkaXIgPT09IFwibFwiICYmIHBvcy54IDwgZ3JvdW5kTGVmdC54KVxuICAgICAgICAgICAgfHwgKGRpciA9PT0gXCJyXCIgJiYgcG9zLnggPiBncm91bmRSaWdodC54KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGRpciA9PT0gXCJsXCIgPyBNYXRoLm1pbihwb3MueCwgZ3JvdW5kUmlnaHQueCkgOiBNYXRoLm1heChwb3MueCwgZ3JvdW5kTGVmdC54KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGRpciA9PT0gXCJsXCIgPyBNYXRoLm1heChwb3NOZXh0LngsIGdyb3VuZExlZnQueCkgOiBNYXRoLm1pbihwb3NOZXh0LngsIGdyb3VuZFJpZ2h0LngpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdW5kU3RhcnQgPSBjb29yZGluYXRlSW50ZXJjZXB0KGdyb3VuZCwgdkxpbmVBdChzdGFydCkpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdW5kRW5kID0gY29vcmRpbmF0ZUludGVyY2VwdChncm91bmQsIHZMaW5lQXQoZW5kKSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEubWFrZUVDQikoZ3JvdW5kU3RhcnQsIGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCwgZXhwb3J0cy5zbWFsbGVzdEVDQkhlaWdodCk7XG4gICAgICAgICAgICBsZXQgZW5kRUNCID0gKDAsIGVjYlRyYW5zZm9ybV8xLm1ha2VFQ0IpKGdyb3VuZEVuZCwgZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0LCBleHBvcnRzLnNtYWxsZXN0RUNCSGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsbGVkQ2VpbGluZ3MgPSAoMCwgemlwTGFiZWxzXzEuemlwTGFiZWxzKShjZWlsaW5ncywgXCJjXCIpOyAvLyBzaG91bGQgbm90IHJlY2FsY3VsYXRlIHRoaXMgZXZlcnkgdGltZS4uLlxuICAgICAgICAgICAgbGV0IGZpcnN0Q2VpbGluZ0NvbGxpc2lvbiA9IGZpbmRDbG9zZXN0Q29sbGlzaW9uKHN0YXJ0RUNCLCBlbmRFQ0IsIGxhYmVsbGVkQ2VpbGluZ3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2VpbGluZ0NvbGxpc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChlY2JIZWlnaHQgPiBleHBvcnRzLnNtYWxsZXN0RUNCSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gYSBzZWNvbmQgY29sbGlzaW9uIGNoZWNrLCBpbiBjYXNlIHRoZSBwbGF5ZXIgc3F1ZWV6ZWQgdGhlbXNlbHZlcyBpbnRvIGEgbG9jYXRpb24gdGhleSBzaG91bGQgbm90IGhhdmVcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEubWFrZUVDQikoZ3JvdW5kU3RhcnQsIGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCAvIDEwLCBlY2JIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbmRFQ0IgPSAoMCwgZWNiVHJhbnNmb3JtXzEubWFrZUVDQikoZ3JvdW5kRW5kLCBleHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQgLyAxMCwgZWNiSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDZWlsaW5nQ29sbGlzaW9uID0gZmluZENsb3Nlc3RDb2xsaXNpb24oc3RhcnRFQ0IsIGVuZEVDQiwgbGFiZWxsZWRDZWlsaW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdENlaWxpbmdDb2xsaXNpb24gPT09IG51bGwgfHwgZmlyc3RDZWlsaW5nQ29sbGlzaW9uLm9iamVjdC5raW5kID09PSBcImNvcm5lclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlaWxpbmcgPSBmaXJzdENlaWxpbmdDb2xsaXNpb24ub2JqZWN0LnN1cmZhY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHdoZXJlIHRvIHJlcG9zaXRpb24gdGhlIHBsYXllciBieSBpbnRlcnNlY3RpbmcgdGhlIG9mZnNldCBncm91bmQgd2l0aCB0aGUgY2VpbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJjZXB0ID0gY29vcmRpbmF0ZUludGVyY2VwdChjZWlsaW5nLCBbKDAsIGxpbkFsZ18xLmFkZCkoZ3JvdW5kU3RhcnQsIG5ldyBWZWMyRF8xLlZlYzJEKDAsIGV4cG9ydHMuc21hbGxlc3RFQ0JIZWlnaHQpKSwgKDAsIGxpbkFsZ18xLmFkZCkoZ3JvdW5kRW5kLCBuZXcgVmVjMkRfMS5WZWMyRCgwLCBleHBvcnRzLnNtYWxsZXN0RUNCSGVpZ2h0KSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkaXIgPT09IFwibFwiICYmIGludGVyY2VwdC54ID4gcG9zLngpIHx8IChkaXIgPT09IFwiclwiICYmIGludGVyY2VwdC54IDwgcG9zLngpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcy54O1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJjZXB0Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJjZXB0LnggKyAoZGlyID09PSBcImxcIiA/IGV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCA6IC1leHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGZpcnN0Q2VpbGluZ0NvbGxpc2lvbi5zd2VlcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDEgLSBzKSAqIHBvcy54ICsgcyAqIHBvc05leHQueCArIChkaXIgPT09IFwibFwiID8gZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0IDogLWV4cG9ydHMuYWRkaXRpb25hbE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFQ0Igc3F1YXNoaW5nIGFuZCByZS1pbmZsYXRpbmdcbi8vIGZpbmRzIHRoZSBFQ0Igc3F1YXNoIGZhY3RvciBmb3IgYSBncm91bmRlZCBFQ0JcbmZ1bmN0aW9uIGdyb3VuZGVkRUNCU3F1YXNoRmFjdG9yKGVjYlRvcCwgZWNiQm90dG9tLCBjZWlsaW5ncykge1xuICAgIGNvbnN0IGNlaWxpbmdZVmFsdWVzID0gY2VpbGluZ3MubWFwKChjZWlsKSA9PiB7XG4gICAgICAgIGlmIChlY2JUb3AueCA8ICgwLCBleHRyZW1lUG9pbnRfMS5leHRyZW1lUG9pbnQpKGNlaWwsIFwibFwiKS54IHx8IGVjYlRvcC54ID4gKDAsIGV4dHJlbWVQb2ludF8xLmV4dHJlbWVQb2ludCkoY2VpbCwgXCJyXCIpLngpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVJbnRlcmNlcHQoW2VjYkJvdHRvbSwgZWNiVG9wXSwgY2VpbCkueTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGxvd2VzdENlaWxpbmdZVmFsdWUgPSAoMCwgZmluZFNtYWxsZXN0V2l0aGluXzEuZmluZFNtYWxsZXN0V2l0aGluKShjZWlsaW5nWVZhbHVlcywgZWNiQm90dG9tLnksIGVjYlRvcC55KTtcbiAgICBjb25zdCBvZmZzZXQgPSBleHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQgLyAxMDtcbiAgICBpZiAobG93ZXN0Q2VpbGluZ1lWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5tYXgob2Zmc2V0LCAobG93ZXN0Q2VpbGluZ1lWYWx1ZSAtIGVjYkJvdHRvbS55KSAvIChlY2JUb3AueSAtIGVjYkJvdHRvbS55KSAtIG9mZnNldCkpO1xuICAgIH1cbn1cbjtcbi8vIGZpbmRzIHRoZSBFQ0Igc3F1YXNoIGZhY3RvciBieSBpbmZsYXRpbmcgdGhlIEVDQiBmcm9tIHRoZSBwb2ludCBvbiB0aGUgRUNCIGdpdmVuIGJ5IHRoZSBhbmd1bGFyIHBhcmFtZXRlciB0XG4vLyBpZiBhbmd1bGFyIHBhcmFtZXRlciBpcyBudWxsLCBpbnN0ZWFkIGluZmxhdGVzIHRoZSBFQ0IgZnJvbSBpdHMgY2VudGVyXG5mdW5jdGlvbiBpbmZsYXRlRUNCKGVjYiwgdCwgZm9jdXMsIHJlbGV2YW50U3VyZmFjZXMpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBleHBvcnRzLmFkZGl0aW9uYWxPZmZzZXQgLyAxMDtcbiAgICBjb25zdCBwb2ludGxpa2VFQ0IgPSBbbmV3IFZlYzJEXzEuVmVjMkQoZm9jdXMueCwgZm9jdXMueSAtIG9mZnNldCksXG4gICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKGZvY3VzLnggKyBvZmZzZXQsIGZvY3VzLnkpLFxuICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChmb2N1cy54LCBmb2N1cy55ICsgb2Zmc2V0KSxcbiAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQoZm9jdXMueCAtIG9mZnNldCwgZm9jdXMueSlcbiAgICBdO1xuICAgIGNvbnN0IGNsb3Nlc3RDb2xsaXNpb24gPSBmaW5kQ2xvc2VzdENvbGxpc2lvbihwb2ludGxpa2VFQ0IsIGVjYiwgcmVsZXZhbnRTdXJmYWNlcyk7XG4gICAgaWYgKGNsb3Nlc3RDb2xsaXNpb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgbG9jYXRpb246IHQsIGZhY3RvcjogMSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3TG9jYXRpb24gPSB0ID09PSBudWxsXG4gICAgICAgICAgICA/IGNsb3Nlc3RDb2xsaXNpb24ub2JqZWN0LmtpbmQgPT09IFwic3VyZmFjZVwiXG4gICAgICAgICAgICAgICAgPyBjbG9zZXN0Q29sbGlzaW9uLm9iamVjdC5wdFxuICAgICAgICAgICAgICAgIDogY2xvc2VzdENvbGxpc2lvbi5vYmplY3QuYW5ndWxhclxuICAgICAgICAgICAgOiB0O1xuICAgICAgICByZXR1cm4geyBsb2NhdGlvbjogbmV3TG9jYXRpb24sIGZhY3RvcjogTWF0aC5tYXgoZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0LCBjbG9zZXN0Q29sbGlzaW9uLnN3ZWVwIC0gZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0KSB9OyAvLyBFQ0IgYW5ndWxhciBwYXJhbWV0ZXIsIHN3ZWVwaW5nIHBhcmFtZXRlclxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlaW5mbGF0ZUVDQihlY2IsIHBvc2l0aW9uLCByZWxldmFudFN1cmZhY2VzLCBvbGRlY2JTcXVhc2hEYXR1bSwgZ3JvdW5kZWQpIHtcbiAgICBsZXQgcSA9IDE7XG4gICAgY29uc3QgYW5ndWxhclBhcmFtZXRlciA9IG9sZGVjYlNxdWFzaERhdHVtLmxvY2F0aW9uO1xuICAgIGlmIChvbGRlY2JTcXVhc2hEYXR1bS5mYWN0b3IgPCAxKSB7XG4gICAgICAgIHEgPSAxIC8gb2xkZWNiU3F1YXNoRGF0dW0uZmFjdG9yICsgZXhwb3J0cy5hZGRpdGlvbmFsT2Zmc2V0IC8gMjA7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gKDAsIGVjYlRyYW5zZm9ybV8xLmVjYkZvY3VzRnJvbUFuZ3VsYXJQYXJhbWV0ZXIpKGVjYiwgYW5ndWxhclBhcmFtZXRlcik7XG4gICAgICAgIGNvbnN0IGZ1bGxzaXplZWNiID0gW25ldyBWZWMyRF8xLlZlYzJEKHEgKiBlY2JbMF0ueCArICgxIC0gcSkgKiBmb2N1cy54LCBxICogZWNiWzBdLnkgKyAoMSAtIHEpICogZm9jdXMueSksXG4gICAgICAgICAgICBuZXcgVmVjMkRfMS5WZWMyRChxICogZWNiWzFdLnggKyAoMSAtIHEpICogZm9jdXMueCwgcSAqIGVjYlsxXS55ICsgKDEgLSBxKSAqIGZvY3VzLnkpLFxuICAgICAgICAgICAgbmV3IFZlYzJEXzEuVmVjMkQocSAqIGVjYlsyXS54ICsgKDEgLSBxKSAqIGZvY3VzLngsIHEgKiBlY2JbMl0ueSArICgxIC0gcSkgKiBmb2N1cy55KSxcbiAgICAgICAgICAgIG5ldyBWZWMyRF8xLlZlYzJEKHEgKiBlY2JbM10ueCArICgxIC0gcSkgKiBmb2N1cy54LCBxICogZWNiWzNdLnkgKyAoMSAtIHEpICogZm9jdXMueSlcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZWNiU3F1YXNoRGF0dW0gPSBpbmZsYXRlRUNCKGZ1bGxzaXplZWNiLCBhbmd1bGFyUGFyYW1ldGVyLCBmb2N1cywgcmVsZXZhbnRTdXJmYWNlcyk7XG4gICAgICAgIGNvbnN0IHNxdWFzaGVkZWNiID0gKDAsIGVjYlRyYW5zZm9ybV8xLnNxdWFzaEVDQkF0KShmdWxsc2l6ZWVjYiwgeyBmYWN0b3I6IGVjYlNxdWFzaERhdHVtLmZhY3RvciwgbG9jYXRpb246IGFuZ3VsYXJQYXJhbWV0ZXIgfSk7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbmV3IFZlYzJEXzEuVmVjMkQocG9zaXRpb24ueCArIHNxdWFzaGVkZWNiWzBdLnggLSBlY2JbMF0ueCwgZ3JvdW5kZWQgPyBwb3NpdGlvbi55IDogcG9zaXRpb24ueSArIHNxdWFzaGVkZWNiWzBdLnkgLSBlY2JbMF0ueSk7XG4gICAgICAgIGNvbnN0IG5ld0FuZ3VsYXIgPSBlY2JTcXVhc2hEYXR1bS5sb2NhdGlvbjtcbiAgICAgICAgKDAsIGRyYXdFQ0JfMS5kcmF3RUNCKShzcXVhc2hlZGVjYiwgXCIjZmZmZjAwXCIpO1xuICAgICAgICByZXR1cm4gW25ld1Bvc2l0aW9uLCBlY2JTcXVhc2hEYXR1bSwgc3F1YXNoZWRlY2JdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtwb3NpdGlvbiwgeyBsb2NhdGlvbjogYW5ndWxhclBhcmFtZXRlciwgZmFjdG9yOiAxIH0sIGVjYl07XG4gICAgfVxufVxuO1xuLy8gcmVjYWxsOiB0eXBlIFBsYXllclN0YXR1c0luZm8gPSB7IGdyb3VuZGVkIDpib29sZWFuLCBpZ25vcmluZ1BsYXRmb3JtcyA6Ym9vbGVhbiwgaW1tdW5lIDpib29sZWFuIH07XG4vLyB0aGlzIGZ1bmN0aW9uIGluaXRpYWxpc2VzIG5lY2Vzc2FyeSBkYXRhIGFuZCB0aGVuIGNhbGxzIHRoZSBtYWluIGNvbGxpc2lvbiByb3V0aW5lIGxvb3BcbmZ1bmN0aW9uIHJ1bkNvbGxpc2lvblJvdXRpbmUoZWNiMSwgZWNicCwgcG9zaXRpb24sIGVjYlNxdWFzaERhdHVtLCBwbGF5ZXJTdGF0dXNJbmZvLCBzdGFnZSkge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQkVMT1c6IHRoaXMgaXMgcmVjb21wdXRlZCBldmVyeSBmcmFtZSBhbmQgc2hvdWxkIGJlIGF2b2lkZWRcbiAgICBjb25zdCBzdGFnZVdhbGxzID0gKDAsIHppcExhYmVsc18xLnppcExhYmVscykoc3RhZ2Uud2FsbEwsIFwibFwiKS5jb25jYXQoKDAsIHppcExhYmVsc18xLnppcExhYmVscykoc3RhZ2Uud2FsbFIsIFwiclwiKSk7XG4gICAgY29uc3Qgc3RhZ2VHcm91bmRzID0gKDAsIHppcExhYmVsc18xLnppcExhYmVscykoc3RhZ2UuZ3JvdW5kLCBcImdcIik7XG4gICAgY29uc3Qgc3RhZ2VDZWlsaW5ncyA9ICgwLCB6aXBMYWJlbHNfMS56aXBMYWJlbHMpKHN0YWdlLmNlaWxpbmcsIFwiY1wiKTtcbiAgICBjb25zdCBzdGFnZVBsYXRmb3JtcyA9ICgwLCB6aXBMYWJlbHNfMS56aXBMYWJlbHMpKHN0YWdlLnBsYXRmb3JtLCBcInBcIik7XG4gICAgLy8gQUJPVkU6IHRoaXMgaXMgcmVjb21wdXRlZCBldmVyeSBmcmFtZSBhbmQgc2hvdWxkIGJlIGF2b2lkZWRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0IGdyb3VuZGVkID0gcGxheWVyU3RhdHVzSW5mby5ncm91bmRlZDtcbiAgICBsZXQgaG9yaXpJZ25vcmUgPSBcIm5vbmVcIjsgLy8gaWdub3JlIG5vIGhvcml6b250YWwgc3VyZmFjZXMgYnkgZGVmYXVsdFxuICAgIGlmIChncm91bmRlZCkge1xuICAgICAgICBob3Jpeklnbm9yZSA9IFwiYWxsXCI7IC8vIGlnbm9yZSBhbGwgaG9yaXpvbnRhbCBzdXJmYWNlcyB3aGVuIGdyb3VuZGVkXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBob3Jpeklnbm9yZSA9IHBsYXllclN0YXR1c0luZm8uaWdub3JpbmdQbGF0Zm9ybXMgPyBcInBsYXRmb3Jtc1wiIDogXCJub25lXCI7XG4gICAgfVxuICAgIGNvbnN0IGFsbFN1cmZhY2VzTWludXNQbGF0Zm9ybXMgPSBzdGFnZVdhbGxzLmNvbmNhdChzdGFnZUdyb3VuZHMpLmNvbmNhdChzdGFnZUNlaWxpbmdzKTtcbiAgICBsZXQgcmVsZXZhbnRTdXJmYWNlcyA9IFtdO1xuICAgIHN3aXRjaCAoaG9yaXpJZ25vcmUpIHtcbiAgICAgICAgY2FzZSBcInBsYXRmb3Jtc1wiOlxuICAgICAgICAgICAgcmVsZXZhbnRTdXJmYWNlcyA9IHN0YWdlV2FsbHMuY29uY2F0KHN0YWdlR3JvdW5kcykuY29uY2F0KHN0YWdlQ2VpbGluZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWxldmFudFN1cmZhY2VzID0gc3RhZ2VXYWxscy5jb25jYXQoc3RhZ2VHcm91bmRzKS5jb25jYXQoc3RhZ2VDZWlsaW5ncykuY29uY2F0KHN0YWdlUGxhdGZvcm1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWxsXCI6XG4gICAgICAgICAgICByZWxldmFudFN1cmZhY2VzID0gc3RhZ2VXYWxscztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uID0gcmVzb2x2ZUVDQihlY2IxLCBlY2JwLCBwbGF5ZXJTdGF0dXNJbmZvLCByZWxldmFudFN1cmZhY2VzKTtcbiAgICBjb25zdCBuZXdUb3VjaGluZyA9IHJlc29sdXRpb24udG91Y2hpbmc7XG4gICAgbGV0IG5ld0VDQnAgPSByZXNvbHV0aW9uLmVjYjtcbiAgICBjb25zdCBuZXdTcXVhc2hGYWN0b3IgPSByZXNvbHV0aW9uLnNxdWFzaGVkID8gTWF0aC5taW4oMSwgKG5ld0VDQnBbMV0ueCAtIG5ld0VDQnBbM10ueCkgLyAoZWNicFsxXS54IC0gZWNicFszXS54KSlcbiAgICAgICAgOiAxO1xuICAgIGxldCBuZXdTcXVhc2hMb2NhdGlvbiA9IG51bGw7XG4gICAgaWYgKG5ld1RvdWNoaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdUb3VjaGluZy5raW5kID09PSBcInN1cmZhY2VcIikge1xuICAgICAgICAgICAgbmV3U3F1YXNoTG9jYXRpb24gPSBuZXdUb3VjaGluZy5wdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NxdWFzaExvY2F0aW9uID0gbmV3VG91Y2hpbmcuYW5ndWxhcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV3U3F1YXNoRGF0dW0gPSB7IGxvY2F0aW9uOiBuZXdTcXVhc2hMb2NhdGlvbiwgZmFjdG9yOiBuZXdTcXVhc2hGYWN0b3IgfTtcbiAgICBuZXdTcXVhc2hEYXR1bS5mYWN0b3IgKj0gZWNiU3F1YXNoRGF0dW0uZmFjdG9yO1xuICAgIGxldCBuZXdQb3NpdGlvbiA9ICgwLCBsaW5BbGdfMS5zdWJ0cmFjdCkoKDAsIGxpbkFsZ18xLmFkZCkocG9zaXRpb24sIG5ld0VDQnBbMF0pLCBlY2JwWzBdKTtcbiAgICBpZiAobmV3U3F1YXNoRGF0dW0uZmFjdG9yIDwgMSkge1xuICAgICAgICBsZXQgc3F1YXNoaW5nTG9jYXRpb24gPSBudWxsO1xuICAgICAgICBpZiAoZ3JvdW5kZWQpIHtcbiAgICAgICAgICAgIHNxdWFzaGluZ0xvY2F0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBbbmV3UG9zaXRpb24sXG4gICAgICAgICAgICBuZXdTcXVhc2hEYXR1bSxcbiAgICAgICAgICAgIG5ld0VDQnBdID0gcmVpbmZsYXRlRUNCKG5ld0VDQnAsIG5ld1Bvc2l0aW9uLCBhbGxTdXJmYWNlc01pbnVzUGxhdGZvcm1zLCB7IGZhY3RvcjogbmV3U3F1YXNoRGF0dW0uZmFjdG9yLCBsb2NhdGlvbjogc3F1YXNoaW5nTG9jYXRpb24gfSwgZ3JvdW5kZWQpO1xuICAgICAgICBpZiAoIWdyb3VuZGVkICYmIG5ld1NxdWFzaERhdHVtLmZhY3RvciA8IDEpIHtcbiAgICAgICAgICAgIC8vIHJlaW5mbGF0ZSBhIHNlY29uZCB0aW1lIGlmIGl0IG1pZ2h0IGhlbHBcbiAgICAgICAgICAgIFtuZXdQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBuZXdTcXVhc2hEYXR1bSxcbiAgICAgICAgICAgICAgICBuZXdFQ0JwXSA9IHJlaW5mbGF0ZUVDQihuZXdFQ0JwLCBuZXdQb3NpdGlvbiwgYWxsU3VyZmFjZXNNaW51c1BsYXRmb3JtcywgbmV3U3F1YXNoRGF0dW0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBwb3NpdGlvbjogbmV3UG9zaXRpb24sIHRvdWNoaW5nOiBuZXdUb3VjaGluZywgc3F1YXNoRGF0dW06IG5ld1NxdWFzaERhdHVtLCBlY2I6IG5ld0VDQnAgfTtcbn1cbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/physics/environmentalCollision.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("1ae217c0cc663eae90db")
/******/ })();
/******/ 
/******/ }
);